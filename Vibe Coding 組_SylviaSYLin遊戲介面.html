<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>像素冒險 - 危險逃脫</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Press Start 2P', monospace;
            background: #000000; /* 黑色背景 */
            overflow: hidden;
            color: white;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        .game-container {
            position: relative;
            background: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameCanvas {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            display: block;
            width: 100vw; /* 左右延伸到邊緣 */
            height: calc(100vh * 513 / 749); /* 按比例動態高度 */
        }
        
        /* 前言背景視窗 */
        .intro-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .intro-content {
            background: url('Vibe Coding 組_SylviaSYLin遊戲介面/assets/story-bg.svg') no-repeat center center;
            background-size: cover;
            border: none;
            border-radius: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .intro-background {
            width: 100%;
            height: 100%;
            min-height: 400px;
        }
        
        .content-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 36px; /* 固定間距 */
        }

        .story-1-container {
            width: 100%;
            display: flex;
            justify-content: center;
        }
        
        .story-1-image {
            width: auto;
            height: auto;
            max-width: 80vw;
            max-height: 60vh; /* 減少高度以留出按鈕空間 */
            opacity: 0;
            animation: fadeIn 1s ease-in-out forwards;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .next-btn-container {
            width: 100%;
            display: flex;
            justify-content: center;
            opacity: 0;
            animation: fadeIn 1s ease-in-out forwards;
        }
        
        .next-btn-image {
            width: auto;
            height: auto;
            max-width: min(200px, 30vw);
            max-height: min(80px, 12vw);
            min-width: 100px;
            min-height: 40px;
            cursor: pointer;
            transition: transform 0.2s ease;
            display: block;
            object-fit: contain;
        }
        
        .next-btn-image:hover {
            transform: scale(1.1);
        }
        
        @keyframes showNextBtn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        /* 失敗畫面視窗 */
        .failure-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1001;
        }
        
        .failure-content {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .failure-background {
            width: 100%;
            height: 100%;
            min-height: 400px;
        }
        
        .failure-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 36px; /* 固定間距 */
        }

        .game-over-container {
            width: 100%;
            display: flex;
            justify-content: center;
        }
        
        .game-over-image {
            width: auto;
            height: auto;
            max-width: 80vw;
            max-height: 60vh; /* 減少高度以留出按鈕空間 */
            opacity: 0;
            animation: fadeIn 1s ease-in-out forwards;
        }
        
        .retry-btn-container {
            width: 100%;
            display: flex;
            justify-content: center;
            opacity: 0;
            animation: fadeIn 1s ease-in-out forwards;
        }
        
        .retry-btn-image {
            width: auto;
            height: auto;
            max-width: min(200px, 30vw);
            max-height: min(80px, 12vw);
            min-width: 100px;
            min-height: 40px;
            cursor: pointer;
            transition: transform 0.2s ease;
            display: block;
            object-fit: contain;
        }
        
        .retry-btn-image:hover {
            transform: scale(1.1);
        }
        
        /* 結局視窗 */
        .ending-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .ending-content {
            background: linear-gradient(45deg, #2d1b69, #11998e);
            border: 4px solid #00ff00;
            padding: 30px;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }
        
        .ending-title {
            font-size: 16px;
            margin-bottom: 20px;
            color: #00ff00;
        }
        
        .ending-text {
            font-size: 10px;
            line-height: 1.6;
            margin-bottom: 20px;
        }
        
        .restart-button {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 15px 30px;
            font-family: inherit;
            font-size: 10px;
            cursor: pointer;
            border: 2px solid #000;
        }
        
        .restart-button:hover {
            background: #ff5252;
            transform: scale(1.05);
        }
        
        .hidden {
            display: none !important;
        }
        
        /* 完全隱藏影片控制界面 */
        video::-webkit-media-controls {
            display: none !important;
        }
        
        video::-webkit-media-controls-panel {
            display: none !important;
        }
        
        video::-webkit-media-controls-play-button {
            display: none !important;
        }
        
        video::-webkit-media-controls-volume-slider {
            display: none !important;
        }
        
        video::-webkit-media-controls-mute-button {
            display: none !important;
        }
        
        video::-webkit-media-controls-timeline {
            display: none !important;
        }
        
        video::-webkit-media-controls-current-time-display {
            display: none !important;
        }
        
        video::-webkit-media-controls-time-remaining-display {
            display: none !important;
        }
        
        video::-webkit-media-controls-fullscreen-button {
            display: none !important;
        }
        
        video::-webkit-media-controls-overlay-play-button {
            display: none !important;
        }
        
        video::-moz-media-controls {
            display: none !important;
        }
        
        /* 確保影片元素本身不顯示任何邊框或焦點輪廓 */
        video {
            outline: none !important;
            border: none !important;
        }
        
    </style>
</head>
<body>
    <div class="game-container">
        <!-- 前言背景視窗 -->
        <div class="intro-modal" id="introModal">
            <div class="intro-content">
                <div class="intro-background">
                    <!-- 這裡可以放置你的前言內容 -->
                </div>
                <div class="content-wrapper">
                    <div class="story-1-container">
                        <img alt="Story 1" class="story-1-image" id="story1Image">
                    </div>
                    <div class="next-btn-container">
                        <img alt="Next Button" class="next-btn-image" id="nextBtnImage">
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 遊戲畫布 -->
        <canvas id="gameCanvas"></canvas>
        
        <!-- 失敗畫面視窗 -->
        <div class="failure-modal" id="failureModal">
            <div class="failure-content">
                <div class="failure-background">
                    <!-- 背景 -->
                </div>
                <div class="failure-wrapper">
                    <div class="game-over-container">
                        <img alt="Game Over" class="game-over-image" id="gameOverImage">
                    </div>
                    <div class="retry-btn-container">
                        <img alt="Retry Button" class="retry-btn-image" id="retryBtnImage">
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 結局視窗 -->
        <div class="ending-modal" id="endingModal">
            <div class="ending-content">
                <div class="ending-title" id="endingTitle"></div>
                <div class="ending-text" id="endingText"></div>
                <button class="restart-button" onclick="restartGame()">重新開始</button>
            </div>
        </div>
    </div>

    <script>
        // 遊戲變數
        let canvas, ctx;
        let gameState = 'intro';
        // 故事相關變數已移除
        let victoryStartTime = null;
        let victoryDuration = 2000;
        let gameLoopId = null;
        
        // 結局相關變數
        let endingState = {
            victoryTriggered: false,      // 是否已觸發勝利
            videoPlayed: false            // 是否已播放過影片
        };
        
        let endingVideo = null; // 結局影片元素
        let endingGifContainer = null; // 結局 GIF 動畫容器
        let gifAnimationInterval = null; // GIF 動畫間隔計時器
        let currentGifFrame = 1; // 當前 GIF 幀（1 或 2）
        
        // 音樂管理系統
        let gameBGM = null;
        let musicVolume = 0.4; // 默認音量40%
        let fadeOutDuration = 2000; // 淡出持續時間2秒
        let fadeInterval = null;
        
        // 按鈕音效管理
        let buttonAudio = null;
        let buttonAudioVolume = 0.5; // 按鈕音效音量50%
        
        // 跳躍音效管理
        let jumpAudio = null;
        let jumpAudioVolume = 0.7; // 跳躍音效音量60%
        let lastJumpAnimation = null; // 追蹤上一次的跳躍動畫狀態
        
        // HP Logo 音效管理
        let hpLogoAudio = null;
        let hpLogoAudioVolume = 0.3; // HP Logo 音效音量30%
        
        // 跑步音效管理
        let runningAudio = null;
        let runningAudioVolume = 0.2; // 跑步音效音量20%
        let isRunningAudioPlaying = false; // 追蹤跑步音效是否正在播放
        
        // 結束音效管理
        let endAudio = null;
        let endAudioVolume = 0.6; // 結束音效音量60%
        
        // Cloud 音效管理
        let cloudAudio = null;
        let cloudAudioVolume = 0.5; // Cloud 音效音量50%
        let isCloudAudioPlaying = false; // 追蹤 Cloud 音效是否正在播放
        let cloudAudioPlayCount = 0; // 追蹤播放次數
        
        // Born 音效管理
        let bornAudio = null;
        let bornAudioVolume = 0.6; // Born 音效音量40%
        let isBornAudioPlaying = false; // 追蹤 Born 音效是否正在播放
        
        // 前言系統變數
        let clickCount = 0; // 追蹤前言按鈕點擊次數
        let isProcessingClick = false; // 防止快速連續點擊
        
        // 背景圖片變數
        let backgroundImage = null;
        let backgroundWidth = 0;
        let backgroundHeight = 0;
        let backgroundLoaded = false;
        
        // 角色動畫系統
        let characterSprites = {
            idle: [],
            running: [],
            jumpPrepare: null, // 準備跳躍圖片 (jump-1)
            jumping: null // 跳躍圖片 (jump-2)
        };
        let currentAnimation = 'idle';
        let animationFrame = 0;
        let lastFrameTime = 0;
        let idleFrameInterval = 300; // 站立動畫：0.3秒換一張
        let runningFrameInterval = 70; // 跑步動畫：0.07秒換一張
        let spritesLoaded = false;
        
        // 跳躍狀態追蹤
        let jumpState = 'none'; // 'none', 'preparing', 'jumping'
        let jumpStartTime = 0;
        let jumpPrepareTime = 0.1 * 1000; // 準備跳躍動畫持續時間：0.03秒（30毫秒）
        
        // 角色大小動態計算
        function calculatePlayerSize() {
            const playerHeightRatio = 75 / 512; // 調整為75像素高度在512背景中的比例 (14.65%) - 提高遊戲挑戰性
            const dynamicHeight = Math.floor(GAME_HEIGHT * playerHeightRatio);
            // 假設角色寬高比為1:1，保持方形比例，如果有特定比例可以調整
            const dynamicWidth = dynamicHeight; // 保持方形，或可根據實際圖片比例調整
            
            return {
                width: dynamicWidth,
                height: dynamicHeight
            };
        }

        // 遊戲物件
        let player = {
            x: 100, y: 0, width: 80, height: 80, // 初始值，會在init時動態計算
            velocityX: 0, velocityY: 0, onGround: false,
            health: 100, maxHealth: 100,
            shieldActive: false, shieldHits: 0,
            facingRight: true,
            alpha: 1,
            controlDisabled: false
        };
        
        let camera = { x: 0, y: 0 };
        
        let world = {
            width: 4000, height: 0, gravity: 0.3, // 增加世界寬度以適應寬屏，高度初始化後設定
            roads: [], endpoint: null
        };
        
        // inventory變數已移除，因為UI元素已移除
        let keys = {};
        
        // 載入背景圖片
        function loadBackgroundImage() {
            backgroundImage = new Image();
            backgroundImage.onload = function() {
                backgroundWidth = this.width;
                backgroundHeight = this.height;
                backgroundLoaded = true;
                console.log('背景圖片載入完成:', backgroundWidth + 'x' + backgroundHeight);
            };
            backgroundImage.onerror = function() {
                console.log('背景圖片載入失敗，使用預設背景');
                backgroundLoaded = false;
            };
            // 使用相對路徑 - 請將您的背景圖片命名為 background.jpg 並放在與此HTML文件相同的目錄中
            backgroundImage.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/background.jpg';
        }
        
        // 載入角色動畫 - 確保正確順序載入
        function loadCharacterSprites() {
            // 重置動畫數組，確保順序正確
            characterSprites.idle = [];
            characterSprites.running = [];
            
            // 站立動畫圖片路徑（SVG格式）
            const idleFramePaths = [
                        'Vibe Coding 組_SylviaSYLin遊戲介面/assets/character-idle-1.svg',
        'Vibe Coding 組_SylviaSYLin遊戲介面/assets/character-idle-2.svg'
            ];
            
            // 跑步動畫圖片路徑（SVG格式） - 按照正確順序
            const runningFramePaths = [
                        'Vibe Coding 組_SylviaSYLin遊戲介面/assets/character-run-1.svg',  // 索引0
        'Vibe Coding 組_SylviaSYLin遊戲介面/assets/character-run-2.svg',  // 索引1
        'Vibe Coding 組_SylviaSYLin遊戲介面/assets/character-run-3.svg',  // 索引2
        'Vibe Coding 組_SylviaSYLin遊戲介面/assets/character-run-4.svg'   // 索引3
            ];
            
            let loadedCount = 0;
            const totalFrames = idleFramePaths.length + runningFramePaths.length;
            
            // 確保按順序載入站立動畫
            function loadIdleAnimation(index) {
                if (index >= idleFramePaths.length) {
                    loadRunningAnimation(0); // 開始載入跑步動畫
                    return;
                }
                
                const img = new Image();
                img.onload = function() {
                    characterSprites.idle[index] = img;
                    loadedCount++;
                    console.log(`✅ 站立動畫 ${index + 1} 載入完成: ${idleFramePaths[index]} (${this.width}x${this.height})`);
                    loadIdleAnimation(index + 1); // 載入下一個
                };
                img.onerror = function() {
                    console.log(`❌ 站立動畫 ${index + 1} 載入失敗: ${idleFramePaths[index]}`);
                    loadIdleAnimation(index + 1); // 繼續載入下一個
                };
                img.src = idleFramePaths[index];
            }
            
            // 確保按順序載入跑步動畫
            function loadRunningAnimation(index) {
                if (index >= runningFramePaths.length) {
                                         // 所有動畫載入完成
                     spritesLoaded = true;
                     console.log('🎉 所有角色動畫載入完成！');
                     console.log('📊 載入結果:');
                     console.log('  站立動畫:', characterSprites.idle.length, '幀');
                     console.log('  跑步動畫:', characterSprites.running.length, '幀');
                     console.log('⏱️ 動畫速度設定:');
                     console.log(`  站立動畫：每${idleFrameInterval}ms切換一幀 (0.3秒)`);
                     console.log(`  跑步動畫：每${runningFrameInterval}ms切換一幀 (0.07秒)`);
                     console.log('🏃 跑步動畫順序確認:');
                     characterSprites.running.forEach((sprite, i) => {
                         console.log(`  索引${i}: ${runningFramePaths[i]} ✅`);
                     });
                     
                     // 驗證動畫完整性
                     console.log('🔍 動畫完整性檢查:');
                     console.log('  預期跑步動畫順序: character-run-1 → character-run-2 → character-run-3 → character-run-4');
                     console.log('  實際載入順序:', characterSprites.running.map((_, i) => `character-run-${i+1}`).join(' → '));
                     
                     if (characterSprites.running.length === 4) {
                         console.log('✅ 跑步動畫載入完整，共4幀');
                     } else {
                         console.log(`❌ 跑步動畫載入不完整，預期4幀，實際${characterSprites.running.length}幀`);
                     }
                    return;
                }
                
                const img = new Image();
                img.onload = function() {
                    characterSprites.running[index] = img;
                    loadedCount++;
                    console.log(`✅ 跑步動畫 ${index + 1} 載入完成: ${runningFramePaths[index]} (${this.width}x${this.height})`);
                    loadRunningAnimation(index + 1); // 載入下一個
                };
                img.onerror = function() {
                    console.log(`❌ 跑步動畫 ${index + 1} 載入失敗: ${runningFramePaths[index]}`);
                    loadRunningAnimation(index + 1); // 繼續載入下一個
                };
                img.src = runningFramePaths[index];
            }
            
            // 開始按順序載入
            loadIdleAnimation(0);
        }

        // 載入跳躍動畫
        function loadJumpSprite() {
            let loadedCount = 0;
            
            // 載入準備跳躍圖片 (jump-1)
            const jumpPrepareImg = new Image();
            jumpPrepareImg.onload = function() {
                characterSprites.jumpPrepare = jumpPrepareImg;
                loadedCount++;
                console.log('✅ 準備跳躍圖片載入完成: jump-1.svg');
                if (loadedCount === 2) {
                    console.log('🏃‍♂️ 所有跳躍圖片載入完成！');
                }
            };
            jumpPrepareImg.onerror = function() {
                console.log('❌ 準備跳躍圖片載入失敗: jump-1.svg');
                loadedCount++;
            };
            jumpPrepareImg.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/jump-1.svg';
            
            // 載入跳躍圖片 (jump-2)
            const jumpImg = new Image();
            jumpImg.onload = function() {
                characterSprites.jumping = jumpImg;
                loadedCount++;
                console.log('✅ 跳躍圖片載入完成: jump-2.svg');
                if (loadedCount === 2) {
                    console.log('🏃‍♂️ 所有跳躍圖片載入完成！');
                }
            };
            jumpImg.onerror = function() {
                console.log('❌ 跳躍圖片載入失敗: jump-2.svg');
                loadedCount++;
            };
            jumpImg.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/jump-2.svg';
        }
        
        // 移除上傳功能 - 直接使用指定的圖片文件
        
        // 遊戲尺寸設定 - 按照 513:749 比例
        const GAME_HEIGHT_RATIO = 513 / 749;  // 遊戲高度與螢幕高度的比例
        let GAME_HEIGHT = Math.floor(window.innerHeight * GAME_HEIGHT_RATIO);  // 動態計算遊戲高度
        let GAME_WIDTH = window.innerWidth;  // 遊戲畫面寬度適應視窗
        
        // 初始化
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // 設置遊戲尺寸
            updateCanvasSize();
            
            // 動態計算並設置角色大小
            const playerSize = calculatePlayerSize();
            player.width = playerSize.width;
            player.height = playerSize.height;
            
            // 設置世界高度等於遊戲高度
            world.height = GAME_HEIGHT;
            
            // 設置玩家初始位置（約遊戲高度的一半）
            player.y = Math.floor(GAME_HEIGHT * 0.5);
            
            // 設置渲染質量
            ctx.imageSmoothingEnabled = false; // 像素風格保持銳利
            canvas.oncontextmenu = function(e) { e.preventDefault(); e.stopPropagation(); }
            
            loadBackgroundImage();
            loadCharacterSprites();
            loadJumpSprite();
            loadRoadImages();
            hpLogoManager.loadImage();
            springManager.loadImages();
            cloudManager.loadImages();
            cloudManager2.loadImages();
            lightningManager.loadImages();
            lightningManager2.loadImages();
            heartManager.loadImages();
            createWorld();
            setupEventListeners();
            updateUI();
            setupStory1Image(); // 設置 story-1 圖片
            
            // 初始化音效系統
            initButtonAudio();
            initJumpAudio();
            initHpLogoAudio();
            initRunningAudio();
            initEndAudio();
            initCloudAudio();
            initBornAudio();
            

            
            gameLoop(); // 啟動遊戲循環以顯示前言背景
        }

        
        // 更新Canvas尺寸
        function updateCanvasSize() {
            GAME_WIDTH = window.innerWidth;
            GAME_HEIGHT = Math.floor(window.innerHeight * GAME_HEIGHT_RATIO);
            
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;
            canvas.style.width = GAME_WIDTH + 'px';
            canvas.style.height = GAME_HEIGHT + 'px';
            
            // 重新設置渲染品質
            ctx.imageSmoothingEnabled = false;
            ctx.imageSmoothingQuality = 'high';
        }
        
        function createWorld() {
            // 動態計算road-1元件尺寸
            // 基準：背景高度512對應road-1高度32，等比縮放
            const baseBackgroundHeight = 512;
            const baseRoadHeight = 32;
            const scaleRatio = baseRoadHeight / baseBackgroundHeight; // 32/512 = 1/16
            
            let roadWidth, roadHeight;
            
            // 如果有載入原始尺寸，使用原始比例
            if (roadOriginalSizes['road-1']) {
                const originalSize = roadOriginalSizes['road-1'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-1高度
                roadHeight = Math.floor(GAME_HEIGHT * scaleRatio);
                // 根據原始比例計算寬度
                roadWidth = Math.floor(roadHeight * originalRatio);
                
                console.log(`🎯 動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-1高度${roadHeight}, 寬度${roadWidth} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例
                roadHeight = Math.floor(GAME_HEIGHT * scaleRatio);
                roadWidth = Math.floor(roadHeight * (200/32)); // 預設比例 6.25
                
                console.log(`⚠️ 使用預設比例: road-1高度${roadHeight}, 寬度${roadWidth}`);
            }
            
            // 設定road-1位置：與背景齊左，動態計算底部距離
            const roadX = 0; // 與背景齊左
            const bottomDistanceRatio = 93 / 512; // 93像素距離在512高度背景中的比例 (18.16%)
            const dynamicBottomDistance = Math.floor(GAME_HEIGHT * bottomDistanceRatio);
            const roadY = GAME_HEIGHT - dynamicBottomDistance - roadHeight; // 動態計算底部距離
            
            // 計算road-kanban元件尺寸
            let kanbanWidth, kanbanHeight;
            const kanbanHeightRatio = 105 / 512; // 105像素高度在512背景中的比例 (20.51%)
            
            if (roadOriginalSizes['road-kanban']) {
                const originalSize = roadOriginalSizes['road-kanban'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-kanban高度
                kanbanHeight = Math.floor(GAME_HEIGHT * kanbanHeightRatio);
                // 根據原始比例計算寬度
                kanbanWidth = Math.floor(kanbanHeight * originalRatio);
                
                console.log(`🎯 動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-kanban高度${kanbanHeight}, 寬度${kanbanWidth} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例 94:105
                kanbanHeight = Math.floor(GAME_HEIGHT * kanbanHeightRatio);
                kanbanWidth = Math.floor(kanbanHeight * (94/105)); // 預設比例
                
                console.log(`⚠️ 使用預設比例: road-kanban高度${kanbanHeight}, 寬度${kanbanWidth}`);
            }
            
            // 設定road-kanban位置：底部對齊road-1頂部，左邊距離動態調整
            const kanbanLeftDistanceRatio = 37 / 512; // 37像素距離在512高度背景中的比例 (7.23%)
            const kanbanX = Math.floor(GAME_HEIGHT * kanbanLeftDistanceRatio); // 使用背景高度計算左邊距
            const kanbanY = roadY - kanbanHeight; // 底部對齊road-1頂部
            
            // 計算road-2元件尺寸
            let road2Width, road2Height;
            const road2HeightRatio = 32 / 512; // 32像素高度在512背景中的比例 (6.25%)
            
            if (roadOriginalSizes['road-2']) {
                const originalSize = roadOriginalSizes['road-2'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-2高度
                road2Height = Math.floor(GAME_HEIGHT * road2HeightRatio);
                // 根據原始比例計算寬度
                road2Width = Math.floor(road2Height * originalRatio);
                
                console.log(`🎯 動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-2高度${road2Height}, 寬度${road2Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例 171:32
                road2Height = Math.floor(GAME_HEIGHT * road2HeightRatio);
                road2Width = Math.floor(road2Height * (171/32)); // 預設比例
                
                console.log(`⚠️ 使用預設比例: road-2高度${road2Height}, 寬度${road2Width}`);
            }
            
            // 設定road-2位置：底部對齊背景底部，左邊對齊road-1右邊
            const road2BottomDistanceRatio = 202 / 512; // 202像素距離在512背景中的比例 (39.45%)
            const road2LeftDistanceRatio = 135 / 512; // 135像素距離在512背景中的比例 (26.37%)
            const road2X = Math.floor(GAME_WIDTH * road2LeftDistanceRatio); // 使用背景寬度計算左邊距
            const road2Y = GAME_HEIGHT - Math.floor(GAME_HEIGHT * road2BottomDistanceRatio) - road2Height; // 底部對齊背景底部
            
            // 計算house-1元件尺寸
            let house1Width, house1Height;
            const house1HeightRatio = 221 / 512; // 221像素高度在512背景中的比例 (43.16%)
            
            if (roadOriginalSizes['house-1']) {
                const originalSize = roadOriginalSizes['house-1'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算house-1高度
                house1Height = Math.floor(GAME_HEIGHT * house1HeightRatio);
                // 根據原始比例計算寬度
                house1Width = Math.floor(house1Height * originalRatio);
                
                console.log(`🎯 動態尺寸計算: 遊戲高度${GAME_HEIGHT} → house-1高度${house1Height}, 寬度${house1Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例 4:3
                house1Height = Math.floor(GAME_HEIGHT * house1HeightRatio);
                house1Width = Math.floor(house1Height * (4/3)); // 預設比例
                
                console.log(`⚠️ 使用預設比例: house-1高度${house1Height}, 寬度${house1Width}`);
            }
            
            // 設定house-1位置：底部對齊road-2的頂部，右邊與road-2右邊距離為33
            const house1RightDistanceRatio = 33 / 512; // 33像素距離在512背景中的比例 (6.45%)
            const house1RightDistance = Math.floor(GAME_HEIGHT * house1RightDistanceRatio); // 使用背景高度計算距離
            const house1X = road2X + road2Width - house1Width - house1RightDistance; // 右邊距離road-2右邊33像素
            const house1Y = road2Y - house1Height; // 底部對齊road-2頂部
            
            // 計算road-3元件尺寸
            let road3Width, road3Height;
            const road3HeightRatio = 32 / 512; // 32像素高度在512背景中的比例 (6.25%)
            
            if (roadOriginalSizes['road-3']) {
                const originalSize = roadOriginalSizes['road-3'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-3高度
                road3Height = Math.floor(GAME_HEIGHT * road3HeightRatio);
                // 根據原始比例計算寬度
                road3Width = Math.floor(road3Height * originalRatio);
                
                console.log(`🎯 動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-3高度${road3Height}, 寬度${road3Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設與road-2相同的比例 171:32
                road3Height = Math.floor(GAME_HEIGHT * road3HeightRatio);
                road3Width = Math.floor(road3Height * (171/32)); // 預設比例
                
                console.log(`⚠️ 使用預設比例: road-3高度${road3Height}, 寬度${road3Width}`);
            }
            
            // 設定road-3位置：底部對齊背景底部，左邊對齊road-2右邊
            const road3BottomDistanceRatio = 65 / 512; // 65像素距離在512背景中的比例 (12.70%)
            const road3LeftDistanceRatio = 63 / 512; // 63像素距離在512背景中的比例 (12.30%)
            const road3LeftDistance = Math.floor(GAME_HEIGHT * road3LeftDistanceRatio); // 使用背景高度計算距離
            const road3X = road2X + road2Width + road3LeftDistance; // 左邊對齊road-2右邊，距離63像素
            const road3Y = GAME_HEIGHT - Math.floor(GAME_HEIGHT * road3BottomDistanceRatio) - road3Height; // 底部對齊背景底部，距離65像素
            
            // 計算house-2元件尺寸
            let house2Width, house2Height;
            const house2HeightRatio = 189 / 512; // 189像素高度在512背景中的比例 (36.91%)
            
            if (roadOriginalSizes['house-2']) {
                const originalSize = roadOriginalSizes['house-2'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算house-2高度
                house2Height = Math.floor(GAME_HEIGHT * house2HeightRatio);
                // 根據原始比例計算寬度
                house2Width = Math.floor(house2Height * originalRatio);
                
                console.log(`🎯 動態尺寸計算: 遊戲高度${GAME_HEIGHT} → house-2高度${house2Height}, 寬度${house2Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設房子寬高比為4:3
                house2Height = Math.floor(GAME_HEIGHT * house2HeightRatio);
                house2Width = Math.floor(house2Height * (4/3)); // 預設比例
                
                console.log(`⚠️ 使用預設比例: house-2高度${house2Height}, 寬度${house2Width}`);
            }
            
            // 設定house-2位置：底部對齊road-3的頂部，左邊與road-3左邊距離為25
            const house2LeftDistanceRatio = 25 / 512; // 25像素距離在512背景中的比例 (4.88%)
            const house2LeftDistance = Math.floor(GAME_HEIGHT * house2LeftDistanceRatio); // 使用背景高度計算距離
            const house2X = road3X + house2LeftDistance; // 右邊距離road-3右邊25像素
            const house2Y = road3Y - house2Height; // 底部對齊road-3頂部

            // 計算 house-3 元件尺寸
            let house3Width, house3Height;
            const house3HeightRatio = 211 / 512; // 211像素高度在512背景中的比例 (41.21%)

            if (roadOriginalSizes['house-3']) {
                const originalSize = roadOriginalSizes['house-3'];
                const originalRatio = originalSize.width / originalSize.height;

                // 根據當前遊戲高度計算 house-3 高度
                house3Height = Math.floor(GAME_HEIGHT * house3HeightRatio);
                // 根據原始比例計算寬度
                house3Width = Math.floor(house3Height * originalRatio);

                console.log(`🎯 動態尺寸計算: 遊戲高度${GAME_HEIGHT} → house-3高度${house3Height}, 寬度${house3Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 若無原始尺寸，使用預設 4:3 比例
                house3Height = Math.floor(GAME_HEIGHT * house3HeightRatio);
                house3Width = Math.floor(house3Height * (4 / 3));

                console.log(`⚠️ 使用預設比例: house-3高度${house3Height}, 寬度${house3Width}`);
            }

            // 計算位置：底部對齊 road-3 頂部，右邊與 road-3 右邊距離為 91（依背景高度等比例）
            const house3RightDistanceRatio = 91 / 512; // 17.77%
            const house3RightDistance = Math.floor(GAME_HEIGHT * house3RightDistanceRatio);
            const house3X = road3X + road3Width - house3Width - house3RightDistance;
            const house3Y = road3Y - house3Height;

            // 計算house-4尺寸
            let house4Width, house4Height;
            const house4HeightRatio = 180 / 512; // 180像素高度在512背景中的比例 (35.16%)
            
            if (roadOriginalSizes['house-4']) {
                const originalSize = roadOriginalSizes['house-4'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算house-4高度
                house4Height = Math.floor(GAME_HEIGHT * house4HeightRatio);
                // 根據原始比例計算寬度
                house4Width = Math.floor(house4Height * originalRatio);
                
                console.log(`🎯 House-4動態尺寸計算: 遊戲高度${GAME_HEIGHT} → house-4高度${house4Height}, 寬度${house4Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:3
                house4Height = Math.floor(GAME_HEIGHT * house4HeightRatio);
                house4Width = Math.floor(house4Height * (4/3)); // 預設比例
                
                console.log(`⚠️ House-4使用預設比例: 高度${house4Height}, 寬度${house4Width}`);
            }

            // 計算house-5尺寸
            let house5Width, house5Height;
            const house5HeightRatio = 232 / 512; // 232像素高度在512背景中的比例 (45.31%)
            
            if (roadOriginalSizes['house-5']) {
                const originalSize = roadOriginalSizes['house-5'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算house-5高度
                house5Height = Math.floor(GAME_HEIGHT * house5HeightRatio);
                // 根據原始比例計算寬度
                house5Width = Math.floor(house5Height * originalRatio);
                
                console.log(`🎯 House-5動態尺寸計算: 遊戲高度${GAME_HEIGHT} → house-5高度${house5Height}, 寬度${house5Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:3
                house5Height = Math.floor(GAME_HEIGHT * house5HeightRatio);
                house5Width = Math.floor(house5Height * (4/3)); // 預設比例
                
                console.log(`⚠️ House-5使用預設比例: 高度${house5Height}, 寬度${house5Width}`);
            }

            // house-4和house-5的位置计算将在road-4创建之后进行
            
            // 創建road元件
            world.roads = [
                {
                    x: roadX, 
                    y: roadY, 
                    width: roadWidth, 
                    height: roadHeight,
                    type: 'road-1'
                },
                {
                    x: kanbanX,
                    y: kanbanY,
                    width: kanbanWidth,
                    height: kanbanHeight,
                    type: 'road-kanban'
                },
                {
                    x: road2X,
                    y: road2Y,
                    width: road2Width,
                    height: road2Height,
                    type: 'road-2'
                },
                {
                    x: road3X,
                    y: road3Y,
                    width: road3Width,
                    height: road3Height,
                    type: 'road-3'
                },
                {
                    x: house1X,
                    y: house1Y,
                    width: house1Width,
                    height: house1Height,
                    type: 'house-1'
                },
                {
                    x: house2X,
                    y: house2Y,
                    width: house2Width,
                    height: house2Height,
                    type: 'house-2'
                },
                {
                    x: house3X,
                    y: house3Y,
                    width: house3Width,
                    height: house3Height,
                    type: 'house-3'
                }
            ];

            // 創建Cloud模組
            cloudManager.createClouds(road3X, road3Width, GAME_HEIGHT);

            // 創建三個階梯狀的road-mid
            const roadMidHeightRatio = 32 / 512; // 32像素高度在512背景中的比例 (6.25%)
            let roadMidWidth, roadMidHeight;
            
            if (roadOriginalSizes['road-mid']) {
                const originalSize = roadOriginalSizes['road-mid'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-mid高度
                roadMidHeight = Math.floor(GAME_HEIGHT * roadMidHeightRatio);
                // 根據原始比例計算寬度
                roadMidWidth = Math.floor(roadMidHeight * originalRatio);
                
                console.log(`🎯 Road-mid動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-mid高度${roadMidHeight}, 寬度${roadMidWidth} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:1
                roadMidHeight = Math.floor(GAME_HEIGHT * roadMidHeightRatio);
                roadMidWidth = Math.floor(roadMidHeight * 4); // 預設比例
                
                console.log(`⚠️ Road-mid使用預設比例: 高度${roadMidHeight}, 寬度${roadMidWidth}`);
            }

            // 計算距離比例
            const firstRoadMidBottomDistanceRatio = 127 / 512; // 127像素距離在512背景中的比例 (24.8%)
            const firstRoadMidLeftDistanceRatio = 94 / 512; // 94像素距離在512背景中的比例 (18.36%)
            const roadMidSpacingRatio = 16 / 512; // 16像素間距在512背景中的比例 (3.125%)
            const roadMidVerticalSpacingRatio = 32 / 512; // 32像素垂直間距在512背景中的比例 (6.25%)

            const firstRoadMidBottomDistance = Math.floor(GAME_HEIGHT * firstRoadMidBottomDistanceRatio);
            const firstRoadMidLeftDistance = Math.floor(GAME_HEIGHT * firstRoadMidLeftDistanceRatio);
            const roadMidSpacing = Math.floor(GAME_HEIGHT * roadMidSpacingRatio);
            const roadMidVerticalSpacing = Math.floor(GAME_HEIGHT * roadMidVerticalSpacingRatio);

            // 第一個road-mid位置
            const firstRoadMidX = road3X + road3Width + firstRoadMidLeftDistance;
            const firstRoadMidY = GAME_HEIGHT - firstRoadMidBottomDistance - roadMidHeight;

            // 第二個road-mid位置
            const secondRoadMidX = firstRoadMidX + roadMidWidth + roadMidSpacing;
            const secondRoadMidY = firstRoadMidY - roadMidVerticalSpacing - roadMidHeight;

            // 第三個road-mid位置
            const thirdRoadMidX = secondRoadMidX + roadMidWidth + roadMidSpacing;
            const thirdRoadMidY = secondRoadMidY - roadMidVerticalSpacing - roadMidHeight;

            // 添加三個road-mid到world.roads
            world.roads.push(
                {
                    x: firstRoadMidX,
                    y: firstRoadMidY,
                    width: roadMidWidth,
                    height: roadMidHeight,
                    type: 'road-mid'
                },
                {
                    x: secondRoadMidX,
                    y: secondRoadMidY,
                    width: roadMidWidth,
                    height: roadMidHeight,
                    type: 'road-mid'
                },
                {
                    x: thirdRoadMidX,
                    y: thirdRoadMidY,
                    width: roadMidWidth,
                    height: roadMidHeight,
                    type: 'road-mid'
                }
            );

            console.log('🏗️ 三個階梯狀road-mid創建完成:', world.roads.filter(r => r.type.includes('road-mid')));

            // 創建road-4
            const road4HeightRatio = 32 / 512; // 32像素高度在512背景中的比例，與road-3相同 (6.25%)
            let road4Width, road4Height;
            
            if (roadOriginalSizes['road-4']) {
                const originalSize = roadOriginalSizes['road-4'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-4高度
                road4Height = Math.floor(GAME_HEIGHT * road4HeightRatio);
                // 根據原始比例計算寬度
                road4Width = Math.floor(road4Height * originalRatio);
                
                console.log(`🎯 Road-4動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-4高度${road4Height}, 寬度${road4Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:1
                road4Height = Math.floor(GAME_HEIGHT * road4HeightRatio);
                road4Width = Math.floor(road4Height * 4); // 預設比例
                
                console.log(`⚠️ Road-4使用預設比例: 高度${road4Height}, 寬度${road4Width}`);
            }

            // 計算road-4位置
            const road4BottomDistanceRatio = 143 / 512; // 143像素距離在512背景中的比例 (27.93%)
            const road4LeftDistanceRatio = 40 / 512; // 40像素距離在512背景中的比例 (7.81%)
            
            const road4BottomDistance = Math.floor(GAME_HEIGHT * road4BottomDistanceRatio);
            const road4LeftDistance = Math.floor(GAME_HEIGHT * road4LeftDistanceRatio);
            
            // 找到最後一個road-mid（第三個）的位置
            const lastRoadMid = world.roads.find(road => road.type === 'road-mid' && road.x === thirdRoadMidX);
            const road4X = lastRoadMid.x + lastRoadMid.width + road4LeftDistance;
            const road4Y = GAME_HEIGHT - road4BottomDistance - road4Height;

            // 添加road-4到world.roads
            world.roads.push({
                x: road4X,
                y: road4Y,
                width: road4Width,
                height: road4Height,
                type: 'road-4'
            });

            console.log('🏗️ Road-4創建完成:', { x: road4X, y: road4Y, width: road4Width, height: road4Height });

            // 現在創建house-4和house-5（在road-4創建之後）
            const house4LeftDistanceRatio = 83 / 512; // 83像素距離在512背景中的比例 (16.21%)
            const house5LeftGapRatio = 104 / 512; // 104像素距離在512背景中的比例 (20.31%)
            
            const house4LeftDistance = Math.floor(GAME_HEIGHT * house4LeftDistanceRatio);
            const house5LeftGap = Math.floor(GAME_HEIGHT * house5LeftGapRatio);
            
            const house4X = road4X + house4LeftDistance; // house-4左邊與road-4左邊距離83像素
            const house4Y = road4Y - house4Height; // house-4底部貼齊road-4頂部
            
            const house5X = house4X + house4Width + house5LeftGap; // house-5左邊與house-4右邊距離104像素
            const house5Y = road4Y - house5Height; // house-5底部貼齊road-4頂部

            // 將house-4和house-5添加到world.roads
            world.roads.push(
                {
                    x: house4X,
                    y: house4Y,
                    width: house4Width,
                    height: house4Height,
                    type: 'house-4'
                },
                {
                    x: house5X,
                    y: house5Y,
                    width: house5Width,
                    height: house5Height,
                    type: 'house-5'
                }
            );

            console.log('🏠 House-4創建完成:', { x: house4X, y: house4Y, width: house4Width, height: house4Height });
            console.log('🏠 House-5創建完成:', { x: house5X, y: house5Y, width: house5Width, height: house5Height });
            
            // 設置玩家初始位置在road-1元件上方
            player.x = roadX + 50; // 在road-1左側一點
            player.y = roadY - player.height; // 站在road-1上方
            
            // 清空所有舊的HP Logo
            hpLogoManager.clear();
            
            // 創建road-2右邊的4個HP Logo（水平排列）
            const hpLogoLeftDistanceRatio = 15 / 512; // 15像素距離在512背景中的比例 (2.93%)
            const hpLogoBottomDistanceRatio = 121 / 512; // 121像素距離在512背景中的比例 (23.63%)
            const hpLogoSpacingRatio = 8 / 512; // 8像素間距在512背景中的比例 (1.56%)
            
            const hpLogoLeftDistance = Math.floor(GAME_HEIGHT * hpLogoLeftDistanceRatio);
            const hpLogoBottomDistance = Math.floor(GAME_HEIGHT * hpLogoBottomDistanceRatio);
            const hpLogoSpacing = Math.floor(GAME_HEIGHT * hpLogoSpacingRatio);
            
            const road2 = world.roads.find(road => road.type === 'road-2');
            const firstHpLogoX = road2.x + hpLogoLeftDistance;
            const firstHpLogoY = road2.y - hpLogoBottomDistance - Math.floor(GAME_HEIGHT * (41 / 512)); // 動態計算高度
            
            hpLogoManager.createHorizontalHpLogos(firstHpLogoX, firstHpLogoY, 4, hpLogoSpacing, GAME_HEIGHT);
            
            // 清空所有舊的彈簧
            springManager.clear();
            
            // 使用Spring模組創建彈簧
            const springLeftDistanceRatio = 40 / 512;
            const springLeftDistance = Math.floor(GAME_HEIGHT * springLeftDistanceRatio);
            
            const road3 = world.roads.find(road => road.type === 'road-3');
            const house2 = world.roads.find(road => road.type === 'house-2');
            const springX = house2.x + house2.width + springLeftDistance;
            
            // 先創建彈簧，讓它自動計算Y位置
            const spring = springManager.createSpring(springX, 0, player.width);
            spring.y = road3.y - spring.height; // 底部對齊road-3頂部
            
            // 創建spring上方的3個HP Logo（垂直排列）
            if (spring) {
                const springBottomDistanceRatio = 94 / 512; // 94像素距離在512背景中的比例
                const springBottomDistance = Math.floor(GAME_HEIGHT * springBottomDistanceRatio);
                const verticalSpacing = Math.floor(GAME_HEIGHT * hpLogoSpacingRatio); // 8像素間距
                
                // spring中心X位置
                const springCenterX = spring.x + Math.floor(spring.width / 2);
                // 第一個HP Logo的底部Y位置（spring頂部上方94像素）
                const firstVerticalHpLogoBottomY = spring.y - springBottomDistance;
                
                hpLogoManager.createVerticalHpLogos(springCenterX, firstVerticalHpLogoBottomY, 3, verticalSpacing, GAME_HEIGHT);
            }

            // 在每個road-mid上方創建HP Logo
            const roadMids = world.roads.filter(road => road.type.includes('road-mid'));
            roadMids.forEach((roadMid, index) => {
                // 計算HP Logo的中心X位置（與road-mid垂直置中）
                const hpLogoCenterX = roadMid.x + Math.floor(roadMid.width / 2);
                // HP Logo底部貼齊road-mid頂部
                const hpLogoBottomY = roadMid.y;
                
                // 為每個road-mid創建一個HP Logo
                hpLogoManager.createVerticalHpLogos(hpLogoCenterX, hpLogoBottomY, 1, 0, GAME_HEIGHT);
                
                console.log(`🩹 在road-mid-${index + 1}上方創建HP Logo，位置: (${hpLogoCenterX}, ${hpLogoBottomY})`);
            });

            // 在road-4上創建5個HP Logo（水平排列）
            const road4HpLogoLeftDistanceRatio = 172 / 512; // 172像素距離在512背景中的比例 (33.59%)
            const road4HpLogoLeftDistance = Math.floor(GAME_HEIGHT * road4HpLogoLeftDistanceRatio);
            const road4HpLogoSpacing = Math.floor(GAME_HEIGHT * hpLogoSpacingRatio); // 8像素間距
            
            const firstRoad4HpLogoX = road4X + road4HpLogoLeftDistance; // 第一個HP Logo左邊與road-4左邊距離172像素
            const firstRoad4HpLogoY = road4Y - Math.floor(GAME_HEIGHT * (41 / 512)); // HP Logo底部貼齊road-4頂部
            
            hpLogoManager.createHorizontalHpLogos(firstRoad4HpLogoX, firstRoad4HpLogoY, 5, road4HpLogoSpacing, GAME_HEIGHT);
            
            console.log('🩹 在road-4上創建5個HP Logo完成，位置:', { x: firstRoad4HpLogoX, y: firstRoad4HpLogoY });

            // 創建5個road-short-1（掉落平台）
            const roadShort1HeightRatio = 21 / 512; // 21像素高度在512背景中的比例 (4.10%)
            let roadShort1Width, roadShort1Height;
            
            if (roadOriginalSizes['road-short-1']) {
                const originalSize = roadOriginalSizes['road-short-1'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-short-1高度
                roadShort1Height = Math.floor(GAME_HEIGHT * roadShort1HeightRatio);
                // 根據原始比例計算寬度
                roadShort1Width = Math.floor(roadShort1Height * originalRatio);
                
                console.log(`🎯 Road-short-1動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-short-1高度${roadShort1Height}, 寬度${roadShort1Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為3:1
                roadShort1Height = Math.floor(GAME_HEIGHT * roadShort1HeightRatio);
                roadShort1Width = Math.floor(roadShort1Height * 3); // 預設比例
                
                console.log(`⚠️ Road-short-1使用預設比例: 高度${roadShort1Height}, 寬度${roadShort1Width}`);
            }

            // 計算road-short-1位置
            const roadShort1LeftDistanceRatio = 24 / 512; // 24像素距離在512背景中的比例 (4.69%)
            const roadShort1SpacingRatio = 40 / 512; // 40像素間距在512背景中的比例 (7.81%)
            
            const roadShort1LeftDistance = Math.floor(GAME_HEIGHT * roadShort1LeftDistanceRatio);
            const roadShort1Spacing = Math.floor(GAME_HEIGHT * roadShort1SpacingRatio);
            
            // 第一個road-short-1位置
            const firstRoadShort1X = road4X + road4Width + roadShort1LeftDistance; // road-short-1左邊與road-4右邊距離24像素
            const firstRoadShort1Y = road4Y; // road-short-1頂部與road-4頂部貼齊

            // 創建5個road-short-1並添加到world.roads
            for (let i = 0; i < 5; i++) {
                world.roads.push({
                    x: firstRoadShort1X + i * (roadShort1Width + roadShort1Spacing),
                    y: firstRoadShort1Y,
                    width: roadShort1Width,
                    height: roadShort1Height,
                    type: 'road-short-1',
                    id: `road-short-1-${i + 1}`,
                    isFalling: false,
                    fallStartTime: 0,
                    fallDuration: 1000, // 1秒後掉落
                    originalY: firstRoadShort1Y
                });
            }

            console.log('🏗️ 5個road-short-1創建完成:', world.roads.filter(r => r.type === 'road-short-1'));

            // 創建road-5
            const road5HeightRatio = 32 / 512; // 32像素高度在512背景中的比例，與road-3和road-4相同 (6.25%)
            let road5Width, road5Height;
            
            if (roadOriginalSizes['road-5']) {
                const originalSize = roadOriginalSizes['road-5'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-5高度
                road5Height = Math.floor(GAME_HEIGHT * road5HeightRatio);
                // 根據原始比例計算寬度
                road5Width = Math.floor(road5Height * originalRatio);
                
                console.log(`🎯 Road-5動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-5高度${road5Height}, 寬度${road5Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:1
                road5Height = Math.floor(GAME_HEIGHT * road5HeightRatio);
                road5Width = Math.floor(road5Height * 4); // 預設比例
                
                console.log(`⚠️ Road-5使用預設比例: 高度${road5Height}, 寬度${road5Width}`);
            }

            // 計算road-5位置
            const road5BottomDistanceRatio = 58 / 512; // 58像素距離在512背景中的比例 (11.33%)
            const road5LeftDistanceRatio = 24 / 512; // 24像素距離在512背景中的比例 (4.69%)
            
            const road5BottomDistance = Math.floor(GAME_HEIGHT * road5BottomDistanceRatio);
            const road5LeftDistance = Math.floor(GAME_HEIGHT * road5LeftDistanceRatio);
            
            // 找到最後一個road-short-1的位置
            const lastRoadShort1 = world.roads.find(road => road.type === 'road-short-1' && road.id === 'road-short-1-5');
            const road5X = lastRoadShort1.x + lastRoadShort1.width + road5LeftDistance;
            const road5Y = GAME_HEIGHT - road5BottomDistance - road5Height;

            // 添加road-5到world.roads
            world.roads.push({
                x: road5X,
                y: road5Y,
                width: road5Width,
                height: road5Height,
                type: 'road-5'
            });

            console.log('🏗️ Road-5創建完成:', { x: road5X, y: road5Y, width: road5Width, height: road5Height });

            // 創建house-6
            const house6HeightRatio = 210 / 512; // 210像素高度在512背景中的比例 (41.02%)
            let house6Width, house6Height;
            
            if (roadOriginalSizes['house-6']) {
                const originalSize = roadOriginalSizes['house-6'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算house-6高度
                house6Height = Math.floor(GAME_HEIGHT * house6HeightRatio);
                // 根據原始比例計算寬度
                house6Width = Math.floor(house6Height * originalRatio);
                
                console.log(`🎯 House-6動態尺寸計算: 遊戲高度${GAME_HEIGHT} → house-6高度${house6Height}, 寬度${house6Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:3
                house6Height = Math.floor(GAME_HEIGHT * house6HeightRatio);
                house6Width = Math.floor(house6Height * (4/3)); // 預設比例
                
                console.log(`⚠️ House-6使用預設比例: 高度${house6Height}, 寬度${house6Width}`);
            }

            // 計算house-6位置
            const house6LeftDistanceRatio = 50 / 512; // 50像素距離在512背景中的比例 (9.77%)
            const house6LeftDistance = Math.floor(GAME_HEIGHT * house6LeftDistanceRatio);
            
            const house6X = road5X + house6LeftDistance; // house-6左邊與road-5左邊距離50像素
            const house6Y = road5Y - house6Height; // house-6底部對齊road-5頂部

            // 添加house-6到world.roads
            world.roads.push({
                x: house6X,
                y: house6Y,
                width: house6Width,
                height: house6Height,
                type: 'house-6'
            });

            console.log('🏠 House-6創建完成:', { x: house6X, y: house6Y, width: house6Width, height: house6Height });

            // 使用Spring模組創建第二個彈簧
            const spring2LeftDistanceRatio = 108 / 512; // 108像素距離在512背景中的比例 (21.09%)
            const spring2LeftDistance = Math.floor(GAME_HEIGHT * spring2LeftDistanceRatio);
            
            const spring2X = house6X + house6Width + spring2LeftDistance; // spring左邊距離house-6右邊108像素
            const spring2 = springManager.createSpring(spring2X, 0, player.width);
            spring2.y = road5Y - spring2.height; // spring底部貼齊road-5頂部
            
            console.log('🏃‍♂️ 第二個Spring創建完成:', { x: spring2X, y: spring2.y, width: spring2.width, height: spring2.height });

            // 在第二個spring上方創建3x3九宮格HP Logo
            const hpLogoGridTopDistanceRatio = 96 / 512; // 96像素距離在512背景中的比例 (18.75%)
            const hpLogoGridSpacingRatio = 8 / 512; // 8像素間距在512背景中的比例 (1.56%)
            
            const hpLogoGridTopDistance = Math.floor(GAME_HEIGHT * hpLogoGridTopDistanceRatio);
            const hpLogoGridSpacing = Math.floor(GAME_HEIGHT * hpLogoGridSpacingRatio);
            
            // 計算九宮格的中心X位置（與spring垂直置中）
            const spring2CenterX = spring2X + Math.floor(spring2.width / 2);
            
            // 計算第一個HP Logo的位置（九宮格左上角）
            const hpLogoHeightRatio = 41 / 512; // 41像素高度在512背景中的比例
            const hpLogoHeight = Math.floor(GAME_HEIGHT * hpLogoHeightRatio);
            
            // 根據圖片實際比例計算寬度，如果沒有則假設為正方形
            let hpLogoWidth;
            if (hpLogoManager.image && hpLogoManager.image.complete && hpLogoManager.image.naturalWidth > 0) {
                const originalRatio = hpLogoManager.image.naturalWidth / hpLogoManager.image.naturalHeight;
                hpLogoWidth = Math.floor(hpLogoHeight * originalRatio);
            } else {
                hpLogoWidth = hpLogoHeight; // 預設為正方形
            }
            
            // 計算九宮格的總寬度和高度
            const gridWidth = (hpLogoWidth * 3) + (hpLogoGridSpacing * 2); // 3個HP Logo + 2個間距
            const gridHeight = (hpLogoHeight * 3) + (hpLogoGridSpacing * 2); // 3個HP Logo + 2個間距
            
            // 計算第一個HP Logo的位置（九宮格左上角）
            const gridFirstHpLogoX = spring2CenterX - Math.floor(gridWidth / 2);
            const gridFirstHpLogoY = spring2.y - hpLogoGridTopDistance - gridHeight; // 距離spring頂部96像素
            
            // 創建3x3九宮格HP Logo
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const hpLogoX = gridFirstHpLogoX + col * (hpLogoWidth + hpLogoGridSpacing);
                    const hpLogoY = gridFirstHpLogoY + row * (hpLogoHeight + hpLogoGridSpacing);
                    
                    hpLogoManager.hpLogos.push({
                        x: hpLogoX,
                        y: hpLogoY,
                        width: hpLogoWidth,
                        height: hpLogoHeight,
                        collected: false,
                        id: `grid_${row}_${col}`,
                        type: 'grid'
                    });
                }
            }
            
            console.log('🩹 3x3九宮格HP Logo創建完成，位置:', { 
                centerX: spring2CenterX, 
                firstX: gridFirstHpLogoX, 
                firstY: gridFirstHpLogoY,
                spacing: hpLogoGridSpacing,
                totalCount: hpLogoManager.hpLogos.length
            });

            // 創建house-7
            const house7HeightRatio = 233 / 512; // 233像素高度在512背景中的比例 (45.51%)
            let house7Width, house7Height;
            
            if (roadOriginalSizes['house-7']) {
                const originalSize = roadOriginalSizes['house-7'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算house-7高度
                house7Height = Math.floor(GAME_HEIGHT * house7HeightRatio);
                // 根據原始比例計算寬度
                house7Width = Math.floor(house7Height * originalRatio);
                
                console.log(`🎯 House-7動態尺寸計算: 遊戲高度${GAME_HEIGHT} → house-7高度${house7Height}, 寬度${house7Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:3
                house7Height = Math.floor(GAME_HEIGHT * house7HeightRatio);
                house7Width = Math.floor(house7Height * (4/3)); // 預設比例
                
                console.log(`⚠️ House-7使用預設比例: 高度${house7Height}, 寬度${house7Width}`);
            }

            // 計算house-7位置
            const house7LeftDistanceRatio = 108 / 512; // 108像素距離在512背景中的比例 (21.09%)
            const house7LeftDistance = Math.floor(GAME_HEIGHT * house7LeftDistanceRatio);
            
            const house7X = spring2X + spring2.width + house7LeftDistance; // house-7左邊與spring右邊距離108像素
            const house7Y = road5Y - house7Height; // house-7底部對齊road-5頂部

            // 添加house-7到world.roads
            world.roads.push({
                x: house7X,
                y: house7Y,
                width: house7Width,
                height: house7Height,
                type: 'house-7'
            });

            console.log('🏠 House-7創建完成:', { x: house7X, y: house7Y, width: house7Width, height: house7Height });

            // 創建CloudManager2的cloud（House-7版本）
            cloudManager2.createClouds(house7X, house7Width, GAME_HEIGHT);

            // 創建road-7
            const road7HeightRatio = 32 / 512; // 32像素高度在512背景中的比例，與road-5相同 (6.25%)
            let road7Width, road7Height;
            
            if (roadOriginalSizes['road-7']) {
                const originalSize = roadOriginalSizes['road-7'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-7高度
                road7Height = Math.floor(GAME_HEIGHT * road7HeightRatio);
                // 根據原始比例計算寬度
                road7Width = Math.floor(road7Height * originalRatio);
                
                console.log(`🎯 Road-7動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-7高度${road7Height}, 寬度${road7Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:1
                road7Height = Math.floor(GAME_HEIGHT * road7HeightRatio);
                road7Width = Math.floor(road7Height * 4); // 預設比例
                
                console.log(`⚠️ Road-7使用預設比例: 高度${road7Height}, 寬度${road7Width}`);
            }

            // 計算road-7位置
            const road7BottomDistanceRatio = 120 / 512; // 120像素距離在512背景中的比例 (23.44%)
            const road7LeftDistanceRatio = 68 / 512; // 68像素距離在512背景中的比例 (13.28%)
            
            const road7BottomDistance = Math.floor(GAME_HEIGHT * road7BottomDistanceRatio);
            const road7LeftDistance = Math.floor(GAME_HEIGHT * road7LeftDistanceRatio);
            
            // road-7底部對齊背景底部距離120像素，左邊對齊road-5右邊距離68像素
            const road7X = road5X + road5Width + road7LeftDistance; // road-7左邊與road-5右邊距離68像素
            const road7Y = GAME_HEIGHT - road7BottomDistance - road7Height; // road-7底部距離背景底部120像素

            // 添加road-7到world.roads
            world.roads.push({
                x: road7X,
                y: road7Y,
                width: road7Width,
                height: road7Height,
                type: 'road-7'
            });

            console.log('🏗️ Road-7創建完成:', { x: road7X, y: road7Y, width: road7Width, height: road7Height });

            // 創建road-8
            const road8HeightRatio = 32 / 512; // 32像素高度在512背景中的比例，與road-5相同 (6.25%)
            let road8Width, road8Height;
            
            if (roadOriginalSizes['road-8']) {
                const originalSize = roadOriginalSizes['road-8'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-8高度
                road8Height = Math.floor(GAME_HEIGHT * road8HeightRatio);
                // 根據原始比例計算寬度
                road8Width = Math.floor(road8Height * originalRatio);
                
                console.log(`🎯 Road-8動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-8高度${road8Height}, 寬度${road8Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:1
                road8Height = Math.floor(GAME_HEIGHT * road8HeightRatio);
                road8Width = Math.floor(road8Height * 4); // 預設比例
                
                console.log(`⚠️ Road-8使用預設比例: 高度${road8Height}, 寬度${road8Width}`);
            }

            // 計算road-8位置
            const road8LeftDistanceRatio = 68 / 512; // 68像素距離在512背景中的比例 (13.28%)
            
            const road8LeftDistance = Math.floor(GAME_HEIGHT * road8LeftDistanceRatio);
            
            // road-8頂部對齊road-5頂部，左邊對齊road-7右邊距離68像素
            const road8X = road7X + road7Width + road8LeftDistance; // road-8左邊與road-7右邊距離68像素
            const road8Y = road5Y; // road-8頂部對齊road-5頂部

            // 添加road-8到world.roads
            world.roads.push({
                x: road8X,
                y: road8Y,
                width: road8Width,
                height: road8Height,
                type: 'road-8'
            });

            console.log('🏗️ Road-8創建完成:', { x: road8X, y: road8Y, width: road8Width, height: road8Height });

            // 創建第一組水平排列的HP Logo（3個，與road-7垂直排列）
            const road7HpLogoSpacingRatio = 8 / 512; // 8像素間距在512背景中的比例 (1.56%)
            const road7HpLogoBottomDistanceRatio = 160 / 512; // 124像素距離在512背景中的比例 (24.22%)
            
            const road7HpLogoSpacing = Math.floor(GAME_HEIGHT * road7HpLogoSpacingRatio);
            const road7HpLogoBottomDistance = Math.floor(GAME_HEIGHT * road7HpLogoBottomDistanceRatio);
            
            // 計算第一組HP Logo的位置（與road-7垂直排列）
            const road7CenterX = road7X + Math.floor(road7Width / 2); // road-7中心X位置
            const road7HpLogoBottomY = road7Y - road7HpLogoBottomDistance; // HP Logo底部位置
            
            // 計算第一組HP Logo的起始X位置（置中排列）
            const road7HpLogoHeightRatio = 41 / 512; // 41像素高度在512背景中的比例
            const road7HpLogoHeight = Math.floor(GAME_HEIGHT * road7HpLogoHeightRatio);
            const road7HpLogoWidth = road7HpLogoHeight; // 假設為正方形
            const road7HpLogosTotalWidth = (road7HpLogoWidth * 3) + (road7HpLogoSpacing * 2); // 3個HP Logo + 2個間距
            const road7HpLogoStartX = road7CenterX - Math.floor(road7HpLogosTotalWidth / 2); // 置中排列的起始X位置
            
            // 創建第一組3個水平排列的HP Logo
            hpLogoManager.createHorizontalHpLogos(road7HpLogoStartX, road7HpLogoBottomY, 3, road7HpLogoSpacing, GAME_HEIGHT);
            
            console.log('🩹 第一組HP Logo創建完成（3個，與road-7垂直排列）');

            // 創建第二組水平排列的HP Logo（6個，在road-8上方）
            const road8HpLogoSpacingRatio = 8 / 512; // 8像素間距在512背景中的比例 (1.56%)
            const road8HpLogoLeftDistanceRatio = 78 / 512; // 78像素距離在512背景中的比例 (15.23%)
            
            const road8HpLogoSpacing = Math.floor(GAME_HEIGHT * road8HpLogoSpacingRatio);
            const road8HpLogoLeftDistance = Math.floor(GAME_HEIGHT * road8HpLogoLeftDistanceRatio);
            
            // 計算第二組HP Logo的位置（在road-8上方）
            const road8HpLogoX = road8X + road8HpLogoLeftDistance; // HP Logo左邊位置
            const road8HpLogoHeightRatio = 41 / 512; // 41像素高度在512背景中的比例
            const road8HpLogoHeight = Math.floor(GAME_HEIGHT * road8HpLogoHeightRatio);
            const road8HpLogoY = road8Y - road8HpLogoHeight; // HP Logo底部與road-8頂部貼齊
            
            // 創建第二組6個水平排列的HP Logo
            hpLogoManager.createHorizontalHpLogos(road8HpLogoX, road8HpLogoY, 6, road8HpLogoSpacing, GAME_HEIGHT);
            
            console.log('🩹 第二組HP Logo創建完成（6個，在road-8上方）');

            // 創建house-8
            const house8HeightRatio = 162 / 512; // 162像素高度在512背景中的比例 (31.64%)
            let house8Width, house8Height;
            
            if (roadOriginalSizes['house-8']) {
                const originalSize = roadOriginalSizes['house-8'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算house-8高度
                house8Height = Math.floor(GAME_HEIGHT * house8HeightRatio);
                // 根據原始比例計算寬度
                house8Width = Math.floor(house8Height * originalRatio);
                
                console.log(`🎯 House-8動態尺寸計算: 遊戲高度${GAME_HEIGHT} → house-8高度${house8Height}, 寬度${house8Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:3
                house8Height = Math.floor(GAME_HEIGHT * house8HeightRatio);
                house8Width = Math.floor(house8Height * (4/3)); // 預設比例
                
                console.log(`⚠️ House-8使用預設比例: 高度${house8Height}, 寬度${house8Width}`);
            }

            // 計算house-8位置
            const house8LeftDistanceRatio = 170 / 512; // 170像素距離在512背景中的比例 (33.20%)
            const house8LeftDistance = Math.floor(GAME_HEIGHT * house8LeftDistanceRatio);
            
            const house8X = road8X + house8LeftDistance; // house-8左邊與road-8左邊距離170像素
            const house8Y = road8Y - house8Height; // house-8底部對齊road-8頂部

            // 添加house-8到world.roads
            world.roads.push({
                x: house8X,
                y: house8Y,
                width: house8Width,
                height: house8Height,
                type: 'house-8'
            });

            console.log('🏠 House-8創建完成:', { x: house8X, y: house8Y, width: house8Width, height: house8Height });

            // 使用Spring模組創建第三個彈簧
            const spring3LeftDistanceRatio = 132 / 512; // 132像素距離在512背景中的比例 (25.78%)
            const spring3LeftDistance = Math.floor(GAME_HEIGHT * spring3LeftDistanceRatio);
            
            const spring3X = house8X + house8Width + spring3LeftDistance; // spring左邊與house-8右邊距離132像素
            const spring3 = springManager.createSpring(spring3X, 0, player.width);
            spring3.y = road8Y - spring3.height; // spring底部對齊road-8頂部
            
            console.log('🏃‍♂️ 第三個Spring創建完成:', { x: spring3X, y: spring3.y, width: spring3.width, height: spring3.height });

            // 創建bridge-1
            const bridge1HeightRatio = 122 / 512; // 122像素高度在512背景中的比例 (23.83%)
            let bridge1Width, bridge1Height;
            
            if (roadOriginalSizes['bridge-1']) {
                const originalSize = roadOriginalSizes['bridge-1'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算bridge-1高度
                bridge1Height = Math.floor(GAME_HEIGHT * bridge1HeightRatio);
                // 根據原始比例計算寬度
                bridge1Width = Math.floor(bridge1Height * originalRatio);
                
                console.log(`🎯 Bridge-1動態尺寸計算: 遊戲高度${GAME_HEIGHT} → bridge-1高度${bridge1Height}, 寬度${bridge1Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:1
                bridge1Height = Math.floor(GAME_HEIGHT * bridge1HeightRatio);
                bridge1Width = Math.floor(bridge1Height * 4); // 預設比例
                
                console.log(`⚠️ Bridge-1使用預設比例: 高度${bridge1Height}, 寬度${bridge1Width}`);
            }

            // 計算bridge-1位置
            const bridge1LeftDistanceRatio = 24 / 512; // 24像素距離在512背景中的比例 (4.69%)
            const bridge1LeftDistance = Math.floor(GAME_HEIGHT * bridge1LeftDistanceRatio);
            
            const bridge1X = spring3X + spring3.width + bridge1LeftDistance; // bridge-1左邊與spring右邊距離24像素
            const bridge1Y = road8Y - bridge1Height; // bridge-1底部對齊road-8頂部

            // 添加bridge-1到world.roads
            world.roads.push({
                x: bridge1X,
                y: bridge1Y,
                width: bridge1Width,
                height: bridge1Height,
                type: 'bridge-1'
            });

            console.log('🌉 Bridge-1創建完成:', { x: bridge1X, y: bridge1Y, width: bridge1Width, height: bridge1Height });

            // 創建8個road-short-2（掉落平台）
            const roadShort2HeightRatio = 21 / 512; // 21像素高度在512背景中的比例 (4.10%)
            let roadShort2Width, roadShort2Height;
            
            if (roadOriginalSizes['road-short-2']) {
                const originalSize = roadOriginalSizes['road-short-2'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-short-2高度
                roadShort2Height = Math.floor(GAME_HEIGHT * roadShort2HeightRatio);
                // 根據原始比例計算寬度
                roadShort2Width = Math.floor(roadShort2Height * originalRatio);
                
                console.log(`🎯 Road-short-2動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-short-2高度${roadShort2Height}, 寬度${roadShort2Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:1
                roadShort2Height = Math.floor(GAME_HEIGHT * roadShort2HeightRatio);
                roadShort2Width = Math.floor(roadShort2Height * 4); // 預設比例
                
                console.log(`⚠️ Road-short-2使用預設比例: 高度${roadShort2Height}, 寬度${roadShort2Width}`);
            }

            // 計算road-short-2位置
            const roadShort2LeftDistanceRatio = 24 / 512; // 24像素距離在512背景中的比例 (4.69%)
            const roadShort2SpacingRatio = 40 / 512; // 40像素間距在512背景中的比例 (7.81%)
            
            const roadShort2LeftDistance = Math.floor(GAME_HEIGHT * roadShort2LeftDistanceRatio);
            const roadShort2Spacing = Math.floor(GAME_HEIGHT * roadShort2SpacingRatio);
            
            // 第一個road-short-2位置
            const firstRoadShort2X = bridge1X + bridge1Width + roadShort2LeftDistance; // road-short-2左邊與bridge-1右邊距離24像素
            const firstRoadShort2Y = bridge1Y; // road-short-2頂部與bridge-1頂部貼齊
            
            // 創建8個road-short-2並添加到world.roads
            for (let i = 0; i < 8; i++) {
                const roadShort2X = firstRoadShort2X + i * (roadShort2Width + roadShort2Spacing);
                const roadShort2Y = firstRoadShort2Y;
                
                world.roads.push({
                    x: roadShort2X,
                    y: roadShort2Y,
                    width: roadShort2Width,
                    height: roadShort2Height,
                    type: 'road-short-2',
                    id: `road-short-2-${i + 1}`,
                    isFalling: false,
                    fallStartTime: null,
                    fallDuration: 1000, // 1秒掉落時間
                    originalY: roadShort2Y // 記錄原始Y位置
                });
            }
            
            console.log('🏗️ 8個road-short-2創建完成:', world.roads.filter(r => r.type === 'road-short-2'));

            // 創建bridge-2
            const bridge2HeightRatio = 122 / 512; // 122像素高度在512背景中的比例 (23.83%)
            let bridge2Width, bridge2Height;
            
            if (roadOriginalSizes['bridge-2']) {
                const originalSize = roadOriginalSizes['bridge-2'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算bridge-2高度
                bridge2Height = Math.floor(GAME_HEIGHT * bridge2HeightRatio);
                // 根據原始比例計算寬度
                bridge2Width = Math.floor(bridge2Height * originalRatio);
                
                console.log(`🎯 Bridge-2動態尺寸計算: 遊戲高度${GAME_HEIGHT} → bridge-2高度${bridge2Height}, 寬度${bridge2Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:1
                bridge2Height = Math.floor(GAME_HEIGHT * bridge2HeightRatio);
                bridge2Width = Math.floor(bridge2Height * 4); // 預設比例
                
                console.log(`⚠️ Bridge-2使用預設比例: 高度${bridge2Height}, 寬度${bridge2Width}`);
            }

            // 計算bridge-2位置
            const bridge2LeftDistanceRatio = 24 / 512; // 24像素距離在512背景中的比例 (4.69%)
            const bridge2LeftDistance = Math.floor(GAME_HEIGHT * bridge2LeftDistanceRatio);
            
            // 找到最後一個road-short-2的位置
            const lastRoadShort2 = world.roads.find(road => road.type === 'road-short-2' && road.id === 'road-short-2-8');
            const bridge2X = lastRoadShort2.x + lastRoadShort2.width + bridge2LeftDistance; // bridge-2左邊與最後一個road-short-2右邊距離24像素
            const bridge2Y = lastRoadShort2.y; // bridge-2頂部對齊road-short-2的頂部

            // 添加bridge-2到world.roads
            world.roads.push({
                x: bridge2X,
                y: bridge2Y,
                width: bridge2Width,
                height: bridge2Height,
                type: 'bridge-2'
            });

            console.log('🌉 Bridge-2創建完成:', { x: bridge2X, y: bridge2Y, width: bridge2Width, height: bridge2Height });

            // 創建road-9
            const road9HeightRatio = 32 / 512; // 32像素高度在512背景中的比例，與road-5相同 (6.25%)
            let road9Width, road9Height;
            
            if (roadOriginalSizes['road-9']) {
                const originalSize = roadOriginalSizes['road-9'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-9高度
                road9Height = Math.floor(GAME_HEIGHT * road9HeightRatio);
                // 根據原始比例計算寬度
                road9Width = Math.floor(road9Height * originalRatio);
                
                console.log(`🎯 Road-9動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-9高度${road9Height}, 寬度${road9Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:1
                road9Height = Math.floor(GAME_HEIGHT * road9HeightRatio);
                road9Width = Math.floor(road9Height * 4); // 預設比例
                
                console.log(`⚠️ Road-9使用預設比例: 高度${road9Height}, 寬度${road9Width}`);
            }

            // 計算road-9位置
            const road9LeftDistanceRatio = 49 / 512; // 49像素距離在512背景中的比例 (9.57%)
            const road9LeftDistance = Math.floor(GAME_HEIGHT * road9LeftDistanceRatio);
            
            const road9X = bridge2X + road9LeftDistance; // road-9左邊與bridge-2左邊距離49像素
            const road9Y = bridge2Y + bridge2Height; // road-9頂部對齊bridge-2底部

            // 添加road-9到world.roads
            world.roads.push({
                x: road9X,
                y: road9Y,
                width: road9Width,
                height: road9Height,
                type: 'road-9'
            });

            console.log('🏗️ Road-9創建完成:', { x: road9X, y: road9Y, width: road9Width, height: road9Height });

            // 創建一組水平排列的HP Logo（3個）
            const road9HpLogoSpacingRatio = 8 / 512; // 8像素間距在512背景中的比例 (1.56%)
            const road9HpLogoLeftDistanceRatio = 110 / 512; // 110像素距離在512背景中的比例 (21.48%)
            
            const road9HpLogoSpacing = Math.floor(GAME_HEIGHT * road9HpLogoSpacingRatio);
            const road9HpLogoLeftDistance = Math.floor(GAME_HEIGHT * road9HpLogoLeftDistanceRatio);
            
            // 計算HP Logo的位置
            const road9HpLogoX = bridge2X + bridge2Width + road9HpLogoLeftDistance; // HP Logo左邊與bridge-2右邊距離110像素
            const road9HpLogoHeightRatio = 41 / 512; // 41像素高度在512背景中的比例
            const road9HpLogoHeight = Math.floor(GAME_HEIGHT * road9HpLogoHeightRatio);
            const road9HpLogoY = road9Y - road9HpLogoHeight; // HP Logo底部與road-9頂部貼齊
            
            // 創建3個水平排列的HP Logo
            hpLogoManager.createHorizontalHpLogos(road9HpLogoX, road9HpLogoY, 3, road9HpLogoSpacing, GAME_HEIGHT);
            
            console.log('🩹 Road-9上方HP Logo創建完成（3個）');

            // 創建laboratory-1
            const laboratory1HeightRatio = 209 / 512; // 209像素高度在512背景中的比例 (40.82%)
            let laboratory1Width, laboratory1Height;
            
            if (roadOriginalSizes['laboratory-1']) {
                const originalSize = roadOriginalSizes['laboratory-1'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算laboratory-1高度
                laboratory1Height = Math.floor(GAME_HEIGHT * laboratory1HeightRatio);
                // 根據原始比例計算寬度
                laboratory1Width = Math.floor(laboratory1Height * originalRatio);
                
                console.log(`🎯 Laboratory-1動態尺寸計算: 遊戲高度${GAME_HEIGHT} → laboratory-1高度${laboratory1Height}, 寬度${laboratory1Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:3
                laboratory1Height = Math.floor(GAME_HEIGHT * laboratory1HeightRatio);
                laboratory1Width = Math.floor(laboratory1Height * (4/3)); // 預設比例
                
                console.log(`⚠️ Laboratory-1使用預設比例: 高度${laboratory1Height}, 寬度${laboratory1Width}`);
            }

            // 計算laboratory-1位置
            const laboratory1LeftDistanceRatio = 112 / 512; // 112像素距離在512背景中的比例 (21.88%)
            const laboratory1LeftDistance = Math.floor(GAME_HEIGHT * laboratory1LeftDistanceRatio);
            
            // 計算HP Logo模組的右邊位置
            const road9HpLogoWidth = road9HpLogoHeight; // 假設為正方形
            const hpLogosTotalWidth = (road9HpLogoWidth * 3) + (road9HpLogoSpacing * 2); // 3個HP Logo + 2個間距
            const hpLogosRightX = road9HpLogoX + hpLogosTotalWidth;
            
            const laboratory1X = hpLogosRightX + laboratory1LeftDistance; // laboratory-1左邊與hp-logo模組右邊距離112像素
            const laboratory1Y = road9Y - laboratory1Height; // laboratory-1底部貼齊road-9的頂部

            // 添加laboratory-1到world.roads
            world.roads.push({
                x: laboratory1X,
                y: laboratory1Y,
                width: laboratory1Width,
                height: laboratory1Height,
                type: 'laboratory-1',
                isTransformed: false,
                transformStartTime: null,
                transformDuration: 200 // 0.2秒轉換時間
            });

            console.log('🏥 Laboratory-1創建完成:', { x: laboratory1X, y: laboratory1Y, width: laboratory1Width, height: laboratory1Height });
            
            // 同步到舊系統（向後兼容）
            springs = springManager.springs;
            hpLogos = hpLogoManager.hpLogos;
            
            // 動態計算世界寬度，確保包含所有元素
            let maxX = 0;
            
            // 檢查所有road元素的最右邊位置
            world.roads.forEach(road => {
                const roadRightX = road.x + road.width;
                if (roadRightX > maxX) {
                    maxX = roadRightX;
                }
            });
            
            // 檢查所有HP Logo的最右邊位置
            hpLogoManager.hpLogos.forEach(hpLogo => {
                const hpLogoRightX = hpLogo.x + hpLogo.width;
                if (hpLogoRightX > maxX) {
                    maxX = hpLogoRightX;
                }
            });
            
            // 檢查所有Spring的最右邊位置
            springManager.springs.forEach(spring => {
                const springRightX = spring.x + spring.width;
                if (springRightX > maxX) {
                    maxX = springRightX;
                }
            });
            
            // 設定世界寬度為road-9最右邊，限制遊戲範圍
            world.width = road9X + road9Width;
            
            console.log(`🌍 世界寬度限制在road-9右邊: ${world.width}px`);
            
            // 遊戲終點設定在road-9最右邊
            world.endpoint = road9X + road9Width;
            console.log(`🎯 遊戲終點設定在: ${world.endpoint}px (road-9最右邊)`);
        }
        
        function setupEventListeners() {
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                if (e.code === 'Space') e.preventDefault();
            });
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });
            window.addEventListener('resize', () => {
                // 更新遊戲尺寸以適應新的視窗尺寸
                updateCanvasSize();
                world.height = GAME_HEIGHT; // 同時更新世界高度
                
                // 動態重新計算角色大小
                const playerSize = calculatePlayerSize();
                player.width = playerSize.width;
                player.height = playerSize.height;
                
                // 重新創建世界以適應新尺寸
                createWorld();
                
                // 重新計算Spring尺寸（窗口大小改變時）
                if (springManager.springs.length > 0 && springManager.imagesLoaded) {
                    springManager.updateAllDimensions();
                }
                
                // 重新創建心臟系統（窗口大小改變時）
                if (heartManager.imagesLoaded) {
                    heartManager.clear();
                    heartManager.createHearts();
                }
                
                // 調整玩家位置
                player.y = Math.floor(GAME_HEIGHT * 0.5);
            });
        }
        
        // 設置失敗畫面圖片尺寸和 retry-btn 位置
        function setupFailureScreen() {
            const gameOverImage = document.getElementById('gameOverImage');
            const retryBtnContainer = document.querySelector('.retry-btn-container');
            const retryBtnImage = document.getElementById('retryBtnImage');
            
            if (gameOverImage && retryBtnContainer && retryBtnImage) {
                // 預先載入 retry-btn 圖片
                retryBtnImage.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/retry-btn.svg';
                
                // 追蹤重試按鈕點擊的變數
                let isProcessingRetryClick = false; // 防止快速連續點擊

                // 創建調整圖片尺寸的函數
                function adjustFailureImageSize() {
                    // 根據 game over 圖片比例計算
                    // 使用與 story-1 相似的比例邏輯
                    const storyBgHeight = 749;
                    const gameOverHeight = 400; // 假設與story-1相似的高度
                    const heightRatio = gameOverHeight / storyBgHeight; // 約0.534
                    
                    // 獲取當前視窗高度
                    const windowHeight = window.innerHeight;
                    
                    // 計算 game over 的目標高度
                    const targetHeight = Math.floor(windowHeight * heightRatio);
                    
                    console.log(`🔍 視窗高度: ${windowHeight}px`);
                    console.log(`🔍 Game Over 目標高度: ${targetHeight}px (${heightRatio * 100}% 的視窗高度)`);
                    
                    // 保持原始寬高比
                    const originalWidth = this.naturalWidth;
                    const originalHeight = this.naturalHeight;
                    const aspectRatio = originalWidth / originalHeight;
                    
                    // 計算對應的寬度
                    const targetWidth = Math.floor(targetHeight * aspectRatio);
                    
                    // 設定圖片尺寸
                    this.style.width = targetWidth + 'px';
                    this.style.height = targetHeight + 'px';
                    
                    console.log(`📏 Game Over 尺寸設定: ${targetWidth}x${targetHeight} (比例: ${heightRatio.toFixed(3)})`);
                    
                    // 計算 retry-btn 的位置
                    const gameOverCenterY = windowHeight / 2;
                    const gameOverTop = gameOverCenterY - (targetHeight / 2);
                    const gameOverBottom = gameOverTop + targetHeight;
                    
                    // 計算 retry-btn 與 game over 的距離
                    // 使用與前言畫面相同的距離比例
                    const baseDistance = 16;
                    const distanceRatio = baseDistance / storyBgHeight;
                    const distanceFromGameOver = Math.floor(windowHeight * distanceRatio);
                    
                    console.log(`📏 Retry-btn 距離: ${distanceFromGameOver}px (原始 ${baseDistance}px 的 ${(distanceRatio * 100).toFixed(2)}%)`);

                    const retryBtnTop = gameOverBottom + distanceFromGameOver;
                    
                    // 設定 retry-btn 容器位置
                    retryBtnContainer.style.top = retryBtnTop + 'px';
                    
                    console.log(`📍 Retry-btn 位置: top=${retryBtnTop}px, 水平置中 (與game over x軸對齊)`);
                    
                    // 確保按鈕可以被點擊
                    retryBtnImage.style.pointerEvents = 'auto';
                    retryBtnImage.style.cursor = 'pointer';
                    console.log('🔗 Retry按鈕事件監聽器準備添加');
                    
                    // 添加點擊事件
                    retryBtnImage.addEventListener('click', function(event) {
                        if (isProcessingRetryClick) {
                            console.log('⚠️ 點擊處理中，請稍候...');
                            return;
                        }
                        
                        isProcessingRetryClick = true;
                        console.log('🖱️ Retry Button clicked! 準備重新開始遊戲...');
                        
                        // 播放按鈕音效
                        playButtonAudio();
                        
                        // 延遲重新開始以讓音效播放
                        setTimeout(() => {
                            directRestartGame();
                            isProcessingRetryClick = false;
                        }, 200);
                    });
                }
                
                // 當 game over 圖片載入完成時調整尺寸
                gameOverImage.onload = adjustFailureImageSize;
                
                // 設定 game over 圖片來源以觸發 onload
                gameOverImage.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/game over.svg';
            }
        }
        
        // 顯示失敗畫面
        function showFailureScreen() {
            // 停止遊戲循環
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            gameState = 'failed';
            
            // 停止背景音樂
            stopGameBGM();
            
            // 停止跑步音效
            stopRunningAudio();
            
            // 清除淡出效果
            if (fadeInterval) {
                clearInterval(fadeInterval);
                fadeInterval = null;
            }
            
            // 顯示失敗畫面
            const failureModal = document.getElementById('failureModal');
            failureModal.style.display = 'flex';
            
            // 設置失敗畫面
            setupFailureScreen();
            
            console.log('💀 失敗畫面顯示，所有音效已停止');
        }
        
        // 設置 story-1 圖片尺寸和 next-btn 位置
        function setupStory1Image() {
            const story1Image = document.getElementById('story1Image');
            const nextBtnContainer = document.querySelector('.next-btn-container');
            const nextBtnImage = document.getElementById('nextBtnImage');
            
            if (story1Image && nextBtnContainer && nextBtnImage) {
                // 預先載入 next-btn 圖片
                nextBtnImage.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/next-btn.svg';
                
                // 使用全域變數 clickCount 和 isProcessingClick

                // 創建調整圖片尺寸的函數
                function adjustImageSize() {
                    // 根據你提供的比例計算
                    // story-bg 高度 749，story-1 高度 536
                    // 比例為 536/749 ≈ 0.715
                    const storyBgHeight = 749;
                    const story1Height = 400;
                    const heightRatio = story1Height / storyBgHeight; // 0.715
                    
                    // 獲取當前視窗高度（這是 story-bg 的實際高度）
                    const windowHeight = window.innerHeight;
                    
                    // 計算 story-1 的目標高度
                    const targetHeight = Math.floor(windowHeight * heightRatio);
                    
                    console.log(`🔍 視窗高度: ${windowHeight}px`);
                    console.log(`🔍 Story-1 目標高度: ${targetHeight}px (${heightRatio * 100}% 的視窗高度)`);
                    
                    // 驗證比例是否正確
                    const actualRatio = targetHeight / windowHeight;
                    console.log(`🔍 實際比例: ${actualRatio.toFixed(3)} (應為 ${heightRatio.toFixed(3)})`);
                    
                    // 如果比例不正確，強制使用正確的比例
                    if (Math.abs(actualRatio - heightRatio) > 0.001) {
                        console.log(`⚠️ 比例不正確，調整中...`);
                        const correctedHeight = Math.floor(windowHeight * heightRatio);
                        if (correctedHeight !== targetHeight) {
                            console.log(`📐 調整高度: ${targetHeight}px → ${correctedHeight}px`);
                            targetHeight = correctedHeight;
                        }
                    }
                    
                    // 保持原始寬高比
                    const originalWidth = this.naturalWidth;
                    const originalHeight = this.naturalHeight;
                    const aspectRatio = originalWidth / originalHeight;
                    
                    // 計算對應的寬度
                    const targetWidth = Math.floor(targetHeight * aspectRatio);
                    
                    // 設定圖片尺寸
                    this.style.width = targetWidth + 'px';
                    this.style.height = targetHeight + 'px';
                    
                    console.log(`📏 Story-1 尺寸設定: ${targetWidth}x${targetHeight} (比例: ${heightRatio.toFixed(3)})`);
                    
                    // 計算 next-btn 的位置
                    const story1CenterY = windowHeight / 2;
                    const story1Top = story1CenterY - (targetHeight / 2);
                    const story1Bottom = story1Top + targetHeight;
                    
                    // 計算 next-btn 與 story-1 的距離
                    // 當 story-bg 高度為 749px 時，距離為 36px
                    // 所以距離也要根據視窗高度等比例縮放
                    const baseDistance = 16;
                    const distanceRatio = baseDistance / storyBgHeight; // 36/749
                    const distanceFromStory1 = Math.floor(windowHeight * distanceRatio);
                    
                    console.log(`📏 Next-btn 距離: ${distanceFromStory1}px (原始 ${baseDistance}px 的 ${(distanceRatio * 100).toFixed(2)}%)`);
                    
                    const nextBtnTop = story1Bottom + distanceFromStory1;
                    
                    // 設定 next-btn 容器位置
                    // 只設定垂直位置，水平位置由 CSS 控制 (left: 50%, transform: translateX(-50%))
                    nextBtnContainer.style.top = nextBtnTop + 'px';
                    
                    console.log(`📍 Next-btn 位置: top=${nextBtnTop}px, 水平置中 (與story-1 x軸對齊)`);
                    
                    // 確保按鈕可以被點擊
                    nextBtnImage.style.pointerEvents = 'auto';
                    nextBtnImage.style.cursor = 'pointer';
                    console.log('🔗 按鈕事件監聽器準備添加');
                    
                    // 立即添加點擊事件（因為動畫會自動開始）
                    nextBtnImage.addEventListener('click', function(event) {
                        event.preventDefault();
                        event.stopPropagation();
                        
                        // 播放按鈕點擊音效
                        playButtonAudio();
                        
                        // 防止快速連續點擊
                        if (isProcessingClick) {
                            console.log('⚠️ 點擊處理中，忽略此次點擊');
                            return;
                        }
                        
                        isProcessingClick = true;
                        
                        // 檢查當前按鈕類型（使用 endsWith 更可靠）
                        const isStartBtn = nextBtnImage.src.endsWith('start-btn.svg');
                        console.log(`🖱️ Button clicked! 當前按鈕類型: ${isStartBtn ? 'start-btn' : 'next-btn'}, 處理中...`);
                        
                        if (isStartBtn) {
                            // 如果是 start-btn，直接開始遊戲
                            console.log('🎮 點擊 start-btn，開始遊戲！');
                            startGame();
                            isProcessingClick = false;
                        } else {
                            // 如果是 next-btn，進行故事切換
                            clickCount++;
                            console.log(`📄 Next-btn 點擊次數: ${clickCount}`);
                            
                            if (clickCount === 1) {
                                // 第一次點擊：切換到 story-2
                                story1Image.onload = adjustImageSize;
                                story1Image.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/story-2.svg';
                                console.log('📄 切換到 story-2');
                                
                                // 延遲解鎖點擊
                                setTimeout(() => {
                                    isProcessingClick = false;
                                    console.log('🔓 點擊處理完成，可以再次點擊');
                                }, 500);
                                
                            } else if (clickCount === 2) {
                                // 第二次點擊：切換到 story-3 並改變按鈕圖片
                                story1Image.onload = adjustImageSize;
                                story1Image.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/story-3.svg';
                                
                                // 延遲切換按鈕圖片，避免立即觸發事件
                                setTimeout(() => {
                                    console.log('🔄 準備切換按鈕為 start-btn');
                                    nextBtnImage.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/start-btn.svg';
                                    console.log('✅ 按鈕已切換為 start-btn');
                                    
                                    // 延遲解鎖點擊
                                    setTimeout(() => {
                                        isProcessingClick = false;
                                        console.log('🔓 點擊處理完成，可以點擊 start-btn');
                                    }, 200);
                                }, 100);
                                
                                console.log('📄 切換到 story-3，按鈕將在 100ms 後變為 start-btn');
                            }
                        }
                    });
                    
                    console.log('✅ 按鈕事件監聽器已添加');
                    
                    // 測試點擊功能
                    nextBtnImage.addEventListener('mousedown', function() {
                        console.log('🖱️ 滑鼠按下按鈕！');
                    });
                    
                    nextBtnImage.addEventListener('mouseup', function() {
                        console.log('🖱️ 滑鼠放開按鈕！');
                    });
                };
                
                // 設定圖片載入事件
                story1Image.onload = adjustImageSize;
                
                // 設定 story-1 圖片來源以觸發 onload
                story1Image.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/story-1.svg';
            }
        }
        
        // 設置 next-btn 位置
        function setupNextBtnPosition(story1Height) {
            const nextBtnContainer = document.querySelector('.next-btn-container');
            const nextBtnImage = document.getElementById('nextBtnImage');
            
            if (nextBtnContainer && nextBtnImage) {
                nextBtnImage.onload = function() {
                    // 計算 next-btn 的位置
                    // 距離 story-1 底部 36 像素
                    const distanceFromStory1 = 36;
                    
                    // 計算 story-1 的位置
                    const windowHeight = window.innerHeight;
                    const story1CenterY = windowHeight / 2;
                    const story1Top = story1CenterY - (story1Height / 2);
                    const story1Bottom = story1Top + story1Height;
                    
                    // 設定 next-btn 容器位置
                    const nextBtnTop = story1Bottom + distanceFromStory1;
                    nextBtnContainer.style.top = nextBtnTop + 'px';
                    console.log(`📏 Story-1 位置: top=${story1Top}, bottom=${story1Bottom}`);
                    console.log(`📏 Next-btn 位置: top=${nextBtnTop} (距離story-1底部${distanceFromStory1}px)`);
                    
                    // 設定 next-btn 圖片尺寸（保持適當大小）
                    
                    // 在 1 秒後顯示 next-btn（等 story-1 動畫結束）
                    setTimeout(() => {
                        nextBtnContainer.style.display = 'block';
                        console.log('🕐 Next button 顯示');
                    }, 1000);
                    const maxWidth = 200;
                    const maxHeight = 80;
                    
                    // 保持原始寬高比
                    const originalWidth = this.naturalWidth;
                    const originalHeight = this.naturalHeight;
                    const aspectRatio = originalWidth / originalHeight;
                    
                    let targetWidth, targetHeight;
                    if (aspectRatio > maxWidth / maxHeight) {
                        // 寬度優先
                        targetWidth = maxWidth;
                        targetHeight = maxWidth / aspectRatio;
                    } else {
                        // 高度優先
                        targetHeight = maxHeight;
                        targetWidth = maxHeight * aspectRatio;
                    }
                    
                    this.style.width = targetWidth + 'px';
                    this.style.height = targetHeight + 'px';
                    
                    console.log(`📍 Next-btn 位置設定: top=${nextBtnTop}px, 尺寸=${targetWidth}x${targetHeight}`);
                };
            }
        }
        
        // 按鈕音效管理函數
        function initButtonAudio() {
            try {
                buttonAudio = new Audio('Vibe Coding 組_SylviaSYLin遊戲介面/assets/sound/button.mp3');
                buttonAudio.volume = buttonAudioVolume;
                console.log('🔊 按鈕音效初始化完成（音量：' + (buttonAudioVolume * 100) + '%）');
            } catch (error) {
                console.log('🚫 按鈕音效初始化失敗:', error);
            }
        }
        
        function playButtonAudio() {
            if (buttonAudio) {
                buttonAudio.currentTime = 0; // 重置播放位置
                buttonAudio.volume = buttonAudioVolume; // 確保音量正確
                buttonAudio.play().catch(e => {
                    console.log('🚫 按鈕音效播放失敗:', e);
                });
            }
        }
        
        function initJumpAudio() {
            try {
                jumpAudio = new Audio('Vibe Coding 組_SylviaSYLin遊戲介面/assets/sound/jump.mp3');
                jumpAudio.volume = jumpAudioVolume;
                console.log('🔊 跳躍音效初始化完成（音量：' + (jumpAudioVolume * 100) + '%）');
            } catch (error) {
                console.log('🚫 跳躍音效初始化失敗:', error);
            }
        }
        
        function playJumpAudio() {
            if (jumpAudio) {
                jumpAudio.currentTime = 0; // 重置播放位置
                jumpAudio.volume = jumpAudioVolume; // 確保音量正確
                jumpAudio.play().catch(e => {
                    console.log('🚫 跳躍音效播放失敗:', e);
                });
            }
        }
        
        function initHpLogoAudio() {
            try {
                hpLogoAudio = new Audio('Vibe Coding 組_SylviaSYLin遊戲介面/assets/sound/gethp.mp3');
                hpLogoAudio.volume = hpLogoAudioVolume;
                console.log('🔊 HP Logo 音效初始化完成（音量：' + (hpLogoAudioVolume * 100) + '%）');
            } catch (error) {
                console.log('🚫 HP Logo 音效初始化失敗:', error);
            }
        }
        
        function playHpLogoAudio() {
            if (hpLogoAudio) {
                hpLogoAudio.currentTime = 0; // 重置播放位置
                hpLogoAudio.volume = hpLogoAudioVolume; // 確保音量正確
                hpLogoAudio.play().catch(e => {
                    console.log('🚫 HP Logo 音效播放失敗:', e);
                });
            }
        }
        
        function initRunningAudio() {
            try {
                runningAudio = new Audio('Vibe Coding 組_SylviaSYLin遊戲介面/assets/sound/running.mp3');
                runningAudio.volume = runningAudioVolume;
                runningAudio.loop = true; // 跑步音效循環播放
                console.log('🔊 跑步音效初始化完成（音量：' + (runningAudioVolume * 100) + '%）');
            } catch (error) {
                console.log('🚫 跑步音效初始化失敗:', error);
            }
        }
        
        function startRunningAudio() {
            if (runningAudio && !isRunningAudioPlaying) {
                runningAudio.currentTime = 0;
                runningAudio.volume = runningAudioVolume;
                runningAudio.play().then(() => {
                    isRunningAudioPlaying = true;
                    console.log('🏃‍♂️ 開始播放跑步音效');
                }).catch(e => {
                    console.log('🚫 跑步音效播放失敗:', e);
                });
            }
        }
        
        function stopRunningAudio() {
            if (runningAudio && isRunningAudioPlaying) {
                runningAudio.pause();
                runningAudio.currentTime = 0;
                isRunningAudioPlaying = false;
                console.log('🏃‍♂️ 停止播放跑步音效');
            }
        }
        
        function initEndAudio() {
            try {
                endAudio = new Audio('Vibe Coding 組_SylviaSYLin遊戲介面/assets/sound/end.mp3');
                endAudio.volume = endAudioVolume;
                console.log('🔊 結束音效初始化完成（音量：' + (endAudioVolume * 100) + '%）');
            } catch (error) {
                console.log('🚫 結束音效初始化失敗:', error);
            }
        }
        
        function playEndAudio() {
            if (endAudio) {
                endAudio.currentTime = 0; // 重置播放位置
                endAudio.volume = endAudioVolume; // 確保音量正確
                endAudio.play().catch(e => {
                    console.log('🚫 結束音效播放失敗:', e);
                });
            }
        }
        
        function initCloudAudio() {
            try {
                cloudAudio = new Audio('Vibe Coding 組_SylviaSYLin遊戲介面/assets/sound/light.mp3');
                cloudAudio.volume = cloudAudioVolume;
                console.log('🔊 Cloud 音效初始化完成（音量：' + (cloudAudioVolume * 100) + '%）');
            } catch (error) {
                console.log('🚫 Cloud 音效初始化失敗:', error);
            }
        }
        
        function startCloudAudio() {
            if (cloudAudio && !isCloudAudioPlaying) {
                isCloudAudioPlaying = true;
                cloudAudioPlayCount = 0; // 重置播放次數
                
                // 立即播放第一次
                playCloudAudio();
                cloudAudioPlayCount++;
                console.log('☁️ 開始播放 Cloud 音效（播放兩次，每次間隔9秒）');
                
                // 隔9秒播放第二次
                setTimeout(() => {
                    if (isCloudAudioPlaying) {
                        playCloudAudio();
                        cloudAudioPlayCount++;
                        console.log('☁️ Cloud 音效播放完成兩次');
                        isCloudAudioPlaying = false;
                    }
                }, 9000); // 9秒延遲
            }
        }
        
        function stopCloudAudio() {
            if (cloudAudio && isCloudAudioPlaying) {
                isCloudAudioPlaying = false;
                cloudAudioPlayCount = 0; // 重置播放次數
                console.log('☁️ 停止播放 Cloud 音效');
            }
        }
        
        function playCloudAudio() {
            if (cloudAudio && isCloudAudioPlaying) {
                cloudAudio.currentTime = 0; // 重置播放位置
                cloudAudio.volume = cloudAudioVolume; // 確保音量正確
                
                cloudAudio.play().catch(e => {
                    console.log('🚫 Cloud 音效播放失敗:', e);
                });
            }
        }
        
        // Born 音效管理函數
        function initBornAudio() {
            try {
                bornAudio = new Audio('Vibe Coding 組_SylviaSYLin遊戲介面/assets/sound/born.mp3');
                bornAudio.volume = bornAudioVolume;
                bornAudio.loop = true; // 設定循環播放
                console.log('🔊 Born 音效初始化完成（音量：' + (bornAudioVolume * 100) + '%，循環播放）');
            } catch (error) {
                console.log('🚫 Born 音效初始化失敗:', error);
            }
        }
        
        function playBornAudio() {
            if (bornAudio && !isBornAudioPlaying) {
                isBornAudioPlaying = true;
                bornAudio.currentTime = 0; // 重置播放位置
                bornAudio.volume = bornAudioVolume; // 確保音量正確
                
                bornAudio.play().then(() => {
                    console.log('🎵 Born 音效開始循環播放');
                }).catch(e => {
                    console.log('🚫 Born 音效播放失敗:', e);
                    isBornAudioPlaying = false;
                });
            }
        }
        
        function stopBornAudio() {
            if (bornAudio && isBornAudioPlaying) {
                bornAudio.pause();
                bornAudio.currentTime = 0;
                isBornAudioPlaying = false;
                console.log('🔇 Born 音效已停止');
            }
        }
        
        // ===============================
        // 結局影片管理函數
        // ===============================
        
        function initEndingVideo() {
            console.log('🎬 開始初始化結局影片元素...');
            
            endingVideo = document.createElement('video');
            endingVideo.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/ending_animation.mp4';
            endingVideo.controls = false; // 隱藏所有控制界面
            endingVideo.style.position = 'fixed';
            endingVideo.style.top = '0';
            endingVideo.style.left = '0';
            endingVideo.style.width = '100vw';
            endingVideo.style.height = '100vh';
            endingVideo.style.objectFit = 'contain';
            endingVideo.style.backgroundColor = 'black';
            endingVideo.style.zIndex = '9999';
            endingVideo.style.display = 'none';
            
            // 完全隱藏影片控制界面
            endingVideo.style.outline = 'none';
            endingVideo.style.border = 'none';
            endingVideo.setAttribute('disablePictureInPicture', '');
            endingVideo.setAttribute('controlsList', 'nodownload nofullscreen noremoteplayback');
            
            // 禁用右鍵選單
            endingVideo.oncontextmenu = function(e) {
                e.preventDefault();
                return false;
            };
            
            // 影片加載成功處理
            endingVideo.onloadeddata = function() {
                console.log('🎬 結局影片加載成功！');
            };
            
            // 影片結束後的處理
            endingVideo.onended = function() {
                console.log('🎬 結局影片播放完畢，開始顯示 GIF 動畫');
                showEndingGif();
            };
            
            // 影片加載錯誤處理
            endingVideo.onerror = function(e) {
                console.error('❌ 結局影片加載失敗:', e);
                console.error('❌ 影片路徑:', endingVideo.src);
                alert('結局影片加載失敗，請確認 Vibe Coding 組_SylviaSYLin遊戲介面/assets/ending_animation.mp4 文件存在\n路徑: ' + endingVideo.src);
            };
            
            // 測試：嘗試預加載影片
            endingVideo.preload = 'metadata';
            
            document.body.appendChild(endingVideo);
            console.log('🎬 結局影片元素已添加到頁面');
            console.log('🎬 影片元素:', endingVideo);
            console.log('🎬 影片路徑:', endingVideo.src);
        }
        
        function playEndingVideo() {
            console.log('🎬 開始播放結局影片');
            
            if (!endingVideo) {
                console.log('🎬 初始化結局影片元素...');
                initEndingVideo();
            }
            
            if (!endingState.videoPlayed) {
                endingState.videoPlayed = true;
                
                // 顯示影片並開始播放
                endingVideo.style.display = 'block';
                console.log('🎬 影片元素已顯示，開始播放...');
                
                endingVideo.play().then(() => {
                    console.log('🎬 結局影片播放成功開始！');
                }).catch(e => {
                    console.error('❌ 結局影片播放失敗:', e);
                    alert('結局影片播放失敗: ' + e.message + '\n請確認 Vibe Coding 組_SylviaSYLin遊戲介面/assets/ending_animation.mp4 檔案存在且可播放');
                });
                
                // 暫停遊戲主循環
                if (gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                    console.log('🎮 遊戲主循環已暫停');
                }
            } else {
                console.log('🎬 影片已經播放過了');
            }
        }
        
        // ===============================
        // 結局 GIF 動畫系統
        // ===============================
        
        function initEndingGif() {
            console.log('🎞️ 初始化結局 GIF 動畫容器...');
            
            // 創建 GIF 動畫容器
            endingGifContainer = document.createElement('div');
            endingGifContainer.style.position = 'fixed';
            endingGifContainer.style.top = '0';
            endingGifContainer.style.left = '0';
            endingGifContainer.style.width = '100vw';
            endingGifContainer.style.height = '100vh';
            endingGifContainer.style.backgroundColor = 'black';
            endingGifContainer.style.zIndex = '9999';
            endingGifContainer.style.display = 'none';
            endingGifContainer.style.pointerEvents = 'none'; // 容器不阻擋點擊
            
            // 創建圖片元素（與影片尺寸完全相同）
            const gifImage = document.createElement('img');
            gifImage.id = 'endingGifImage';
            gifImage.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/pass-1.png';
            gifImage.style.position = 'fixed';
            gifImage.style.top = '0';
            gifImage.style.left = '0';
            gifImage.style.width = '100vw';
            gifImage.style.height = '100vh';
            gifImage.style.objectFit = 'contain';
            gifImage.style.backgroundColor = 'black';
            gifImage.style.transition = 'opacity 0.1s ease'; // 添加淡入效果
            
            // 創建重玩按鈕（精確定位）
            const retryButton = document.createElement('img');
            retryButton.id = 'endingRetryButton';
            retryButton.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/retry-btn-2.svg';
            retryButton.style.position = 'fixed';
            retryButton.style.cursor = 'pointer';
            retryButton.style.transition = 'transform 0.2s ease';
            retryButton.style.zIndex = '10000';
            retryButton.style.pointerEvents = 'auto'; // 確保按鈕可以被點擊
            
            // 動態計算按鈕尺寸和位置
            calculateRetryButtonPosition(retryButton);
            
            // 按鈕懸停效果（保持居中對齊）
            retryButton.onmouseover = function() {
                retryButton.style.transform = 'translateX(-50%) scale(1.1)';
            };
            retryButton.onmouseout = function() {
                retryButton.style.transform = 'translateX(-50%) scale(1)';
            };
            
            // 點擊重玩
            retryButton.onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                // 立即隱藏 GIF 容器以免阻擋
                if (endingGifContainer) {
                    endingGifContainer.style.display = 'none';
                }
                
                // 停止 Born 音效
                stopBornAudio();
                
                try {
                    directRestartGame();
                } catch (error) {
                    console.error('❌ directRestartGame 執行失敗:', error);
                    // 備用重置方案
                    emergencyRestart();
                }
            };
            
            // 添加觸摸事件支持（移動設備）
            retryButton.ontouchstart = function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (endingGifContainer) {
                    endingGifContainer.style.display = 'none';
                }
                
                // 停止 Born 音效
                stopBornAudio();
                
                try {
                    directRestartGame();
                } catch (error) {
                    emergencyRestart();
                }
            };
            
            // 組裝容器
            endingGifContainer.appendChild(gifImage);
            endingGifContainer.appendChild(retryButton);
            document.body.appendChild(endingGifContainer);
            
            // 監聽視窗尺寸變化，重新計算按鈕位置
            window.addEventListener('resize', () => {
                if (endingGifContainer.style.display === 'flex') {
                    calculateRetryButtonPosition(retryButton);
                }
            });
            
            console.log('🎞️ 結局 GIF 動畫容器初始化完成');
        }
        
        function calculateRetryButtonPosition(retryButton) {
            // 使用與 game over 時 retry-btn 相同的距離邏輯，但保持原本的按鈕尺寸設定
            const windowHeight = window.innerHeight;
            const windowWidth = window.innerWidth;
            
            // 使用與 game over retry-btn 相同的基準距離和比例
            const storyBgHeight = 512; // 與 game over 計算中使用的基準高度相同
            const baseDistance = 16; // 與 game over retry-btn 相同的基準距離
            const distanceRatio = baseDistance / storyBgHeight;
            const distanceFromImage = Math.floor(windowHeight * distanceRatio);
            
            // 設置按鈕尺寸（保持原本的動態設定）
            const buttonHeight = Math.floor(windowHeight * 0.08); // 大約佔螢幕高度的8%
            retryButton.style.height = buttonHeight + 'px';
            retryButton.style.width = 'auto'; // 保持比例
            
            console.log(`🔧 按鈕尺寸設定: ${buttonHeight}px 高度`);
            
            // 透過載入一個臨時圖片來取得實際的 pass-1 圖片尺寸
            const tempImg = new Image();
            tempImg.onload = function() {
                const imgAspectRatio = this.width / this.height;
                const screenAspectRatio = windowWidth / windowHeight;
                
                let actualImageWidth, actualImageHeight, imageTop;
                
                if (imgAspectRatio > screenAspectRatio) {
                    // 圖片較寬，以寬度為準
                    actualImageWidth = windowWidth;
                    actualImageHeight = windowWidth / imgAspectRatio;
                    imageTop = (windowHeight - actualImageHeight) / 2;
                } else {
                    // 圖片較高，以高度為準
                    actualImageHeight = windowHeight;
                    actualImageWidth = windowHeight * imgAspectRatio;
                    imageTop = 0;
                }
                
                // 計算圖片底部位置
                const imageBottom = imageTop + actualImageHeight;
                
                // 使用與 game over retry-btn 相同的位置邏輯
                const buttonTop = imageBottom + distanceFromImage;
                
                console.log(`📍 按鈕位置計算: 圖片底部=${imageBottom}px, 距離=${distanceFromImage}px, 按鈕頂部=${buttonTop}px`);
                
                // 確保按鈕不會超出螢幕，離底部至少40像素
                const minBottomMargin = 100;
                const maxButtonTop = windowHeight - buttonHeight - minBottomMargin;
                const safeButtonTop = Math.min(buttonTop, maxButtonTop);
                
                // 水平居中
                retryButton.style.left = '50%';
                retryButton.style.top = safeButtonTop + 'px';
                retryButton.style.transform = 'translateX(-50%)';
                retryButton.style.display = 'block'; // 確保按鈕顯示
                
                console.log(`✅ 按鈕最終位置: top=${safeButtonTop}px, 離底部=${windowHeight - safeButtonTop - buttonHeight}px`);
            };
            
            // 載入 pass-1 圖片來取得實際尺寸
            tempImg.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/pass-1.png';
        }
        
        function showEndingGif() {
            console.log('🎞️ 顯示結局 GIF 動畫');
            
            if (!endingGifContainer) {
                initEndingGif();
            }
            
            // 預先載入圖片以避免閃爍
            const preloadImage1 = new Image();
            const preloadImage2 = new Image();
            preloadImage1.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/pass-1.png';
            preloadImage2.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/pass-2.png';
            
            // 等待圖片載入完成後再顯示
            Promise.all([
                new Promise(resolve => preloadImage1.onload = resolve),
                new Promise(resolve => preloadImage2.onload = resolve)
            ]).then(() => {
                // 先準備 GIF 容器和圖片，但保持在影片後面
                endingGifContainer.style.display = 'flex';
                endingGifContainer.style.pointerEvents = 'none'; // 確保容器不阻擋點擊
                endingGifContainer.style.zIndex = '9998'; // 暫時放在影片後面
                
                // 重置到第一幀並立即設置圖片
                currentGifFrame = 1;
                const gifImage = document.getElementById('endingGifImage');
                if (gifImage) {
                    gifImage.style.opacity = '1'; // 直接顯示，不淡入
                    gifImage.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/pass-1.png';
                }
                
                // 開始播放 Born 音效（循環播放）
                playBornAudio();
                
                // 短暫延遲後再隱藏影片，確保 GIF 已經準備好
                setTimeout(() => {
                    if (endingVideo) {
                        endingVideo.style.display = 'none';
                    }
                    // 將 GIF 容器移到最前面
                    endingGifContainer.style.zIndex = '9999';
                    
                    // 重新計算按鈕位置（防止視窗尺寸變化）
                    const retryButton = document.getElementById('endingRetryButton');
                    if (retryButton) {
                        calculateRetryButtonPosition(retryButton);
                    }
                    
                    // 開始 GIF 動畫
                    startGifAnimation();
                }, 50); // 50ms 延遲，幾乎察覺不到但足夠讓 GIF 準備好
            });
        }
        
        function startGifAnimation() {
            console.log('🎞️ 開始 GIF 動畫循環');
            
            const gifImage = document.getElementById('endingGifImage');
            if (!gifImage) return;
            
            // 停止任何現有的動畫
            if (gifAnimationInterval) {
                clearInterval(gifAnimationInterval);
            }
            
            // 每1秒切換圖片（無閃爍切換）
            gifAnimationInterval = setInterval(() => {
                currentGifFrame = currentGifFrame === 1 ? 2 : 1;
                const nextImage = new Image();
                nextImage.onload = function() {
                    gifImage.src = `Vibe Coding 組_SylviaSYLin遊戲介面/assets/pass-${currentGifFrame}.png`;
                };
                nextImage.src = `Vibe Coding 組_SylviaSYLin遊戲介面/assets/pass-${currentGifFrame}.png`;
            }, 1000);
        }
        
        function stopGifAnimation() {
            if (gifAnimationInterval) {
                clearInterval(gifAnimationInterval);
                gifAnimationInterval = null;
            }
        }
        
        function restartGame() {
            console.log('🔄 重新開始遊戲...');
            
            // 停止 GIF 動畫
            stopGifAnimation();
            
            // 隱藏所有結局相關元素
            if (endingVideo) {
                endingVideo.style.display = 'none';
            }
            if (endingGifContainer) {
                endingGifContainer.style.display = 'none';
            }
            
            // 重置遊戲狀態
            gameState = 'intro';
            endingState.victoryTriggered = false;
            endingState.videoPlayed = false;
            
            // 重置前言系統狀態
            clickCount = 0;
            isProcessingClick = false;
            
            // 重置玩家位置和狀態
            player.x = 100;
            player.y = 0;
            player.velocityX = 0;
            player.velocityY = 0;
            player.controlDisabled = false;
            player.alpha = 1;
            
            // 重置攝影機
            camera.x = 0;
            camera.y = 0;
            
            // 重新創建世界
            createWorld();
            
            // 重置心臟管理器
            if (typeof heartManager !== 'undefined') {
                heartManager.reset();
            }
            
            // 重置其他管理器
            if (typeof springManager !== 'undefined') {
                springManager.reset();
            }
            if (typeof cloudManager !== 'undefined') {
                cloudManager.reset();
            }
            if (typeof cloudManager2 !== 'undefined') {
                cloudManager2.reset();
            }
            if (typeof lightningManager !== 'undefined') {
                lightningManager.reset();
            }
            if (typeof lightningManager2 !== 'undefined') {
                lightningManager2.reset();
            }
            
            // 重置前言畫面的圖片和按鈕
            const story1Image = document.getElementById('story1Image');
            const nextBtnImage = document.getElementById('nextBtnImage');
            if (story1Image) {
                story1Image.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/story-1.svg';
            }
            if (nextBtnImage) {
                nextBtnImage.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/next-btn.svg';
            }
            
            // 顯示前言畫面
            const introModal = document.getElementById('introModal');
            if (introModal) {
                introModal.style.display = 'flex';
                console.log('📖 前言畫面已顯示，已重置為 story-1');
            } else {
                console.error('❌ 找不到 introModal 元素');
            }
            
            // 重新開始遊戲循環
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
            }
            gameLoop();
            
            // 重新開始背景音樂
            if (gameBGM) {
                gameBGM.currentTime = 0;
                gameBGM.play().catch(e => {
                    console.log('🎵 背景音樂重新播放失敗:', e);
                });
            }
            
            console.log('🔄 遊戲重新開始完成');
        }
        
        // 備用重置方案
        function emergencyRestart() {
            console.log('🚨 執行備用重置方案...');
            
            // 強制重新載入頁面
            location.reload();
        }
        
        // ===============================
        // 通關提示系統
        // ===============================
        
        function showVictoryModal() {
            console.log('🎉 顯示通關提示');
            
            // 創建通關背景遮罩
            const victoryModal = document.createElement('div');
            victoryModal.id = 'victoryModal';
            victoryModal.style.position = 'fixed';
            victoryModal.style.top = '0';
            victoryModal.style.left = '0';
            victoryModal.style.width = '100%';
            victoryModal.style.height = '100%';
            victoryModal.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            victoryModal.style.display = 'flex';
            victoryModal.style.justifyContent = 'center';
            victoryModal.style.alignItems = 'center';
            victoryModal.style.zIndex = '9998';
            victoryModal.style.flexDirection = 'column';
            
            // 創建通關文字
            const victoryText = document.createElement('div');
            victoryText.innerHTML = '成功送達';
            victoryText.style.color = 'white';
            victoryText.style.fontSize = '48px';
            victoryText.style.fontFamily = 'Press Start 2P, monospace';
            victoryText.style.textAlign = 'center';
            victoryText.style.marginBottom = '40px';
            victoryText.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
            
            // 創建 pass-btn 按鈕
            const passButton = document.createElement('img');
            passButton.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/pass-btn.svg';
            passButton.style.width = '200px';
            passButton.style.height = 'auto';
            passButton.style.cursor = 'pointer';
            passButton.style.transition = 'transform 0.2s ease';
            
            // 按鈕懸停效果
            passButton.onmouseover = function() {
                passButton.style.transform = 'scale(1.1)';
            };
            passButton.onmouseout = function() {
                passButton.style.transform = 'scale(1)';
            };
            
            // 點擊按鈕播放影片
            passButton.onclick = function() {
                console.log('🎬 Pass 按鈕被點擊，開始播放結局影片');
                
                // 暫停遊戲背景音樂（如果有的話）
                if (gameBGM && !gameBGM.paused) {
                    gameBGM.pause();
                    console.log('🎵 背景音樂已暫停（由 pass-btn 觸發）');
                }
                
                hideVictoryModal();
                playEndingVideo();
            };
            
            // 組裝模態框
            victoryModal.appendChild(victoryText);
            victoryModal.appendChild(passButton);
            document.body.appendChild(victoryModal);
            
            console.log('🎉 通關提示顯示完成');
        }
        
        function hideVictoryModal() {
            const victoryModal = document.getElementById('victoryModal');
            if (victoryModal) {
                victoryModal.remove();
                console.log('🎉 通關提示已隱藏');
            }
        }
        
        // 音樂管理函數
        function initGameBGM() {
            try {
                gameBGM = new Audio('Vibe Coding 組_SylviaSYLin遊戲介面/assets/sound/game-bgm.mp3');
                gameBGM.volume = musicVolume; // 直接設定為完整音量
                gameBGM.loop = true; // 無限循環
                console.log('🎵 背景音樂初始化完成（音量：' + (musicVolume * 100) + '%）');
            } catch (error) {
                console.log('🚫 背景音樂初始化失敗:', error);
            }
        }
        
        function playGameBGM() {
            if (gameBGM) {
                gameBGM.currentTime = 0; // 從頭開始播放
                gameBGM.volume = musicVolume; // 直接設定為完整音量
                gameBGM.play().then(() => {
                    console.log('🎵 背景音樂開始播放（音量：' + (musicVolume * 100) + '%）');
                }).catch(e => {
                    console.log('🚫 背景音樂播放失敗:', e);
                });
            }
        }
        
        function stopGameBGM() {
            if (gameBGM) {
                gameBGM.pause();
                gameBGM.currentTime = 0;
                console.log('🎵 背景音樂已停止');
            }
        }
        
        function fadeOutGameBGM(callback) {
            if (!gameBGM || gameBGM.paused) {
                if (callback) callback();
                return;
            }
            
            // 清除任何現有的淡出效果
            if (fadeInterval) {
                clearInterval(fadeInterval);
            }
            
            const startVolume = gameBGM.volume;
            const fadeStep = startVolume / (fadeOutDuration / 50); // 每50ms減少的音量
            
            console.log('🎵 開始音樂淡出效果');
            
            fadeInterval = setInterval(() => {
                if (gameBGM.volume > fadeStep) {
                    gameBGM.volume -= fadeStep;
                } else {
                    gameBGM.volume = 0;
                    gameBGM.pause();
                    clearInterval(fadeInterval);
                    fadeInterval = null;
                    console.log('🎵 音樂淡出完成');
                    if (callback) callback();
                }
            }, 50);
        }
        
        // 開始遊戲函數
        function startGame() {
            document.getElementById('introModal').style.display = 'none';
            gameState = 'playing';
            
            // 初始化並播放背景音樂
            initGameBGM();
            setTimeout(() => {
                playGameBGM();
            }, 100); // 稍微延遲以確保音頻初始化完成
        }
        
        function update() {
            if (gameState !== 'playing' && gameState !== 'intro') return;
            updatePlayer();
            updateCamera();
            checkCollisions();
            springManager.checkTriggerCollisions(player);
            updateFallingPlatforms();
            updateLaboratory();
            cloudManager.update();
            cloudManager2.update();
            // 檢查主角是否走到house-3來觸發cloud動畫
            const house3 = world.roads.find(road => road.type === 'house-3');
            if (house3) {
                cloudManager.checkTrigger(player, house3.x, house3.width);
            }
            // 檢查主角是否走到house-7來觸發cloud2動畫
            const house7 = world.roads.find(road => road.type === 'house-7');
            if (house7) {
                cloudManager2.checkTrigger(player, house7.x, house7.width);
            }
            // 更新閃電系統
            lightningManager.update(cloudManager.clouds, GAME_HEIGHT);
            lightningManager2.update(cloudManager2.clouds, GAME_HEIGHT);
            // 心臟狀態現在由 HeartManager 內部管理
            // 檢查閃電碰撞
            if (lightningManager.checkCollisions(player)) {
                takeDamage(1); // 閃電造成1點傷害
                // 讓主角閃爍兩下
                player.alpha = 0.0;
                setTimeout(() => {
                    player.alpha = 1;
                }, 200);
                setTimeout(() => {
                    player.alpha = 0.0;
                }, 400);
                setTimeout(() => {
                    player.alpha = 1;
                }, 600);
            }
            // 檢查閃電2碰撞
            if (lightningManager2.checkCollisions(player)) {
                takeDamage(1); // 閃電2造成1點傷害
                // 讓主角閃爍兩下
                player.alpha = 0.0;
                setTimeout(() => {
                    player.alpha = 1;
                }, 200);
                setTimeout(() => {
                    player.alpha = 0.0;
                }, 400);
                setTimeout(() => {
                    player.alpha = 1;
                }, 600);
            }
            checkEndpoint();
        }
        
        function updatePlayer() {
            const wasMoving = Math.abs(player.velocityX) > 0.1;
            

            
            // 如果主角控制被禁用，停止移動和跑步音效
            if (player.controlDisabled) {
                player.velocityX *= 0.9; // 逐漸停止
                stopRunningAudio(); // 停止跑步音效
                return;
            }
            
            if (keys['ArrowLeft']) {
                player.velocityX = -3;
                player.facingRight = false;
            } else if (keys['ArrowRight']) {
                player.velocityX = 3;
                player.facingRight = true;
            } else {
                player.velocityX *= 0.9;
            }
            
            if (keys['Space'] && player.onGround) {
                player.velocityY = -8;
                player.onGround = false;
                // 開始跳躍狀態追蹤
                jumpState = 'preparing';
                jumpStartTime = Date.now();
            }
            
            // 更新跳躍狀態
            updateJumpState();
            
            // 更新動畫狀態
            const isMoving = Math.abs(player.velocityX) > 0.1;
            const isJumping = !player.onGround; // 角色不在地面上就是跳躍狀態
            
            let newAnimation;
            if (isJumping) {
                if (jumpState === 'preparing') {
                    newAnimation = 'jumpPrepare';
                } else {
                    newAnimation = 'jumping';
                }
            } else if (isMoving) {
                newAnimation = 'running';
            } else {
                newAnimation = 'idle';
            }
            
            // 如果動畫狀態改變，重置動畫幀索引和時間
            if (newAnimation !== currentAnimation) {
                // 檢查是否切換到 jumpPrepare（顯示 jump-1 時播放音效）
                if (newAnimation === 'jumpPrepare') {
                    playJumpAudio();
                }
                
                // 檢查是否切換到跑步狀態
                if (newAnimation === 'running') {
                    startRunningAudio();
                } else {
                    // 如果切換到其他狀態，停止跑步音效
                    stopRunningAudio();
                }
                
                currentAnimation = newAnimation;
                animationFrame = 0; // 重置到第一幀
                lastFrameTime = Date.now(); // 重置時間，避免時間混亂
            }
            
            player.velocityY += world.gravity;
            player.x += player.velocityX;
            player.y += player.velocityY;
            
            if (player.x < 0) player.x = 0;
            if (player.x > world.width - player.width) player.x = world.width - player.width;
            if (player.y > world.height) takeDamage(100);
            
            // 更新動畫幀
            updateAnimation();
        }

        // 更新跳躍狀態
        function updateJumpState() {
            if (jumpState === 'preparing') {
                const currentTime = Date.now();
                if (currentTime - jumpStartTime > jumpPrepareTime) {
                    jumpState = 'jumping';
                }
            } else if (jumpState === 'jumping' && player.onGround) {
                jumpState = 'none';
            }
        }
        
        function updateAnimation() {
            const currentTime = Date.now();
            
            // 跳躍動畫不需要更新幀，使用單一圖片
            if (currentAnimation === 'jumping' || currentAnimation === 'jumpPrepare') {
                return;
            }
            
            // 根據動畫類型選擇不同的間隔時間
            const currentInterval = currentAnimation === 'running' ? runningFrameInterval : idleFrameInterval;
            
            if (currentTime - lastFrameTime > currentInterval) {
                const animFrames = characterSprites[currentAnimation];
                if (animFrames && animFrames.length > 0) {
                    // 確保動畫幀索引在有效範圍內
                    if (animationFrame >= animFrames.length) {
                        animationFrame = 0;
                    }
                    
                    const previousFrame = animationFrame;
                    animationFrame = (animationFrame + 1) % animFrames.length;
                    
                    // 調試：僅顯示動畫循環重啟
                    if (currentAnimation === 'running' && previousFrame === 3 && animationFrame === 0) {
                        console.log(`🔄 跑步動畫循環重啟: character-run-4 → character-run-1 (${runningFrameInterval}ms間隔)`);
                    } else if (currentAnimation === 'idle' && previousFrame === 1 && animationFrame === 0) {
                        console.log(`🔄 站立動畫循環重啟: character-idle-2 → character-idle-1 (${idleFrameInterval}ms間隔)`);
                    }
                } else {
                    // 如果沒有動畫，重置動畫幀
                    animationFrame = 0;
                    console.log(`⚠️ 沒有找到 ${currentAnimation} 動畫幀，重置為0`);
                }
                lastFrameTime = currentTime;
            }
        }
        
        function updateCamera() {
            // 使用Math.floor確保攝影機位置為整數，避免閃爍
            camera.x = Math.floor(player.x - GAME_WIDTH / 2);
            camera.y = Math.floor(player.y - GAME_HEIGHT / 2);
            
            if (camera.x < 0) camera.x = 0;
            if (camera.x > world.width - GAME_WIDTH) camera.x = Math.max(0, world.width - GAME_WIDTH);
            if (camera.y < 0) camera.y = 0;
            if (camera.y > world.height - GAME_HEIGHT) camera.y = world.height - GAME_HEIGHT;
        }
        

        

        
        function checkCollisions() {
            player.onGround = false;
            
            // 檢查與路面的碰撞
            world.roads.forEach(road => {
                            // road-kanban、house-1、house-2、house-3、house-4、house-5、house-6、house-7、house-8 作為背景，不參與碰撞檢測
            if (road.type === 'road-kanban' || road.type === 'house-1' || road.type === 'house-2' || road.type === 'house-3' || road.type === 'house-4' || road.type === 'house-5' || road.type === 'house-6' || road.type === 'house-7' || road.type === 'house-8') {
                    return; // 跳過背景元素的碰撞檢測
                }
                
                if (player.x < road.x + road.width &&
                    player.x + player.width > road.x &&
                    player.y < road.y + road.height &&
                    player.y + player.height > road.y) {
                    
                    if (player.velocityY > 0 && player.y < road.y) {
                        player.y = road.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                        
                        // 如果是road-short-1或road-short-2，觸發掉落
                        if ((road.type === 'road-short-1' || road.type === 'road-short-2') && !road.isFalling) {
                            road.isFalling = true;
                            road.fallStartTime = Date.now();
                            console.log(`⚠️ 玩家踩到 ${road.id}，開始掉落！`);
                        }
                    }
                }
            });
            
            // 使用HP Logo管理器檢查碰撞
            const newlyCollected = hpLogoManager.checkCollisions(player);
            if (newlyCollected > 0) {
                            console.log('💊 HP Logo被收集！');
                updateUI();
            }
            
            // 使用Spring模組檢查障礙物碰撞
            springManager.checkObstacleCollisions(player);
        }


        
        function updateFallingPlatforms() {
            const currentTime = Date.now();
            
            world.roads.forEach(road => {
                if ((road.type === 'road-short-1' || road.type === 'road-short-2') && road.isFalling) {
                    const fallProgress = (currentTime - road.fallStartTime) / road.fallDuration;
                    
                    if (fallProgress >= 1) {
                        // 掉落完成，移除平台
                        const index = world.roads.indexOf(road);
                        if (index > -1) {
                            world.roads.splice(index, 1);
                            console.log(`💥 ${road.id} 掉落完成，已移除`);
                        }
                    } else {
                        // 正在掉落，更新Y位置
                        const fallDistance = 200; // 掉落距離
                        road.y = road.originalY + (fallDistance * fallProgress);
                    }
                }
            });
        }

        function updateLaboratory() {
            const currentTime = Date.now();
            
            world.roads.forEach(road => {
                if (road.type === 'laboratory-1' && !road.isTransformed) {
                    // 檢查主角是否走到laboratory-1的寬度1/5位置
                    const triggerX = road.x + (road.width * 0.2); // 1/5 = 0.2
                    
                    if (player.x >= triggerX) {
                        // 檢查是否收集了足夠的光球（至少35顆）
                        console.log(`🎯 主角到達 Laboratory-1 觸發點！位置: ${player.x.toFixed(2)} >= ${triggerX.toFixed(2)}`);
                        
                        if (typeof heartManager !== 'undefined' && heartManager.canWin()) {
                            road.isTransformed = true;
                            road.transformStartTime = currentTime;
                            road.type = 'laboratory-2';
                            player.controlDisabled = true; // 禁用主角控制
                            endingState.victoryTriggered = true; // 標記勝利已觸發
                            console.log('🏥 Laboratory-1轉換為Laboratory-2！觸發勝利狀態');
                            
                            // 初始化結局影片（提前準備）
                            if (!endingVideo) {
                                initEndingVideo();
                            }
                            
                            // 播放結束音效
                            playEndAudio();
                            
                            // 顯示通關提示
                            setTimeout(() => {
                                showVictoryModal();
                            }, 1000); // 延遲1秒顯示，讓音效先播放
                        } else {
                            // 光球數量不足，阻止進入
                            player.x = triggerX - 1; // 阻止進入
                            const orbsNeeded = 35 - (heartManager ? heartManager.collectedOrbs : 0);
                            console.log(`❌ 光球數量不足！還需要收集 ${orbsNeeded} 顆光球才能過關`);
                        }
                    }
                } else if (road.type === 'laboratory-2' && road.isTransformed) {
                    const transformProgress = (currentTime - road.transformStartTime) / road.transformDuration;
                    
                    if (transformProgress >= 1) {
                        // 轉換完成，開始畫面變黑
                        console.log('🎉 遊戲勝利！主角成功進入實驗室！');
                        gameState = 'victory';
                        startVictorySequence();
                    } else {
                        // 正在轉換，主角透明度逐漸降低
                        const alpha = 1 - transformProgress;
                        player.alpha = alpha;
                    }
                }
            });
        }

        function startVictorySequence() {
            // 開始勝利序列
            victoryStartTime = Date.now();
            victoryDuration = 2000; // 2秒變黑時間
            console.log('🎬 開始勝利序列：畫面變黑');
            
            // 不在此處停止音樂，保持音樂播放直到用戶點擊 pass-btn
            // fadeOutGameBGM(); // 已移除：音樂會在點擊 pass-btn 時才停止
        }

        function checkEndpoint() {
            // 檢查主角是否到達遊戲終點
            if (world.endpoint && player.x >= world.endpoint) {
                console.log('🎯 主角到達遊戲終點！');
                // 主角不能繼續往右走
                player.x = world.endpoint;
            }
        }
        
        function takeDamage(amount) {
            // 如果是雷擊傷害（amount = 1），使用愛心系統
            if (amount === 1 && typeof heartManager !== 'undefined') {
                const gameOver = heartManager.loseHeart();
                if (gameOver) {
                    // 顯示失敗畫面
                    showFailureScreen();
                }
            } else {
                // 其他傷害保持原邏輯（如掉落傷害）
                player.health -= amount;
                if (player.health <= 0) {
                    player.health = 0;
                    // 顯示失敗畫面
                    showFailureScreen();
                }
            }
            updateUI();
        }
        
        function useHealthPotion() {
            // UI元素已移除，此函數保留以備將來使用
        }
        
        function useShield() {
            // UI元素已移除，此函數保留以備將來使用
        }
        
        function updateUI() {
            // UI元素已移除，此函數保留以備將來使用
        }
        
        function endGame(success) {
            // 停止遊戲循環
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            gameState = 'ended';
            
            // 停止跑步音效（無論成功或失敗）
            stopRunningAudio();
            
            if (success) {
                // 音樂淡出效果
                fadeOutGameBGM(() => {
                    // 淡出完成後顯示結束畫面
                    const modal = document.getElementById('endingModal');
                    const title = document.getElementById('endingTitle');
                    const text = document.getElementById('endingText');
                    
                    title.textContent = '🎉 任務成功！';
                    text.innerHTML = `恭喜你成功逃出了危險！<br><br>你發現的秘密將改變整個世界...<br><br>在你的努力下，人類終於找到了<br>突破科技極限的關鍵。<br><br>新的時代即將來臨！`;
                    
                    modal.style.display = 'flex';
                });
            }
            // 移除失敗畫面處理，為客製化做準備
        }
        
        function restartGame() {
            // 停止遊戲循環
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            gameState = 'intro';
            // 故事相關變數重置已移除
            
            // 動態計算角色大小
            const playerSize = calculatePlayerSize();
            
            // 完全重置玩家狀態
            player = {
                x: 100, y: Math.floor(GAME_HEIGHT * 0.5), 
                width: playerSize.width, height: playerSize.height,
                velocityX: 0, velocityY: 0, onGround: false,
                health: 100, maxHealth: 100,
                shieldActive: false, shieldHits: 0,
                facingRight: true,
                alpha: 1,
                controlDisabled: false
            };
            
            // 重置動畫狀態
            currentAnimation = 'idle';
            animationFrame = 0;
            lastFrameTime = Date.now();
            
            // 重置勝利序列
            victoryStartTime = null;
            
            // 重置跳躍狀態
            jumpState = 'none';
            jumpStartTime = 0;
            
            // 重置攝影機
            camera = { x: 0, y: 0 };
            
            // 先重置所有管理器狀態
            springManager.reset();
            cloudManager.reset();
            cloudManager2.reset();
            lightningManager.reset();
            lightningManager2.reset();
            heartManager.reset();
            hpLogoManager.reset();
            
            // 重置世界（這會重新創建雲朵）
            createWorld();
            
            // 重置庫存
            inventory = { healthPotions: 2, shields: 1 };
            
            // 重置road-short-1和road-short-2掉落狀態
            world.roads.forEach(road => {
                if (road.type === 'road-short-1' || road.type === 'road-short-2') {
                    road.isFalling = false;
                    road.fallStartTime = 0;
                    road.y = road.originalY;
                }
            });
            
            // 清除所有按鍵狀態
            keys = {};
            
            updateUI();
            
            // 停止背景音樂
            stopGameBGM();
            // 清除淡出效果
            if (fadeInterval) {
                clearInterval(fadeInterval);
                fadeInterval = null;
            }
            
            document.getElementById('endingModal').style.display = 'none';
            document.getElementById('failureModal').style.display = 'none';
            document.getElementById('introModal').style.display = 'flex';
        }
        
        // 直接重置遊戲（不回到前言）
        function directRestartGame() {
            // 停止遊戲循環
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            gameState = 'playing'; // 直接進入遊戲狀態
            
            // 重置結局狀態
            endingState.victoryTriggered = false;
            endingState.videoPlayed = false;
            
            // 動態計算角色大小
            const playerSize = calculatePlayerSize();
            
            // 完全重置玩家狀態
            player = {
                x: 100, y: Math.floor(GAME_HEIGHT * 0.5), 
                width: playerSize.width, height: playerSize.height,
                velocityX: 0, velocityY: 0, onGround: false,
                health: 100, maxHealth: 100,
                shieldActive: false, shieldHits: 0,
                facingRight: true,
                alpha: 1,
                controlDisabled: false
            };
            
            // 重置動畫狀態
            currentAnimation = 'idle';
            animationFrame = 0;
            lastFrameTime = Date.now();
            
            // 重置勝利序列
            victoryStartTime = null;
            
            // 重置跳躍狀態
            jumpState = 'none';
            jumpStartTime = 0;
            
            // 重置攝影機
            camera = { x: 0, y: 0 };
            
            // 先重置所有管理器狀態
            springManager.reset();
            cloudManager.reset();
            cloudManager2.reset();
            lightningManager.reset();
            lightningManager2.reset();
            heartManager.reset();
            hpLogoManager.reset();
            
            // 重置世界（這會重新創建雲朵）
            createWorld();
            
            // 重置庫存
            inventory = { healthPotions: 2, shields: 1 };
            
            // 重置road-short-1和road-short-2掉落狀態
            world.roads.forEach(road => {
                if (road.type === 'road-short-1' || road.type === 'road-short-2') {
                    road.isFalling = false;
                    road.fallStartTime = 0;
                    road.y = road.originalY;
                }
            });
            
            // 清除所有按鍵狀態
            keys = {};
            
            updateUI();
            
            // 停止當前背景音樂並清除淡出效果
            stopGameBGM();
            if (fadeInterval) {
                clearInterval(fadeInterval);
                fadeInterval = null;
            }
            
            // 關閉所有模態框和結局元素
            document.getElementById('endingModal').style.display = 'none';
            document.getElementById('failureModal').style.display = 'none';
            document.getElementById('introModal').style.display = 'none';
            
            // 關閉結局相關元素
            if (endingVideo) {
                endingVideo.style.display = 'none';
            }
            if (endingGifContainer) {
                endingGifContainer.style.display = 'none';
            }
            
            // 停止結局相關音效和動畫
            stopBornAudio();
            stopGifAnimation();
            
            // 重新初始化並播放背景音樂
            initGameBGM();
            setTimeout(() => {
                playGameBGM();
            }, 100);
            
            // 重新開始遊戲循環
            gameLoop();
            
            console.log('🔄 遊戲直接重置完成，從起點開始新遊戲');
        }
        
        function render() {
            if (gameState === 'intro') {
                // 在 intro 狀態下只繪製黑色背景
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                return;
            }
            
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            drawBackground();
            drawRoads();
            hpLogoManager.draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT);
            springManager.draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT);
            cloudManager.draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT);
            cloudManager2.draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT);
            lightningManager.draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT);
            lightningManager2.draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT);
            // 繪製心臟系統
            heartManager.draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT);
            // drawEndpoint(); // 已刪除 lab 藍色框框
            drawPlayer();
            
            // 如果處於勝利狀態，繪製變黑效果
            if (gameState === 'victory' && victoryStartTime) {
                const currentTime = Date.now();
                const elapsed = currentTime - victoryStartTime;
                const progress = Math.min(elapsed / victoryDuration, 1);
                
                // 繪製漸變黑色遮罩
                ctx.fillStyle = `rgba(0, 0, 0, ${progress})`;
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                
                // 如果變黑完成，可以準備顯示勝利動畫
                if (progress >= 1) {
                    console.log('🎬 畫面變黑完成，準備顯示勝利動畫');
                    // 這裡可以加入勝利動畫的邏輯
                }
            }
        }
        
        function drawBackground() {
            if (backgroundLoaded && backgroundImage) {
                // 計算背景圖片的縮放比例，讓圖片高度填滿畫面
                const scale = GAME_HEIGHT / backgroundHeight;
                const scaledWidth = Math.floor(backgroundWidth * scale);
                const scaledHeight = GAME_HEIGHT;
                
                // 計算背景的滾動位置（視差效果）
                const parallaxSpeed = 0.3; // 背景滾動速度（相對於攝影機速度）
                const backgroundOffsetX = Math.floor(camera.x * parallaxSpeed) % scaledWidth;
                
                // 計算需要繪製的背景圖片數量，確保完整覆蓋
                const startTile = Math.floor(-backgroundOffsetX / scaledWidth) - 1;
                const endTile = Math.ceil((GAME_WIDTH - backgroundOffsetX) / scaledWidth) + 1;
                
                // 繪製背景圖片以實現無限滾動，確保整數位置
                for (let i = startTile; i <= endTile; i++) {
                    const x = Math.floor(i * scaledWidth - backgroundOffsetX);
                    // 確保繪製尺寸也是整數
                    ctx.drawImage(backgroundImage, x, 0, Math.floor(scaledWidth), Math.floor(scaledHeight));
                }
            } else {
                // 如果背景圖片載入失敗，使用原來的星空背景
                ctx.fillStyle = '#ffffff';
                for (let i = 0; i < 100; i++) {
                    const x = (i * 137) % world.width - camera.x;
                    const y = (i * 73) % world.height - camera.y;
                    if (x >= -10 && x <= GAME_WIDTH + 10 && y >= -10 && y <= GAME_HEIGHT + 10) {
                        ctx.fillRect(x, y, 2, 2);
                    }
                }
            }
        }
        
        // 路面圖片載入
        let roadImages = {};
        let roadOriginalSizes = {}; // 儲存原始尺寸
        let roadsLoaded = false;

        // HP Logo 系統
        // HP Logo系統已移至HpLogoManager模組
        let hpLogos = []; // 向後兼容
        // collectedHpCount變數已移除，因為UI元素已移除

        // Spring 彈簧系統
        let springs = [];
        let springImages = {}; // 存储spring-1到spring-4的图片
        let springsLoaded = false;

        // ===============================
        // Lightning 閃電模組
        // ===============================
        // Lightning 閃電模組 (House-3)
        // ===============================
        class LightningManager {
            constructor() {
                this.lightnings = [];
                this.imagesLoaded = false;
                this.images = {};
                this.isActive = false;
                this.lastLightningTime = 0;
                this.lightningInterval = 300; // 0.8秒產生一次閃電
                this.lightningDuration = 2000; // 2秒閃電持續時間
                this.maxLightnings = 10; // 最多同時存在5個閃電
                this.cloudLastLightningTime = {}; // 記錄每個cloud最後產生閃電的時間
                this.cloudLightningInterval = 800; // 每個cloud 1.2秒才能產生一次閃電
                this.playerLastHitTime = 0; // 記錄主角最後被擊中的時間
                this.playerHitCooldown = 1000; // 主角被擊中後1秒內不會再次受傷
            }

            // 載入Lightning圖片
            loadImages() {
                const lightningTypes = ['lightning'];
                let loadedCount = 0;

                lightningTypes.forEach(type => {
                    const img = new Image();
                    img.onload = () => {
                        this.images[type] = img;
                        loadedCount++;
                        if (loadedCount === lightningTypes.length) {
                            this.imagesLoaded = true;
                            console.log('⚡ Lightning圖片載入完成');
                        }
                    };
                    img.onerror = () => {
                        console.log(`❌ Lightning圖片載入失敗: ${type}`);
                        loadedCount++;
                        if (loadedCount === lightningTypes.length) {
                            this.imagesLoaded = true;
                        }
                    };
                    img.src = `Vibe Coding 組_SylviaSYLin遊戲介面/assets/${type}.svg`;
                });
            }

            // 啟動閃電系統
            startLightning() {
                this.isActive = true;
                this.lastLightningTime = Date.now();
                console.log('⚡ Lightning系統啟動！');
            }

            // 更新閃電
            update(clouds, GAME_HEIGHT) {
                if (!this.isActive || !clouds || clouds.length === 0) return;

                const currentTime = Date.now();

                // 檢查是否有cloud在動畫中
                const activeClouds = clouds.filter(cloud => cloud.isAnimating);
                if (activeClouds.length === 0) return;

                // 連續性產生閃電（不限制cloud間隔，但限制總數量）
                if (this.lightnings.length < this.maxLightnings) {
                    // 隨機選擇一個動畫中的cloud
                    const randomCloud = activeClouds[Math.floor(Math.random() * activeClouds.length)];
                    
                    // 添加一些隨機性，讓閃電產生更自然
                    const randomDelay = Math.random() * 500; // 0-500ms的隨機延遲
                    if (currentTime - this.lastLightningTime > this.lightningInterval + randomDelay) {
                        this.createLightning(randomCloud, GAME_HEIGHT);
                        this.lastLightningTime = currentTime;
                    }
                }

                // 更新現有閃電
                this.lightnings.forEach((lightning, index) => {
                    const elapsed = currentTime - lightning.startTime;
                    const progress = elapsed / this.lightningDuration;

                    if (progress >= 1) {
                        // 閃電結束，移除
                        this.lightnings.splice(index, 1);
                    } else {
                        // 更新閃電位置（從cloud往下落）
                        const fallDistance = GAME_HEIGHT; // 掉落距離為整個遊戲高度
                        lightning.y = lightning.cloudY + (fallDistance * progress);
                    }
                });
            }

            // 創建閃電
            createLightning(cloud, GAME_HEIGHT) {
                // 計算lightning尺寸
                const lightningHeightRatio = 24 / 512; // 24像素高度在512背景中的比例 (4.69%)
                const lightningHeight = Math.floor(GAME_HEIGHT * lightningHeightRatio);
                
                let lightningWidth;
                if (roadOriginalSizes['lightning']) {
                    const originalSize = roadOriginalSizes['lightning'];
                    const originalRatio = originalSize.width / originalSize.height;
                    lightningWidth = Math.floor(lightningHeight * originalRatio);
                } else if (this.images['lightning'] && this.images['lightning'].complete) {
                    const ratio = this.images['lightning'].naturalWidth / this.images['lightning'].naturalHeight;
                    lightningWidth = Math.floor(lightningHeight * ratio);
                } else {
                    lightningWidth = lightningHeight; // 預設為正方形
                }

                // 在cloud範圍內隨機位置
                const minX = cloud.x;
                const maxX = cloud.x + cloud.width - lightningWidth;
                const lightningX = minX + Math.random() * (maxX - minX);

                const lightning = {
                    x: lightningX,
                    y: cloud.y + cloud.height, // 從cloud底部開始
                    width: lightningWidth,
                    height: lightningHeight,
                    cloudY: cloud.y + cloud.height, // 記錄cloud底部位置
                    startTime: Date.now(),
                    type: 'lightning'
                };

                this.lightnings.push(lightning);
                console.log('⚡ 新閃電產生！位置:', { x: lightningX, y: lightning.y, cloud: cloud.type });
            }

            // 檢查與主角的碰撞
            checkCollisions(player) {
                if (!this.isActive) return false;

                const currentTime = Date.now();
                
                // 檢查是否在冷卻期內
                if (currentTime - this.playerLastHitTime < this.playerHitCooldown) {
                    return false;
                }

                let hit = false;
                this.lightnings.forEach(lightning => {
                    if (player.x < lightning.x + lightning.width &&
                        player.x + player.width > lightning.x &&
                        player.y < lightning.y + lightning.height &&
                        player.y + player.height > lightning.y) {
                        
                        hit = true;
                        this.playerLastHitTime = currentTime; // 記錄被擊中時間
                        console.log('⚡ 主角被閃電擊中！HP:', player.health);
                    }
                });

                return hit;
            }

            // 繪製閃電
            draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT) {
                if (!this.isActive) return;

                this.lightnings.forEach(lightning => {
                    const x = Math.floor(lightning.x - camera.x);
                    const y = Math.floor(lightning.y - camera.y);
                    
                    // 檢查是否在畫面內
                    if (x + lightning.width >= 0 && x <= GAME_WIDTH &&
                        y + lightning.height >= 0 && y <= GAME_HEIGHT) {
                        
                        if (this.imagesLoaded && this.images['lightning']) {
                            ctx.save();
                            ctx.imageSmoothingEnabled = false;
                            ctx.drawImage(this.images['lightning'], x, y, lightning.width, lightning.height);
                            ctx.restore();
                        } else {
                            // 如果圖片未載入，繪製預設的閃電形狀
                            ctx.fillStyle = '#FFFF00';
                            ctx.fillRect(x, y, lightning.width, lightning.height);
                        }
                    }
                });
            }

            // 重置
            reset() {
                this.lightnings = [];
                this.isActive = false;
                this.lastLightningTime = 0;
                this.cloudLastLightningTime = {};
                this.playerLastHitTime = 0;
            }
        }

        // ===============================
        // Lightning 閃電模組 (House-7)
        // ===============================
        class LightningManager2 {
            constructor() {
                this.lightnings = [];
                this.imagesLoaded = false;
                this.images = {};
                this.isActive = false;
                this.lastLightningTime = 0;
                this.lightningInterval = 300; // 0.3秒產生一次閃電
                this.lightningDuration = 2000; // 2秒閃電持續時間
                this.maxLightnings = 10; // 最多同時存在10個閃電
                this.cloudLastLightningTime = {}; // 記錄每個cloud最後產生閃電的時間
                this.cloudLightningInterval = 800; // 每個cloud 0.8秒才能產生一次閃電
                this.playerLastHitTime = 0; // 記錄主角最後被擊中的時間
                this.playerHitCooldown = 1000; // 主角被擊中後1秒內不會再次受傷
            }

            // 載入Lightning圖片
            loadImages() {
                const lightningTypes = ['lightning'];
                let loadedCount = 0;

                lightningTypes.forEach(type => {
                    const img = new Image();
                    img.onload = () => {
                        this.images[type] = img;
                        loadedCount++;
                        if (loadedCount === lightningTypes.length) {
                            this.imagesLoaded = true;
                            console.log('⚡ Lightning2圖片載入完成');
                        }
                    };
                    img.onerror = () => {
                        console.log(`❌ Lightning2圖片載入失敗: ${type}`);
                        loadedCount++;
                        if (loadedCount === lightningTypes.length) {
                            this.imagesLoaded = true;
                        }
                    };
                    img.src = `Vibe Coding 組_SylviaSYLin遊戲介面/assets/${type}.svg`;
                });
            }

            // 啟動閃電系統
            startLightning() {
                this.isActive = true;
                this.lastLightningTime = Date.now();
                console.log('⚡ Lightning2系統啟動！');
            }

            // 更新閃電
            update(clouds, GAME_HEIGHT) {
                if (!this.isActive || !clouds || clouds.length === 0) return;

                const currentTime = Date.now();

                // 檢查是否有cloud在動畫中
                const activeClouds = clouds.filter(cloud => cloud.isAnimating);
                if (activeClouds.length === 0) return;

                // 連續性產生閃電（不限制cloud間隔，但限制總數量）
                if (this.lightnings.length < this.maxLightnings) {
                    // 隨機選擇一個動畫中的cloud
                    const randomCloud = activeClouds[Math.floor(Math.random() * activeClouds.length)];
                    
                    // 添加一些隨機性，讓閃電產生更自然
                    const randomDelay = Math.random() * 500; // 0-500ms的隨機延遲
                    if (currentTime - this.lastLightningTime > this.lightningInterval + randomDelay) {
                        this.createLightning(randomCloud, GAME_HEIGHT);
                        this.lastLightningTime = currentTime;
                    }
                }

                // 更新現有閃電
                this.lightnings.forEach((lightning, index) => {
                    const elapsed = currentTime - lightning.startTime;
                    const progress = elapsed / this.lightningDuration;

                    if (progress >= 1) {
                        // 閃電結束，移除
                        this.lightnings.splice(index, 1);
                    } else {
                        // 更新閃電位置（從cloud往下落）
                        const fallDistance = GAME_HEIGHT; // 掉落距離為整個遊戲高度
                        lightning.y = lightning.cloudY + (fallDistance * progress);
                    }
                });
            }

            // 創建閃電
            createLightning(cloud, GAME_HEIGHT) {
                // 計算lightning尺寸
                const lightningHeightRatio = 24 / 512; // 24像素高度在512背景中的比例 (4.69%)
                const lightningHeight = Math.floor(GAME_HEIGHT * lightningHeightRatio);
                
                let lightningWidth;
                if (roadOriginalSizes['lightning']) {
                    const originalSize = roadOriginalSizes['lightning'];
                    const originalRatio = originalSize.width / originalSize.height;
                    lightningWidth = Math.floor(lightningHeight * originalRatio);
                } else if (this.images['lightning'] && this.images['lightning'].complete) {
                    const ratio = this.images['lightning'].naturalWidth / this.images['lightning'].naturalHeight;
                    lightningWidth = Math.floor(lightningHeight * ratio);
                } else {
                    lightningWidth = lightningHeight; // 預設為正方形
                }

                // 在cloud範圍內隨機位置
                const minX = cloud.x;
                const maxX = cloud.x + cloud.width - lightningWidth;
                const lightningX = minX + Math.random() * (maxX - minX);

                const lightning = {
                    x: lightningX,
                    y: cloud.y + cloud.height, // 從cloud底部開始
                    width: lightningWidth,
                    height: lightningHeight,
                    cloudY: cloud.y + cloud.height, // 記錄cloud底部位置
                    startTime: Date.now(),
                    type: 'lightning'
                };

                this.lightnings.push(lightning);
                console.log('⚡ 新閃電2產生！位置:', { x: lightningX, y: lightning.y, cloud: cloud.type });
            }

            // 檢查與主角的碰撞
            checkCollisions(player) {
                if (!this.isActive) return false;

                const currentTime = Date.now();
                
                // 檢查是否在冷卻期內
                if (currentTime - this.playerLastHitTime < this.playerHitCooldown) {
                    return false;
                }

                let hit = false;
                this.lightnings.forEach(lightning => {
                    if (player.x < lightning.x + lightning.width &&
                        player.x + player.width > lightning.x &&
                        player.y < lightning.y + lightning.height &&
                        player.y + player.height > lightning.y) {
                        
                        hit = true;
                        this.playerLastHitTime = currentTime; // 記錄被擊中時間
                        console.log('⚡ 主角被閃電2擊中！HP:', player.health);
                    }
                });

                return hit;
            }

            // 繪製閃電
            draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT) {
                if (!this.isActive) return;

                this.lightnings.forEach(lightning => {
                    const x = Math.floor(lightning.x - camera.x);
                    const y = Math.floor(lightning.y - camera.y);
                    
                    // 檢查是否在畫面內
                    if (x + lightning.width >= 0 && x <= GAME_WIDTH &&
                        y + lightning.height >= 0 && y <= GAME_HEIGHT) {
                        
                        if (this.imagesLoaded && this.images['lightning']) {
                            ctx.save();
                            ctx.imageSmoothingEnabled = false;
                            ctx.drawImage(this.images['lightning'], x, y, lightning.width, lightning.height);
                            ctx.restore();
                        } else {
                            // 如果圖片未載入，繪製預設的閃電形狀
                            ctx.fillStyle = '#FFFF00';
                            ctx.fillRect(x, y, lightning.width, lightning.height);
                        }
                    }
                });
            }

            // 重置
            reset() {
                this.lightnings = [];
                this.isActive = false;
                this.lastLightningTime = 0;
                this.cloudLastLightningTime = {};
                this.playerLastHitTime = 0;
            }
        }

        // ===============================
        // Cloud 雲朵模組 (House-3)
        // ===============================
        class CloudManager {
            constructor() {
                this.clouds = [];
                this.imagesLoaded = false;
                this.images = {};
                this.animationStarted = false;
                this.startTime = null;
                this.cloud1StartTime = null;
                this.cloud2StartTime = null;
                this.cloud3StartTime = null;
                this.animationDuration = 1000; // 1秒滑入動畫
                this.cloudDelay = 300; // 0.3秒延遲
            }

            // 載入Cloud圖片
            loadImages() {
                const cloudTypes = ['cloud-1', 'cloud-2', 'cloud-3'];
                let loadedCount = 0;

                cloudTypes.forEach(type => {
                    const img = new Image();
                    img.onload = () => {
                        this.images[type] = img;
                        loadedCount++;
                        if (loadedCount === cloudTypes.length) {
                            this.imagesLoaded = true;
                            console.log('☁️ Cloud圖片載入完成');
                        }
                    };
                    img.onerror = () => {
                        console.log(`❌ Cloud圖片載入失敗: ${type}`);
                        loadedCount++;
                        if (loadedCount === cloudTypes.length) {
                            this.imagesLoaded = true;
                        }
                    };
                    img.src = `Vibe Coding 組_SylviaSYLin遊戲介面/assets/${type}.svg`;
                });
            }

            // 創建Cloud雲朵
            createClouds(road3X, road3Width, GAME_HEIGHT) {
                // 計算Cloud尺寸
                const cloud1HeightRatio = 96 / 512; // 96像素高度在512背景中的比例 (18.75%)
                const cloud2HeightRatio = 79 / 512; // 79像素高度在512背景中的比例 (15.43%)
                const cloud3HeightRatio = 77 / 512; // 77像素高度在512背景中的比例 (15.04%)

                const cloud1Height = Math.floor(GAME_HEIGHT * cloud1HeightRatio);
                const cloud2Height = Math.floor(GAME_HEIGHT * cloud2HeightRatio);
                const cloud3Height = Math.floor(GAME_HEIGHT * cloud3HeightRatio);

                // 計算Cloud寬度（保持原始比例）
                let cloud1Width, cloud2Width, cloud3Width;

                // 使用roadOriginalSizes來獲取原始比例
                if (roadOriginalSizes['cloud-1']) {
                    const originalSize = roadOriginalSizes['cloud-1'];
                    const originalRatio = originalSize.width / originalSize.height;
                    cloud1Width = Math.floor(cloud1Height * originalRatio);
                } else if (this.images['cloud-1'] && this.images['cloud-1'].complete) {
                    const ratio = this.images['cloud-1'].naturalWidth / this.images['cloud-1'].naturalHeight;
                    cloud1Width = Math.floor(cloud1Height * ratio);
                } else {
                    cloud1Width = cloud1Height; // 預設為正方形
                }

                if (roadOriginalSizes['cloud-2']) {
                    const originalSize = roadOriginalSizes['cloud-2'];
                    const originalRatio = originalSize.width / originalSize.height;
                    cloud2Width = Math.floor(cloud2Height * originalRatio);
                } else if (this.images['cloud-2'] && this.images['cloud-2'].complete) {
                    const ratio = this.images['cloud-2'].naturalWidth / this.images['cloud-2'].naturalHeight;
                    cloud2Width = Math.floor(cloud2Height * ratio);
                } else {
                    cloud2Width = cloud2Height; // 預設為正方形
                }

                if (roadOriginalSizes['cloud-3']) {
                    const originalSize = roadOriginalSizes['cloud-3'];
                    const originalRatio = originalSize.width / originalSize.height;
                    cloud3Width = Math.floor(cloud3Height * originalRatio);
                } else if (this.images['cloud-3'] && this.images['cloud-3'].complete) {
                    const ratio = this.images['cloud-3'].naturalWidth / this.images['cloud-3'].naturalHeight;
                    cloud3Width = Math.floor(cloud3Height * ratio);
                } else {
                    cloud3Width = cloud3Height; // 預設為正方形
                }

                // 計算Cloud位置
                const cloudLeftDistanceRatio = 8 / 512; // 8像素距離在512背景中的比例 (1.56%)
                const cloud1TopDistanceRatio = 15 / 512; // 15像素距離在512背景中的比例 (2.93%)
                const cloud2TopDistanceRatio = 19 / 512; // 19像素距離在512背景中的比例 (3.71%)
                const cloud3TopDistanceRatio = 15 / 512; // 15像素距離在512背景中的比例 (2.93%)
                const cloud2LeftDistanceRatio = 14 / 512; // 14像素距離在512背景中的比例 (2.73%)
                const cloud3LeftDistanceRatio = 48 / 512; // 48像素距離在512背景中的比例 (9.38%)

                const cloudLeftDistance = Math.floor(GAME_HEIGHT * cloudLeftDistanceRatio);
                const cloud1TopDistance = Math.floor(GAME_HEIGHT * cloud1TopDistanceRatio);
                const cloud2TopDistance = Math.floor(GAME_HEIGHT * cloud2TopDistanceRatio);
                const cloud3TopDistance = Math.floor(GAME_HEIGHT * cloud3TopDistanceRatio);
                const cloud2LeftDistance = Math.floor(GAME_HEIGHT * cloud2LeftDistanceRatio);
                const cloud3LeftDistance = Math.floor(GAME_HEIGHT * cloud3LeftDistanceRatio);

                // 計算Cloud的最終位置
                const cloud1FinalX = road3X + road3Width + cloudLeftDistance;
                const cloud1FinalY = cloud1TopDistance;
                const cloud2FinalX = cloud1FinalX + cloud1Width + cloud2LeftDistance;
                const cloud2FinalY = cloud2TopDistance;
                const cloud3FinalX = cloud2FinalX + cloud2Width + cloud3LeftDistance;
                const cloud3FinalY = cloud3TopDistance;

                // 創建Cloud物件（初始位置在畫面外）
                this.clouds = [
                    {
                        x: cloud1FinalX,
                        y: -cloud1Height, // 初始在畫面外
                        width: cloud1Width,
                        height: cloud1Height,
                        finalY: cloud1FinalY,
                        type: 'cloud-1',
                        isAnimating: false
                    },
                    {
                        x: cloud2FinalX,
                        y: -cloud2Height, // 初始在畫面外
                        width: cloud2Width,
                        height: cloud2Height,
                        finalY: cloud2FinalY,
                        type: 'cloud-2',
                        isAnimating: false
                    },
                    {
                        x: cloud3FinalX,
                        y: -cloud3Height, // 初始在畫面外
                        width: cloud3Width,
                        height: cloud3Height,
                        finalY: cloud3FinalY,
                        type: 'cloud-3',
                        isAnimating: false
                    }
                ];

                console.log('☁️ Cloud模組創建完成:', this.clouds);
            }

            // 啟動動畫
            startAnimation() {
                if (this.animationStarted) return;
                
                this.animationStarted = true;
                this.startTime = Date.now();
                this.cloud1StartTime = this.startTime;
                this.cloud2StartTime = this.startTime + this.cloudDelay;
                this.cloud3StartTime = this.startTime + (this.cloudDelay * 2);
                
                console.log('☁️ Cloud動畫啟動！');
                
                // 啟動閃電系統
                lightningManager.startLightning();
                
                // 開始播放 Cloud 音效
                startCloudAudio();
            }

            // 更新動畫
            update() {
                if (!this.animationStarted || !this.clouds || this.clouds.length === 0) return;

                const currentTime = Date.now();

                // 更新cloud-1
                if (this.clouds[0] && currentTime >= this.cloud1StartTime) {
                    this.clouds[0].isAnimating = true;
                    const elapsed = currentTime - this.cloud1StartTime;
                    const progress = Math.min(elapsed / this.animationDuration, 1);
                    
                    // ease out動畫
                    const easeOutProgress = 1 - Math.pow(1 - progress, 3);
                    this.clouds[0].y = -this.clouds[0].height + (easeOutProgress * (this.clouds[0].finalY + this.clouds[0].height));
                }

                // 更新cloud-2
                if (this.clouds[1] && currentTime >= this.cloud2StartTime) {
                    this.clouds[1].isAnimating = true;
                    const elapsed = currentTime - this.cloud2StartTime;
                    const progress = Math.min(elapsed / this.animationDuration, 1);
                    
                    const easeOutProgress = 1 - Math.pow(1 - progress, 3);
                    this.clouds[1].y = -this.clouds[1].height + (easeOutProgress * (this.clouds[1].finalY + this.clouds[1].height));
                }

                // 更新cloud-3
                if (this.clouds[2] && currentTime >= this.cloud3StartTime) {
                    this.clouds[2].isAnimating = true;
                    const elapsed = currentTime - this.cloud3StartTime;
                    const progress = Math.min(elapsed / this.animationDuration, 1);
                    
                    const easeOutProgress = 1 - Math.pow(1 - progress, 3);
                    this.clouds[2].y = -this.clouds[2].height + (easeOutProgress * (this.clouds[2].finalY + this.clouds[2].height));
                }
            }

            // 繪製Cloud
            draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT) {
                if (!this.clouds || this.clouds.length === 0) return;
                
                this.clouds.forEach(cloud => {
                    if (cloud && cloud.isAnimating) {
                        const x = Math.floor(cloud.x - camera.x);
                        const y = Math.floor(cloud.y - camera.y);
                        
                        // 檢查是否在畫面內
                        if (x + cloud.width >= 0 && x <= GAME_WIDTH &&
                            y + cloud.height >= 0 && y <= GAME_HEIGHT) {
                            
                            if (this.imagesLoaded && this.images[cloud.type]) {
                                ctx.save();
                                ctx.imageSmoothingEnabled = false;
                                ctx.drawImage(this.images[cloud.type], x, y, cloud.width, cloud.height);
                                ctx.restore();
                            } else {
                                // 如果圖片未載入，繪製預設的雲朵形狀
                                ctx.fillStyle = '#ffffff';
                                ctx.fillRect(x, y, cloud.width, cloud.height);
                            }
                        }
                    }
                });
            }

            // 停止動畫
            stopAnimation() {
                if (!this.animationStarted) return;
                
                this.animationStarted = false;
                console.log('☁️ Cloud動畫停止！');
                
                // 停止播放 Cloud 音效
                stopCloudAudio();
            }
            
            // 重置
            reset() {
                this.clouds = [];
                this.animationStarted = false;
                this.startTime = null;
                this.cloud1StartTime = null;
                this.cloud2StartTime = null;
                this.cloud3StartTime = null;
                
                // 停止播放 Cloud 音效
                stopCloudAudio();
            }

            // 檢查是否應該啟動動畫
            checkTrigger(player, house3X, house3Width) {
                // 檢查主角是否在road-short-1或road-short-2上
                const isOnShortRoad = world.roads.some(road => 
                    (road.type === 'road-short-1' || road.type === 'road-short-2') &&
                    player.x >= road.x && player.x <= road.x + road.width &&
                    player.y >= road.y && player.y <= road.y + road.height
                );
                
                if (this.animationStarted) {
                    // 檢查主角是否離開house-3範圍或進入short road
                    if (player.x < house3X || player.x > house3X + house3Width || isOnShortRoad) {
                        this.stopAnimation();
                    }
                    return;
                }
                
                // 檢查主角是否走到house-3且不在short road上
                if (player.x >= house3X && player.x <= house3X + house3Width && !isOnShortRoad) {
                    this.startAnimation();
                }
            }
        }

        // ===============================
        // Cloud 雲朵模組 (House-7)
        // ===============================
        class CloudManager2 {
            constructor() {
                this.clouds = [];
                this.imagesLoaded = false;
                this.images = {};
                this.animationStarted = false;
                this.startTime = null;
                this.cloud1StartTime = null;
                this.cloud2StartTime = null;
                this.cloud3StartTime = null;
                this.animationDuration = 1000; // 1秒滑入動畫
                this.cloudDelay = 300; // 0.3秒延遲
            }

            // 載入Cloud圖片
            loadImages() {
                const cloudTypes = ['cloud-1', 'cloud-2', 'cloud-3'];
                let loadedCount = 0;

                cloudTypes.forEach(type => {
                    const img = new Image();
                    img.onload = () => {
                        this.images[type] = img;
                        loadedCount++;
                        if (loadedCount === cloudTypes.length) {
                            this.imagesLoaded = true;
                            console.log('☁️ Cloud2圖片載入完成');
                        }
                    };
                    img.onerror = () => {
                        console.log(`❌ Cloud2圖片載入失敗: ${type}`);
                        loadedCount++;
                        if (loadedCount === cloudTypes.length) {
                            this.imagesLoaded = true;
                        }
                    };
                    img.src = `Vibe Coding 組_SylviaSYLin遊戲介面/assets/${type}.svg`;
                });
            }

            // 創建Cloud雲朵 (House-7版本)
            createClouds(house7X, house7Width, GAME_HEIGHT) {
                // 計算Cloud尺寸
                const cloud1HeightRatio = 96 / 512; // 96像素高度在512背景中的比例 (18.75%)
                const cloud2HeightRatio = 79 / 512; // 79像素高度在512背景中的比例 (15.43%)
                const cloud3HeightRatio = 77 / 512; // 77像素高度在512背景中的比例 (15.04%)

                const cloud1Height = Math.floor(GAME_HEIGHT * cloud1HeightRatio);
                const cloud2Height = Math.floor(GAME_HEIGHT * cloud2HeightRatio);
                const cloud3Height = Math.floor(GAME_HEIGHT * cloud3HeightRatio);

                // 計算Cloud寬度（保持原始比例）
                let cloud1Width, cloud2Width, cloud3Width;

                // 使用roadOriginalSizes來獲取原始比例
                if (roadOriginalSizes['cloud-1']) {
                    const originalSize = roadOriginalSizes['cloud-1'];
                    const originalRatio = originalSize.width / originalSize.height;
                    cloud1Width = Math.floor(cloud1Height * originalRatio);
                } else if (this.images['cloud-1'] && this.images['cloud-1'].complete) {
                    const ratio = this.images['cloud-1'].naturalWidth / this.images['cloud-1'].naturalHeight;
                    cloud1Width = Math.floor(cloud1Height * ratio);
                } else {
                    cloud1Width = cloud1Height; // 預設為正方形
                }

                if (roadOriginalSizes['cloud-2']) {
                    const originalSize = roadOriginalSizes['cloud-2'];
                    const originalRatio = originalSize.width / originalSize.height;
                    cloud2Width = Math.floor(cloud2Height * originalRatio);
                } else if (this.images['cloud-2'] && this.images['cloud-2'].complete) {
                    const ratio = this.images['cloud-2'].naturalWidth / this.images['cloud-2'].naturalHeight;
                    cloud2Width = Math.floor(cloud2Height * ratio);
                } else {
                    cloud2Width = cloud2Height; // 預設為正方形
                }

                if (roadOriginalSizes['cloud-3']) {
                    const originalSize = roadOriginalSizes['cloud-3'];
                    const originalRatio = originalSize.width / originalSize.height;
                    cloud3Width = Math.floor(cloud3Height * originalRatio);
                } else if (this.images['cloud-3'] && this.images['cloud-3'].complete) {
                    const ratio = this.images['cloud-3'].naturalWidth / this.images['cloud-3'].naturalHeight;
                    cloud3Width = Math.floor(cloud3Height * ratio);
                } else {
                    cloud3Width = cloud3Height; // 預設為正方形
                }

                // 計算Cloud位置 (House-7版本)
                const cloud1TopDistanceRatio = 15 / 512; // 15像素距離在512背景中的比例 (2.93%)
                const cloud2TopDistanceRatio = 19 / 512; // 19像素距離在512背景中的比例 (3.71%)
                const cloud3TopDistanceRatio = 15 / 512; // 15像素距離在512背景中的比例 (2.93%)
                const cloud2LeftDistanceRatio = 14 / 512; // 14像素距離在512背景中的比例 (2.73%)
                const cloud3LeftDistanceRatio = 48 / 512; // 48像素距離在512背景中的比例 (9.38%)

                const cloud1TopDistance = Math.floor(GAME_HEIGHT * cloud1TopDistanceRatio);
                const cloud2TopDistance = Math.floor(GAME_HEIGHT * cloud2TopDistanceRatio);
                const cloud3TopDistance = Math.floor(GAME_HEIGHT * cloud3TopDistanceRatio);
                const cloud2LeftDistance = Math.floor(GAME_HEIGHT * cloud2LeftDistanceRatio);
                const cloud3LeftDistance = Math.floor(GAME_HEIGHT * cloud3LeftDistanceRatio);

                // 計算Cloud的最終位置 (House-7版本) - 左邊貼齊house-7右邊
                const cloud1FinalX = house7X + house7Width; // cloud1左邊貼齊house-7右邊
                const cloud1FinalY = cloud1TopDistance;
                const cloud2FinalX = cloud1FinalX + cloud1Width + cloud2LeftDistance;
                const cloud2FinalY = cloud2TopDistance;
                const cloud3FinalX = cloud2FinalX + cloud2Width + cloud3LeftDistance;
                const cloud3FinalY = cloud3TopDistance;

                // 創建Cloud物件（初始位置在畫面外）
                this.clouds = [
                    {
                        x: cloud1FinalX,
                        y: -cloud1Height, // 初始在畫面外
                        width: cloud1Width,
                        height: cloud1Height,
                        finalY: cloud1FinalY,
                        type: 'cloud-1',
                        isAnimating: false
                    },
                    {
                        x: cloud2FinalX,
                        y: -cloud2Height, // 初始在畫面外
                        width: cloud2Width,
                        height: cloud2Height,
                        finalY: cloud2FinalY,
                        type: 'cloud-2',
                        isAnimating: false
                    },
                    {
                        x: cloud3FinalX,
                        y: -cloud3Height, // 初始在畫面外
                        width: cloud3Width,
                        height: cloud3Height,
                        finalY: cloud3FinalY,
                        type: 'cloud-3',
                        isAnimating: false
                    }
                ];

                console.log('☁️ Cloud2模組創建完成:', this.clouds);
            }

            // 啟動動畫
            startAnimation() {
                if (this.animationStarted) return;
                
                this.animationStarted = true;
                this.startTime = Date.now();
                this.cloud1StartTime = this.startTime;
                this.cloud2StartTime = this.startTime + this.cloudDelay;
                this.cloud3StartTime = this.startTime + (this.cloudDelay * 2);
                
                console.log('☁️ Cloud2動畫啟動！');
                
                // 啟動閃電系統
                lightningManager2.startLightning();
                
                // 開始播放 Cloud 音效
                startCloudAudio();
            }

            // 更新動畫
            update() {
                if (!this.animationStarted || !this.clouds || this.clouds.length === 0) return;

                const currentTime = Date.now();

                // 更新cloud-1
                if (this.clouds[0] && currentTime >= this.cloud1StartTime) {
                    this.clouds[0].isAnimating = true;
                    const elapsed = currentTime - this.cloud1StartTime;
                    const progress = Math.min(elapsed / this.animationDuration, 1);
                    
                    // ease out動畫
                    const easeOutProgress = 1 - Math.pow(1 - progress, 3);
                    this.clouds[0].y = -this.clouds[0].height + (easeOutProgress * (this.clouds[0].finalY + this.clouds[0].height));
                }

                // 更新cloud-2
                if (this.clouds[1] && currentTime >= this.cloud2StartTime) {
                    this.clouds[1].isAnimating = true;
                    const elapsed = currentTime - this.cloud2StartTime;
                    const progress = Math.min(elapsed / this.animationDuration, 1);
                    
                    const easeOutProgress = 1 - Math.pow(1 - progress, 3);
                    this.clouds[1].y = -this.clouds[1].height + (easeOutProgress * (this.clouds[1].finalY + this.clouds[1].height));
                }

                // 更新cloud-3
                if (this.clouds[2] && currentTime >= this.cloud3StartTime) {
                    this.clouds[2].isAnimating = true;
                    const elapsed = currentTime - this.cloud3StartTime;
                    const progress = Math.min(elapsed / this.animationDuration, 1);
                    
                    const easeOutProgress = 1 - Math.pow(1 - progress, 3);
                    this.clouds[2].y = -this.clouds[2].height + (easeOutProgress * (this.clouds[2].finalY + this.clouds[2].height));
                }
            }

            // 繪製Cloud
            draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT) {
                if (!this.clouds || this.clouds.length === 0) return;
                
                this.clouds.forEach(cloud => {
                    if (cloud && cloud.isAnimating) {
                        const x = Math.floor(cloud.x - camera.x);
                        const y = Math.floor(cloud.y - camera.y);
                        
                        // 檢查是否在畫面內
                        if (x + cloud.width >= 0 && x <= GAME_WIDTH &&
                            y + cloud.height >= 0 && y <= GAME_HEIGHT) {
                            
                            if (this.imagesLoaded && this.images[cloud.type]) {
                                ctx.save();
                                ctx.imageSmoothingEnabled = false;
                                ctx.drawImage(this.images[cloud.type], x, y, cloud.width, cloud.height);
                                ctx.restore();
                            } else {
                                // 如果圖片未載入，繪製預設的雲朵形狀
                                ctx.fillStyle = '#ffffff';
                                ctx.fillRect(x, y, cloud.width, cloud.height);
                            }
                        }
                    }
                });
            }

            // 停止動畫
            stopAnimation() {
                if (!this.animationStarted) return;
                
                this.animationStarted = false;
                console.log('☁️ Cloud2動畫停止！');
                
                // 停止播放 Cloud 音效
                stopCloudAudio();
            }
            
            // 重置
            reset() {
                this.clouds = [];
                this.animationStarted = false;
                this.startTime = null;
                this.cloud1StartTime = null;
                this.cloud2StartTime = null;
                this.cloud3StartTime = null;
                
                // 停止播放 Cloud 音效
                stopCloudAudio();
            }

            // 檢查是否應該啟動動畫
            checkTrigger(player, house7X, house7Width) {
                // 檢查主角是否在road-short-1或road-short-2上
                const isOnShortRoad = world.roads.some(road => 
                    (road.type === 'road-short-1' || road.type === 'road-short-2') &&
                    player.x >= road.x && player.x <= road.x + road.width &&
                    player.y >= road.y && player.y <= road.y + road.height
                );
                
                if (this.animationStarted) {
                    // 檢查主角是否離開house-7範圍或進入short road
                    if (player.x < house7X || player.x > house7X + house7Width || isOnShortRoad) {
                        this.stopAnimation();
                    }
                    return;
                }
                
                // 檢查主角是否走到house-7且不在short road上
                if (player.x >= house7X && player.x <= house7X + house7Width && !isOnShortRoad) {
                    this.startAnimation();
                }
            }
        }

        // ===============================
        // Spring 彈簧模組
        // ===============================
        class SpringManager {
            constructor() {
                this.springs = [];
                this.images = {};
                this.imagesLoaded = false;
            }

            // 載入Spring圖片
            loadImages() {
                const springTypes = ['spring-1', 'spring-2', 'spring-3', 'spring-4'];
                let loadedCount = 0;
                
                springTypes.forEach(type => {
                    const img = new Image();
                    img.onload = () => {
                        this.images[type] = img;
                        loadedCount++;
                        console.log(`✅ 彈簧圖片載入完成: ${type}.svg`);
                        
                        if (loadedCount === springTypes.length) {
                            this.imagesLoaded = true;
                            console.log('🏃‍♂️ 所有彈簧圖片載入完成！');
                            // 圖片載入完成後重新計算Spring尺寸
                            this.updateAllDimensions();
                        }
                    };
                    img.onerror = () => {
                        console.log(`❌ 彈簧圖片載入失敗: ${type}.svg`);
                        loadedCount++;
                        if (loadedCount === springTypes.length) {
                            this.imagesLoaded = true;
                        }
                    };
                    img.src = `Vibe Coding 組_SylviaSYLin遊戲介面/assets/${type}.svg`;
                });
            }

            // 創建Spring彈簧
            createSpring(x, y, playerWidth) {
                const springWidthRatio = 42 / 109; // 42像素寬度相對於109角色寬度的比例
                const springWidth = Math.floor(playerWidth * springWidthRatio);
                
                let springHeight;
                if (this.images['spring-1'] && this.images['spring-1'].complete) {
                    const originalRatio = this.images['spring-1'].naturalHeight / this.images['spring-1'].naturalWidth;
                    springHeight = Math.floor(springWidth * originalRatio);
                } else {
                    const defaultRatio = 1.2;
                    springHeight = Math.floor(springWidth * defaultRatio);
                }

                const spring = {
                    x: x,
                    y: y,
                    width: springWidth,
                    height: springHeight,
                    state: 'idle', // 'idle', 'standby', 'compressing', 'compressed', 'expanding'
                    currentFrame: 1,
                    animationTime: 0,
                    isPlayerOn: false,
                    playerStandTime: 0,
                    standbyDuration: 0.3 * 1000,
                    compressionDuration: 0.01 * 1000,
                    holdDuration: 0.03 * 1000,
                    expansionDuration: 0.01 * 1000
                };

                this.springs.push(spring);
                console.log('🏃‍♂️ Spring彈簧創建完成:', spring);
                return spring;
            }

            // 更新所有Spring尺寸
            updateAllDimensions() {
                this.springs.forEach(spring => {
                    this.updateSpringDimensions(spring, player.width);
                });
            }

            // 更新單個Spring尺寸
            updateSpringDimensions(spring, playerWidth) {
                if (!this.images['spring-1'] || !this.images['spring-1'].complete) return;
                
                const springWidthRatio = 42 / 109;
                const springWidth = Math.floor(playerWidth * springWidthRatio);
                const originalRatio = this.images['spring-1'].naturalHeight / this.images['spring-1'].naturalWidth;
                const springHeight = Math.floor(springWidth * originalRatio);
                
                const oldHeight = spring.height;
                spring.width = springWidth;
                spring.height = springHeight;
                spring.y += (oldHeight - springHeight); // 保持底部對齊
            }

            // 檢查障礙物碰撞
            checkObstacleCollisions(player) {
                this.springs.forEach(spring => {
                    if (player.x < spring.x + spring.width &&
                        player.x + player.width > spring.x &&
                        player.y < spring.y + spring.height &&
                        player.y + player.height > spring.y) {
                        
                        // 優先處理垂直碰撞（可以站在spring上面）
                        if (player.velocityY > 0 && player.y < spring.y) {
                            player.y = spring.y - player.height;
                            player.velocityY = 0;
                            player.onGround = true;
                            return;
                        }
                        
                        // 水平碰撞處理（左右阻擋）
                        if (player.y + player.height > spring.y + 5) {
                            if (player.velocityX > 0) {
                                player.x = spring.x - player.width;
                            } else if (player.velocityX < 0) {
                                player.x = spring.x + spring.width;
                            }
                            player.velocityX = 0;
                        }
                    }
                });
            }

            // 檢查觸發碰撞
            checkTriggerCollisions(player) {
                this.springs.forEach(spring => {
                    const playerOnSpringTop = player.x < spring.x + spring.width &&
                                            player.x + player.width > spring.x &&
                                            player.y + player.height >= spring.y &&
                                            player.y + player.height <= spring.y + 10 &&
                                            player.onGround;
                    
                    if (playerOnSpringTop && spring.state === 'idle') {
                        if (!spring.isPlayerOn) {
                            spring.isPlayerOn = true;
                            spring.playerStandTime = Date.now();
                            spring.state = 'standby';
                            console.log('🏃‍♂️ 玩家站到彈簧上，進入待機狀態');
                            
                            // 切換到jump-1動畫
                            jumpState = 'preparing';
                            jumpStartTime = Date.now();
                        }
                    } else if (!playerOnSpringTop && spring.isPlayerOn) {
                        spring.isPlayerOn = false;
                        spring.playerStandTime = 0;
                        if (spring.state === 'standby') {
                            spring.state = 'idle';
                            spring.currentFrame = 1;
                            spring.animationTime = 0;
                            console.log('🏃‍♂️ 玩家離開彈簧，重置狀態');
                        }
                    }
                });
            }

            // 更新Spring動畫
            update(player) {
                const currentTime = Date.now();
                
                this.springs.forEach(spring => {
                    if (spring.state === 'idle') {
                        spring.currentFrame = 1;
                        return;
                    }
                    
                    const deltaTime = currentTime - spring.animationTime;
                    
                    switch (spring.state) {
                        case 'standby':
                            if (spring.isPlayerOn && deltaTime >= spring.standbyDuration) {
                                spring.state = 'compressing';
                                spring.currentFrame = 1;
                                spring.animationTime = currentTime;
                                console.log('🏃‍♂️ 彈簧待機時間結束，開始壓縮動畫');
                            }
                            break;
                            
                        case 'compressing':
                            if (deltaTime >= spring.compressionDuration) {
                                spring.currentFrame++;
                                spring.animationTime = currentTime;
                                
                                if (spring.currentFrame > 4) {
                                    spring.state = 'compressed';
                                    spring.currentFrame = 4;
                                    spring.animationTime = currentTime;
                                    console.log('🏃‍♂️ 彈簧壓縮完成，開始停頓');
                                }
                            }
                            break;
                            
                        case 'compressed':
                            if (deltaTime >= spring.holdDuration) {
                                spring.state = 'expanding';
                                spring.currentFrame = 3;
                                spring.animationTime = currentTime;
                                
                                if (spring.isPlayerOn) {
                                    player.velocityY = -12;
                                    player.onGround = false;
                                    jumpState = 'jumping';
                                    jumpStartTime = Date.now();
                                    console.log('🏃‍♂️ 彈簧彈開！玩家被彈起，切換到jump-2');
                                    
                                    // 播放跳躍音效
                                    playJumpAudio();
                                }
                            }
                            break;
                            
                        case 'expanding':
                            if (deltaTime >= spring.expansionDuration) {
                                spring.currentFrame--;
                                spring.animationTime = currentTime;
                                
                                if (spring.currentFrame < 1) {
                                    spring.state = 'idle';
                                    spring.currentFrame = 1;
                                    spring.animationTime = 0;
                                    console.log('🏃‍♂️ 彈簧回復到閒置狀態');
                                }
                            }
                            break;
                    }
                });
            }

            // 繪製Spring
            draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT) {
                this.springs.forEach(spring => {
                    const x = Math.floor(spring.x - camera.x);
                    const y = Math.floor(spring.y - camera.y);
                    
                    if (x + spring.width >= 0 && x <= GAME_WIDTH &&
                        y + spring.height >= 0 && y <= GAME_HEIGHT) {
                        
                        const frameName = `spring-${spring.currentFrame}`;
                        
                        if (this.imagesLoaded && this.images[frameName]) {
                            ctx.save();
                            ctx.imageSmoothingEnabled = false;
                            ctx.drawImage(this.images[frameName], x, y, spring.width, spring.height);
                            ctx.restore();
                        } else {
                            // 預設彈簧樣式
                            ctx.fillStyle = '#4CAF50';
                            ctx.fillRect(x, y, spring.width, spring.height);
                            
                            ctx.strokeStyle = '#2E7D32';
                            ctx.lineWidth = 2;
                            
                            const compressionRatio = spring.currentFrame / 4;
                            const compressedHeight = Math.floor(spring.height * compressionRatio);
                            const offsetY = spring.height - compressedHeight;
                            
                            for (let i = 0; i < 3; i++) {
                                const lineY = y + offsetY + (compressedHeight / 4) * (i + 1);
                                ctx.beginPath();
                                ctx.moveTo(x, lineY);
                                ctx.lineTo(x + spring.width, lineY);
                                ctx.stroke();
                            }
                            
                            ctx.fillStyle = '#ffffff';
                            ctx.font = '8px "Press Start 2P"';
                            ctx.fillText(`S${spring.currentFrame}`, x + 2, y + 10);
                        }
                    }
                });
            }

            // 重置所有Spring狀態
            reset() {
                this.springs.forEach(spring => {
                    spring.state = 'idle';
                    spring.currentFrame = 1;
                    spring.animationTime = 0;
                    spring.isPlayerOn = false;
                    spring.playerStandTime = 0;
                });
            }

            // 清空所有Spring
            clear() {
                this.springs = [];
            }
        }

        // 創建全域Spring管理器
        const springManager = new SpringManager();

        // ===============================
        // HP Logo 血量瓶模組
        // ===============================
        class HpLogoManager {
            constructor() {
                this.hpLogos = [];
                this.image = null;
                this.imageLoaded = false;
            }

            // 載入HP Logo圖片
            loadImage() {
                this.image = new Image();
                this.image.onload = () => {
                    this.imageLoaded = true;
                    console.log('✅ HP Logo圖片載入完成: hp-logo.svg');
                };
                this.image.onerror = () => {
                    console.log('❌ HP Logo圖片載入失敗: hp-logo.svg');
                    this.imageLoaded = false;
                };
                this.image.src = 'Vibe Coding 組_SylviaSYLin遊戲介面/assets/hp-logo.svg';
            }

            // 創建HP Logo（水平排列）
            createHorizontalHpLogos(startX, startY, count, spacing, gameHeight) {
                const hpLogoHeightRatio = 41 / 512; // 41像素高度在512背景中的比例
                const hpLogoHeight = Math.floor(gameHeight * hpLogoHeightRatio);
                
                // 根據圖片實際比例計算寬度，如果沒有則假設為正方形
                let hpLogoWidth;
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    const originalRatio = this.image.naturalWidth / this.image.naturalHeight;
                    hpLogoWidth = Math.floor(hpLogoHeight * originalRatio);
                } else {
                    hpLogoWidth = hpLogoHeight; // 預設為正方形
                }

                for (let i = 0; i < count; i++) {
                    this.hpLogos.push({
                        x: startX + i * (hpLogoWidth + spacing),
                        y: startY,
                        width: hpLogoWidth,
                        height: hpLogoHeight,
                        collected: false,
                        id: `horizontal_${i}`,
                        type: 'horizontal'
                    });
                }

                console.log(`🩹 水平HP Logo創建完成，共${count}個`);
                return { width: hpLogoWidth, height: hpLogoHeight };
            }

            // 創建HP Logo（垂直排列）
            createVerticalHpLogos(centerX, bottomY, count, spacing, gameHeight) {
                const hpLogoHeightRatio = 41 / 512; // 41像素高度在512背景中的比例
                const hpLogoHeight = Math.floor(gameHeight * hpLogoHeightRatio);
                
                // 根據圖片實際比例計算寬度，如果沒有則假設為正方形
                let hpLogoWidth;
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    const originalRatio = this.image.naturalWidth / this.image.naturalHeight;
                    hpLogoWidth = Math.floor(hpLogoHeight * originalRatio);
                } else {
                    hpLogoWidth = hpLogoHeight; // 預設為正方形
                }

                // 計算起始X位置以實現置中
                const startX = centerX - Math.floor(hpLogoWidth / 2);

                for (let i = 0; i < count; i++) {
                    this.hpLogos.push({
                        x: startX,
                        y: bottomY - (i + 1) * (hpLogoHeight + spacing), // 從底部往上排列
                        width: hpLogoWidth,
                        height: hpLogoHeight,
                        collected: false,
                        id: `vertical_${i}`,
                        type: 'vertical'
                    });
                }

                console.log(`🩹 垂直HP Logo創建完成，共${count}個`);
                return { width: hpLogoWidth, height: hpLogoHeight };
            }

            // 檢查碰撞
            checkCollisions(player) {
                let collectedCount = 0;
                
                this.hpLogos.forEach(hpLogo => {
                    if (!hpLogo.collected) {
                        if (player.x < hpLogo.x + hpLogo.width &&
                            player.x + player.width > hpLogo.x &&
                            player.y < hpLogo.y + hpLogo.height &&
                            player.y + player.height > hpLogo.y) {
                            
                            hpLogo.collected = true;
                            collectedCount++;
                            console.log(`💊 光球被收集: ${hpLogo.id}`);
                            
                            // 播放 HP Logo 收集音效
                            playHpLogoAudio();
                            
                            // 通知 HeartManager 收集了光球
                            if (typeof heartManager !== 'undefined') {
                                heartManager.collectOrb();
                            }
                        }
                    }
                });

                return collectedCount;
            }

            // 繪製HP Logo
            draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT) {
                this.hpLogos.forEach(hpLogo => {
                    if (!hpLogo.collected) {
                        const x = Math.floor(hpLogo.x - camera.x);
                        const y = Math.floor(hpLogo.y - camera.y);
                        
                        // 檢查是否在畫面內
                        if (x + hpLogo.width >= 0 && x <= GAME_WIDTH &&
                            y + hpLogo.height >= 0 && y <= GAME_HEIGHT) {
                            
                            if (this.imageLoaded && this.image) {
                                ctx.save();
                                ctx.imageSmoothingEnabled = false;
                                ctx.drawImage(this.image, x, y, hpLogo.width, hpLogo.height);
                                ctx.restore();
                            } else {
                                // 預設樣式：紅色十字
                                ctx.fillStyle = '#ff0000';
                                ctx.fillRect(x, y, hpLogo.width, hpLogo.height);
                                
                                // 繪製十字
                                ctx.fillStyle = '#ffffff';
                                const crossWidth = Math.floor(hpLogo.width * 0.2);
                                const crossHeight = Math.floor(hpLogo.height * 0.6);
                                const horizontalCrossHeight = Math.floor(hpLogo.height * 0.2);
                                const horizontalCrossWidth = Math.floor(hpLogo.width * 0.6);
                                
                                // 垂直線
                                ctx.fillRect(
                                    x + Math.floor((hpLogo.width - crossWidth) / 2), 
                                    y + Math.floor((hpLogo.height - crossHeight) / 2), 
                                    crossWidth, 
                                    crossHeight
                                );
                                
                                // 水平線
                                ctx.fillRect(
                                    x + Math.floor((hpLogo.width - horizontalCrossWidth) / 2), 
                                    y + Math.floor((hpLogo.height - horizontalCrossHeight) / 2), 
                                    horizontalCrossWidth, 
                                    horizontalCrossHeight
                                );
                            }
                        }
                    }
                });
            }

            // 獲取收集到的HP Logo數量
            getCollectedCount() {
                return this.hpLogos.filter(hpLogo => hpLogo.collected).length;
            }

            // 獲取總HP Logo數量
            getTotalCount() {
                return this.hpLogos.length;
            }

            // 重置所有HP Logo狀態
            reset() {
                this.hpLogos.forEach(hpLogo => {
                    hpLogo.collected = false;
                });
            }

            // 清空所有HP Logo
            clear() {
                this.hpLogos = [];
            }
        }

        // 創建全域HP Logo管理器
        const hpLogoManager = new HpLogoManager();
        const cloudManager = new CloudManager();
        const cloudManager2 = new CloudManager2();
        const lightningManager = new LightningManager();
        const lightningManager2 = new LightningManager2();

        // HP Logo圖片載入已移至HpLogoManager模組



        function loadRoadImages() {
            const roadTypes = ['road-1', 'road-kanban', 'road-2', 'road-3', 'road-4', 'road-5', 'road-7', 'road-8', 'road-9', 'road-mid', 'road-short-1', 'road-short-2', 'house-1', 'house-2', 'house-3', 'house-4', 'house-5', 'house-6', 'house-7', 'house-8', 'bridge-1', 'bridge-2', 'laboratory-1', 'laboratory-2', 'cloud-1', 'cloud-2', 'cloud-3', 'lightning', 'heart-1', 'heart-2'];
            let loadedCount = 0;
            
            roadTypes.forEach(type => {
                const img = new Image();
                img.onload = function() {
                    roadImages[type] = img;
                    // 記錄原始尺寸
                    roadOriginalSizes[type] = {
                        width: this.naturalWidth || this.width,
                        height: this.naturalHeight || this.height
                    };
                    loadedCount++;
                    console.log(`✅ 路面圖片載入完成: ${type}.svg (${roadOriginalSizes[type].width}x${roadOriginalSizes[type].height})`);
                    
                    if (loadedCount === roadTypes.length) {
                        roadsLoaded = true;
                        console.log('🛣️ 所有路面圖片載入完成！');
                        // 圖片載入完成後重新創建世界以應用正確尺寸
                        if (typeof createWorld === 'function') {
                            createWorld();
                        }
                    }
                };
                img.onerror = function() {
                    console.log(`❌ 路面圖片載入失敗: ${type}.svg`);
                    // 使用預設尺寸
                    roadOriginalSizes[type] = {
                        width: 200,
                        height: 32
                    };
                    loadedCount++;
                    if (loadedCount === roadTypes.length) {
                        roadsLoaded = true;
                        if (typeof createWorld === 'function') {
                            createWorld();
                        }
                    }
                };
                img.src = `Vibe Coding 組_SylviaSYLin遊戲介面/assets/${type}.svg`;
            });
        }

        function drawRoads() {
            world.roads.forEach(road => {
                // 使用Math.floor確保整數像素位置，避免閃爍
                const x = Math.floor(road.x - camera.x);
                const y = Math.floor(road.y - camera.y);
                
                if (x + road.width >= 0 && x <= GAME_WIDTH &&
                    y + road.height >= 0 && y <= GAME_HEIGHT) {
                    
                    // 嘗試繪製SVG圖片
                    if (roadsLoaded && roadImages[road.type]) {
                        ctx.save();
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(roadImages[road.type], x, y, road.width, road.height);
                        ctx.restore();
                    } else if (road.type === 'laboratory-2') {
                        // laboratory-2顯示為不同的顏色
                        ctx.fillStyle = '#FFD700'; // 金色
                        ctx.strokeStyle = '#FFA500';
                        ctx.lineWidth = 2;
                        ctx.fillRect(x, y, road.width, road.height);
                        ctx.strokeRect(x, y, road.width, road.height);
                    } else {
                        // 如果圖片未載入，繪製預設的方塊
                        if ((road.type === 'road-short-1' || road.type === 'road-short-2') && road.isFalling) {
                            // 掉落中的road-short-1和road-short-2顯示為紅色
                            ctx.fillStyle = '#FF4444';
                            ctx.strokeStyle = '#FF0000';
                        } else {
                            // 其他road顯示為綠色
                            ctx.fillStyle = '#228B22';
                            ctx.strokeStyle = '#32CD32';
                        }
                        ctx.lineWidth = 2;
                        ctx.fillRect(x, y, road.width, road.height);
                        ctx.strokeRect(x, y, road.width, road.height);
                        
                        // 為road-short-1和road-short-2添加標籤
                        if (road.type === 'road-short-1' || road.type === 'road-short-2') {
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = '8px Arial';
                            ctx.fillText(road.id, x + 2, y + 10);
                        }
                        
                        // 顯示文字標示
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '16px "Press Start 2P"';
                        ctx.fillText(road.type, x + 10, y + 30);
                    }
                }
            });
        }

        function drawHpLogos() {
            hpLogos.forEach(hpLogo => {
                // 如果hp-logo已被收集，不繪製
                if (hpLogo.collected) return;
                
                // 使用Math.floor確保整數像素位置，避免閃爍
                const x = Math.floor(hpLogo.x - camera.x);
                const y = Math.floor(hpLogo.y - camera.y);
                
                // 檢查是否在畫面內
                if (x + hpLogo.width >= 0 && x <= GAME_WIDTH &&
                    y + hpLogo.height >= 0 && y <= GAME_HEIGHT) {
                    
                    // 嘗試繪製HP Logo圖片
                    if (hpLogoLoaded && hpLogoImage) {
                        ctx.save();
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(hpLogoImage, x, y, hpLogo.width, hpLogo.height);
                        ctx.restore();
                    } else {
                        // 如果圖片未載入，繪製預設的紅色十字
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(x, y, hpLogo.width, hpLogo.height);
                        
                        // 繪製白色十字
                        ctx.fillStyle = '#ffffff';
                        const crossSize = Math.floor(hpLogo.width * 0.6);
                        const crossThickness = Math.floor(hpLogo.width * 0.15);
                        const centerX = x + hpLogo.width / 2;
                        const centerY = y + hpLogo.height / 2;
                        
                        // 水平線
                        ctx.fillRect(centerX - crossSize/2, centerY - crossThickness/2, crossSize, crossThickness);
                        // 垂直線
                        ctx.fillRect(centerX - crossThickness/2, centerY - crossSize/2, crossThickness, crossSize);
                    }
                }
            });
        }


        
        function drawEndpoint() {
            // 已刪除 lab 藍色框框
            return;
        }
        

        
        function drawPlayer() {
            // 使用Math.floor確保整數像素位置，避免閃爍
            const x = Math.floor(player.x - camera.x);
            const y = Math.floor(player.y - camera.y);
            
            // 設定透明度
            const alpha = player.alpha !== undefined ? player.alpha : 1;
            ctx.globalAlpha = alpha;
            
            let hasValidSprite = false;
            let sprite = null;
            
            if (currentAnimation === 'jumping') {
                // 使用跳躍圖片 (jump-2)
                if (characterSprites.jumping && characterSprites.jumping.complete) {
                    hasValidSprite = true;
                    sprite = characterSprites.jumping;
                }
            } else if (currentAnimation === 'jumpPrepare') {
                // 使用準備跳躍圖片 (jump-1)
                if (characterSprites.jumpPrepare && characterSprites.jumpPrepare.complete) {
                    hasValidSprite = true;
                    sprite = characterSprites.jumpPrepare;
                }
            } else {
                // 檢查是否有有效的動畫幀
                const animFrames = characterSprites[currentAnimation];
                
                // 確保動畫幀索引在有效範圍內
                if (animFrames && animFrames.length > 0 && animationFrame >= animFrames.length) {
                    console.log(`⚠️ 動畫幀索引超出範圍: ${animationFrame} >= ${animFrames.length}，重置為0`);
                    animationFrame = 0;
                }
                
                hasValidSprite = animFrames && 
                              animFrames.length > 0 && 
                              animationFrame < animFrames.length &&
                              animFrames[animationFrame] && 
                              animFrames[animationFrame].complete;
                
                if (hasValidSprite) {
                    sprite = animFrames[animationFrame];
                }
                
                // 調試信息（僅在需要時顯示）
                if (currentAnimation === 'running' && !hasValidSprite) {
                    console.log(`❌ 跑步動畫幀無效: 索引${animationFrame}, 動畫數組長度${animFrames?.length}`);
                }
            }
            
            if (hasValidSprite && sprite) {
                // 繪製自定義角色動畫
                ctx.save();
                
                // 設置高品質渲染
                ctx.imageSmoothingEnabled = false;
                ctx.imageSmoothingQuality = 'high';
                
                // 如果面向左邊，水平翻轉
                if (!player.facingRight) {
                    ctx.scale(-1, 1);
                    ctx.drawImage(sprite, -(x + player.width), y, player.width, player.height);
                } else {
                    ctx.drawImage(sprite, x, y, player.width, player.height);
                }
                
                ctx.restore();
            } else {
                // 使用預設的emoji角色
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(x, y, player.width, player.height);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = '26px "Press Start 2P"';
                
                // 根據面向方向調整emoji
                if (!player.facingRight) {
                    // 面向左邊時稍微偏移
                    ctx.fillText('🧑‍🔬', x + 15, y + 35);
                } else {
                    ctx.fillText('🧑‍🔬', x + 18, y + 35);
                }
            }
            
            // 繪製防護罩效果
            if (player.shieldActive) {
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(x + player.width/2, y + player.height/2, 30, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = '#00ffff';
                ctx.font = '12px "Press Start 2P"';
                ctx.fillText(`${3 - player.shieldHits}`, x + player.width + 8, y + 15);
            }
            
            // 重置透明度
            ctx.globalAlpha = 1;
        }
        
        function gameLoop() {
            update();
            springManager.update(player);
            render();
                if (gameState === 'playing' || gameState === 'intro') {
        gameLoopId = requestAnimationFrame(gameLoop);
    }
        }
        
        window.addEventListener('load', init);

        // ===============================
        // Heart 心臟系統
        // ===============================
        class HeartManager {
            constructor() {
                this.hearts = [];
                this.images = {};
                this.imagesLoaded = false;
                this.maxHearts = 5;
                this.currentHearts = 5;
                this.collectedOrbs = 0; // 總收集光球數
                this.orbsForRecovery = 0; // 用於回復的光球計數
            }

            // 載入Heart圖片
            loadImages() {
                const heartTypes = ['heart-1', 'heart-2', 'hp-small'];
                let loadedCount = 0;
                
                heartTypes.forEach(type => {
                    const img = new Image();
                    img.onload = () => {
                        this.images[type] = img;
                        loadedCount++;
                        console.log(`✅ 心臟圖片載入完成: ${type}.svg`);
                        
                        if (loadedCount === heartTypes.length) {
                            this.imagesLoaded = true;
                            console.log('❤️ 所有心臟圖片載入完成！');
                            // 圖片載入完成後創建心臟
                            this.createHearts();
                        }
                    };
                    img.onerror = () => {
                        console.log(`❌ 心臟圖片載入失敗: ${type}.svg`);
                        loadedCount++;
                        if (loadedCount === heartTypes.length) {
                            this.imagesLoaded = true;
                            this.createHearts();
                        }
                    };
                    img.src = `Vibe Coding 組_SylviaSYLin遊戲介面/assets/${type}.svg`;
                });
            }

            // 創建心臟
            createHearts() {
                // 計算心臟尺寸
                const heartHeightRatio = 22 / 512; // 22像素高度在512背景中的比例 (4.30%)
                const heartHeight = Math.floor(GAME_HEIGHT * heartHeightRatio);
                
                let heartWidth;
                if (this.images['heart-1'] && this.images['heart-1'].complete) {
                    const originalRatio = this.images['heart-1'].naturalWidth / this.images['heart-1'].naturalHeight;
                    heartWidth = Math.floor(heartHeight * originalRatio);
                } else {
                    const defaultRatio = 1.0; // 預設為正方形
                    heartWidth = Math.floor(heartHeight * defaultRatio);
                }

                // 計算心臟位置
                const heartTopDistanceRatio = 20 / 512; // 20像素距離在512背景中的比例 (3.91%)
                const heartLeftDistanceRatio = 30 / 512; // 30像素距離在512背景中的比例 (5.86%)
                const heartSpacingRatio = 4 / 512; // 4像素間距在512背景中的比例 (0.78%)
                
                const heartTopDistance = Math.floor(GAME_HEIGHT * heartTopDistanceRatio);
                const heartLeftDistance = Math.floor(GAME_HEIGHT * heartLeftDistanceRatio);
                const heartSpacing = Math.floor(GAME_HEIGHT * heartSpacingRatio);

                // 創建5個心臟
                for (let i = 0; i < this.maxHearts; i++) {
                    this.hearts.push({
                        x: heartLeftDistance + i * (heartWidth + heartSpacing),
                        y: heartTopDistance,
                        width: heartWidth,
                        height: heartHeight,
                        type: 'heart-1', // 預設為滿心臟
                        id: `heart_${i + 1}`
                    });
                }

                // 計算hp-small尺寸
                const hpSmallHeightRatio = 22 / 512; // 22像素高度在512背景中的比例
                const hpSmallHeight = Math.floor(GAME_HEIGHT * hpSmallHeightRatio);
                
                let hpSmallWidth;
                if (this.images['hp-small'] && this.images['hp-small'].complete) {
                    const originalRatio = this.images['hp-small'].naturalWidth / this.images['hp-small'].naturalHeight;
                    hpSmallWidth = Math.floor(hpSmallHeight * originalRatio);
                } else {
                    const defaultRatio = 1.0; // 預設為正方形
                    hpSmallWidth = Math.floor(hpSmallHeight * defaultRatio);
                }

                // 計算hp-small位置
                const hpSmallTopDistanceRatio = 8 / 512; // 8像素距離在512背景中的比例
                const hpSmallTopDistance = Math.floor(GAME_HEIGHT * hpSmallTopDistanceRatio);

                // 創建hp-small
                this.hearts.push({
                    x: heartLeftDistance, // 與heart-1左邊對齊
                    y: heartTopDistance + heartHeight + hpSmallTopDistance, // heart-1底部往下8像素
                    width: hpSmallWidth,
                    height: hpSmallHeight,
                    type: 'hp-small',
                    id: 'hp-small'
                });

                console.log('❤️ 心臟系統創建完成:', this.hearts);
            }

            // 扣除愛心（被雷擊時調用）
            loseHeart() {
                if (this.currentHearts > 0) {
                    this.currentHearts--;
                    this.updateHeartDisplay();
                    console.log(`❤️ 愛心被扣除，剩餘：${this.currentHearts}/${this.maxHearts}`);
                    
                    if (this.currentHearts === 0) {
                        console.log('生命歸零');
                        return true; // 返回true表示遊戲結束
                    }
                }
                return false;
            }

            // 收集光球
            collectOrb() {
                this.collectedOrbs++;
                this.orbsForRecovery++;
                console.log(`💎 收集光球：${this.collectedOrbs}總數，回復用：${this.orbsForRecovery}`);
                
                // 每5顆光球回復1點生命
                if (this.orbsForRecovery >= 5 && this.currentHearts < this.maxHearts) {
                    this.currentHearts++;
                    this.orbsForRecovery -= 5; // 扣除用於回復的光球
                    this.updateHeartDisplay();
                    console.log(`❤️ 回復愛心！當前：${this.currentHearts}/${this.maxHearts}`);
                }
            }

            // 更新心臟顯示
            updateHeartDisplay() {
                // 更新每個心臟的類型（排除hp-small），從右邊開始扣除
                let heartIndex = 0;
                this.hearts.forEach((heart, index) => {
                    if (heart.type === 'hp-small') return; // 跳過hp-small
                    
                    if (heartIndex < this.currentHearts) {
                        heart.type = 'heart-1'; // 滿心臟
                    } else {
                        heart.type = 'heart-2'; // 空心臟
                    }
                    heartIndex++;
                });
            }

            // 檢查是否可以過關（至少35顆光球）
            canWin() {
                return this.collectedOrbs >= 35;
            }

            // 獲取當前狀態
            getStatus() {
                return {
                    hearts: this.currentHearts,
                    orbs: this.collectedOrbs,
                    canWin: this.canWin()
                };
            }

            // 繪製心臟
            draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT) {
                let hpSmallX = 0;
                let hpSmallY = 0;
                let hpSmallWidth = 0;
                let hpSmallHeight = 0;
                let hpSmallFound = false;

                this.hearts.forEach(heart => {
                    // 固定在螢幕位置，不受攝影機影響
                    const x = Math.floor(heart.x);
                    const y = Math.floor(heart.y);
                    
                    if (this.imagesLoaded && this.images[heart.type]) {
                        ctx.save();
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(this.images[heart.type], x, y, heart.width, heart.height);
                        ctx.restore();

                        // 記錄hp-small的位置信息
                        if (heart.type === 'hp-small') {
                            hpSmallX = x;
                            hpSmallY = y;
                            hpSmallWidth = heart.width;
                            hpSmallHeight = heart.height;
                            hpSmallFound = true;
                        }
                    } else {
                        // 預設心臟樣式
                        ctx.fillStyle = heart.type === 'heart-1' ? '#ff0000' : '#666666';
                        ctx.fillRect(x, y, heart.width, heart.height);
                        
                        // 繪製心臟輪廓
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, heart.width, heart.height);
                        
                        // 顯示心臟類型
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '8px "Press Start 2P"';
                        ctx.fillText(heart.type === 'heart-1' ? 'H1' : 'H2', x + 2, y + 10);

                        // 記錄hp-small的位置信息（預設樣式時）
                        if (heart.type === 'hp-small') {
                            hpSmallX = x;
                            hpSmallY = y;
                            hpSmallWidth = heart.width;
                            hpSmallHeight = heart.height;
                            hpSmallFound = true;
                        }
                    }
                });

                // 如果找到hp-small，在其右邊顯示光球收集數量
                if (hpSmallFound && typeof hpLogoManager !== 'undefined') {
                    const collectedCount = this.collectedOrbs;
                    const totalCount = hpLogoManager.getTotalCount();
                    const text = `${collectedCount}/${totalCount}`;

                    // 計算文字距離
                    const textSpacingRatio = 4 / 512; // 4像素距離在512背景中的比例
                    const textSpacing = Math.floor(GAME_HEIGHT * textSpacingRatio);

                    // 動態計算文字大小（當hp-small高度為22時，字體大小為16）
                    const fontSizeRatio = 12 / 22; // 16pt字體對應22像素hp-small高度的比例
                    const fontSize = Math.floor(hpSmallHeight * fontSizeRatio);
                    
                    // 設置文字樣式
                    ctx.save();
                    ctx.font = `${fontSize}px "Press Start 2P"`;
                    ctx.fillStyle = '#ffffff';
                    ctx.textBaseline = 'middle';
                    
                    // 計算文字位置（水平置中對齊hp-small）
                    const textX = hpSmallX + hpSmallWidth + textSpacing;
                    const textY = hpSmallY + Math.floor(hpSmallHeight / 2);

                    // 繪製文字
                    ctx.fillText(text, textX, textY);
                    ctx.restore();
                }
            }

            // 重置心臟狀態
            reset() {
                this.currentHearts = this.maxHearts;
                this.collectedOrbs = 0;
                this.orbsForRecovery = 0;
                this.hearts.forEach(heart => {
                    if (heart.type !== 'hp-small') {
                        heart.type = 'heart-1';
                    }
                });
            }

            // 清空所有心臟
            clear() {
                this.hearts = [];
            }
        }

        // 創建全域心臟管理器
        const heartManager = new HeartManager();
    </script>
</body>
</html>
