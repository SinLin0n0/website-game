<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>像素冒險 - 危險逃脫</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Press Start 2P', monospace;
            background: #000000; /* 黑色背景 */
            overflow: hidden;
            color: white;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        .game-container {
            position: relative;
            background: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameCanvas {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            display: block;
            width: 100vw; /* 左右延伸到邊緣 */
            height: calc(100vh * 513 / 749); /* 按比例動態高度 */
        }
        
        /* 故事背景視窗 */
        .story-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .story-content {
            background: linear-gradient(45deg, #2d1b69, #11998e);
            border: 4px solid #00ff00;
            border-radius: 0;
            padding: 30px;
            max-width: 600px;
            min-height: 400px;
            position: relative;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }
        
        .story-page {
            display: none;
            line-height: 1.8;
            font-size: 12px;
        }
        
        .story-page.active {
            display: block;
        }
        
        .story-nav {
            position: absolute;
            bottom: 20px;
            right: 20px;
        }
        
        .story-button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-family: inherit;
            font-size: 10px;
            cursor: pointer;
            border: 2px solid #000;
            transition: all 0.1s;
        }
        
        .story-button:hover {
            background: #fff;
            transform: scale(1.05);
        }
        

        
        /* 結局視窗 */
        .ending-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .ending-content {
            background: linear-gradient(45deg, #2d1b69, #11998e);
            border: 4px solid #00ff00;
            padding: 30px;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }
        
        .ending-title {
            font-size: 16px;
            margin-bottom: 20px;
            color: #00ff00;
        }
        
        .ending-text {
            font-size: 10px;
            line-height: 1.6;
            margin-bottom: 20px;
        }
        
        .restart-button {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 15px 30px;
            font-family: inherit;
            font-size: 10px;
            cursor: pointer;
            border: 2px solid #000;
        }
        
        .restart-button:hover {
            background: #ff5252;
            transform: scale(1.05);
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- 故事背景視窗 -->
        <div class="story-modal" id="storyModal">
            <div class="story-content">
                <div class="story-page active" data-page="1">
                    <h3 style="color: #00ff00; margin-bottom: 20px;">第一章：突破重圍</h3>
                    <p>西元2147年，人類科技已經發展到巔峰。</p>
                    <br>
                                    <p>你是一名研究員，意外發現了一個驚人的秘密...</p>
                <br>
                <p>這個地方的防禦系統突然啟動，各種障礙物開始攻擊入侵者。</p>
                    <br>
                    <p>你必須想辦法逃出這個危險的地方！</p>
                </div>
                
                <div class="story-page" data-page="2">
                    <h3 style="color: #00ff00; margin-bottom: 20px;">第二章：逃脫計畫</h3>
                    <p>沿途會有電信門市提供補給物品。</p>
                    <br>
                    <p>🩹 補血物品：可以恢復你的生命值</p>
                    <p>🛡️ 防護罩：能抵擋三次攻擊</p>
                    <br>
                    <p>小心從天而降的障礙物，它們會造成傷害！</p>
                    <br>
                    <p>避開地面的陷阱，掉下去就完蛋了。</p>
                </div>
                
                <div class="story-page" data-page="3">
                    <h3 style="color: #00ff00; margin-bottom: 20px;">操作說明</h3>
                    <p>🎮 左右方向鍵：移動角色</p>
                    <br>
                    <p>🚀 空白鍵：跳躍</p>
                    <br>
                    <p>🖱️ 雙擊物品：使用補給品</p>
                    <br>
                    <p>你的目標是逃離這個危險的地方！</p>
                    <br>
                    <p style="color: #ff6b6b;">準備好了嗎？讓我們開始冒險吧！</p>
                </div>
                
                <div class="story-nav">
                    <button class="story-button" id="nextBtn" onclick="nextPage()">下一頁 ▶</button>
                    <button class="story-button hidden" id="startBtn" onclick="startGame()">開始遊戲</button>
                </div>
            </div>
        </div>
        

        
        <!-- 遊戲畫布 -->
        <canvas id="gameCanvas"></canvas>
        
        <!-- 結局視窗 -->
        <div class="ending-modal" id="endingModal">
            <div class="ending-content">
                <div class="ending-title" id="endingTitle"></div>
                <div class="ending-text" id="endingText"></div>
                <button class="restart-button" onclick="restartGame()">重新開始</button>
            </div>
        </div>
    </div>

    <script>
        // 遊戲變數
        let canvas, ctx;
        let gameState = 'story';
        let currentStoryPage = 1;
        let maxStoryPages = 3;
        let victoryStartTime = null;
        let victoryDuration = 2000;
        let gameLoopId = null;
        
        // 背景圖片變數
        let backgroundImage = null;
        let backgroundWidth = 0;
        let backgroundHeight = 0;
        let backgroundLoaded = false;
        
        // 角色動畫系統
        let characterSprites = {
            idle: [],
            running: [],
            jumpPrepare: null, // 準備跳躍圖片 (jump-1)
            jumping: null // 跳躍圖片 (jump-2)
        };
        let currentAnimation = 'idle';
        let animationFrame = 0;
        let lastFrameTime = 0;
        let idleFrameInterval = 300; // 站立動畫：0.3秒換一張
        let runningFrameInterval = 70; // 跑步動畫：0.07秒換一張
        let spritesLoaded = false;
        
        // 跳躍狀態追蹤
        let jumpState = 'none'; // 'none', 'preparing', 'jumping'
        let jumpStartTime = 0;
        let jumpPrepareTime = 0.1 * 1000; // 準備跳躍動畫持續時間：0.03秒（30毫秒）
        
        // 角色大小動態計算
        function calculatePlayerSize() {
            const playerHeightRatio = 109 / 512; // 109像素高度在512背景中的比例 (21.29%)
            const dynamicHeight = Math.floor(GAME_HEIGHT * playerHeightRatio);
            // 假設角色寬高比為1:1，保持方形比例，如果有特定比例可以調整
            const dynamicWidth = dynamicHeight; // 保持方形，或可根據實際圖片比例調整
            
            return {
                width: dynamicWidth,
                height: dynamicHeight
            };
        }

        // 遊戲物件
        let player = {
            x: 100, y: 0, width: 80, height: 80, // 初始值，會在init時動態計算
            velocityX: 0, velocityY: 0, onGround: false,
            health: 100, maxHealth: 100,
            shieldActive: false, shieldHits: 0,
            facingRight: true,
            alpha: 1,
            controlDisabled: false
        };
        
        let camera = { x: 0, y: 0 };
        
        let world = {
            width: 4000, height: 0, gravity: 0.3, // 增加世界寬度以適應寬屏，高度初始化後設定
            roads: [], endpoint: null
        };
        
        // inventory變數已移除，因為UI元素已移除
        let keys = {};
        
        // 載入背景圖片
        function loadBackgroundImage() {
            backgroundImage = new Image();
            backgroundImage.onload = function() {
                backgroundWidth = this.width;
                backgroundHeight = this.height;
                backgroundLoaded = true;
                console.log('背景圖片載入完成:', backgroundWidth + 'x' + backgroundHeight);
            };
            backgroundImage.onerror = function() {
                console.log('背景圖片載入失敗，使用預設背景');
                backgroundLoaded = false;
            };
            // 使用相對路徑 - 請將您的背景圖片命名為 background.jpg 並放在與此HTML文件相同的目錄中
            backgroundImage.src = 'background.jpg';
        }
        
        // 載入角色動畫 - 確保正確順序載入
        function loadCharacterSprites() {
            // 重置動畫數組，確保順序正確
            characterSprites.idle = [];
            characterSprites.running = [];
            
            // 站立動畫圖片路徑（SVG格式）
            const idleFramePaths = [
                'character-idle-1.svg',
                'character-idle-2.svg'
            ];
            
            // 跑步動畫圖片路徑（SVG格式） - 按照正確順序
            const runningFramePaths = [
                'character-run-1.svg',  // 索引0
                'character-run-2.svg',  // 索引1
                'character-run-3.svg',  // 索引2
                'character-run-4.svg'   // 索引3
            ];
            
            let loadedCount = 0;
            const totalFrames = idleFramePaths.length + runningFramePaths.length;
            
            // 確保按順序載入站立動畫
            function loadIdleAnimation(index) {
                if (index >= idleFramePaths.length) {
                    loadRunningAnimation(0); // 開始載入跑步動畫
                    return;
                }
                
                const img = new Image();
                img.onload = function() {
                    characterSprites.idle[index] = img;
                    loadedCount++;
                    console.log(`✅ 站立動畫 ${index + 1} 載入完成: ${idleFramePaths[index]} (${this.width}x${this.height})`);
                    loadIdleAnimation(index + 1); // 載入下一個
                };
                img.onerror = function() {
                    console.log(`❌ 站立動畫 ${index + 1} 載入失敗: ${idleFramePaths[index]}`);
                    loadIdleAnimation(index + 1); // 繼續載入下一個
                };
                img.src = idleFramePaths[index];
            }
            
            // 確保按順序載入跑步動畫
            function loadRunningAnimation(index) {
                if (index >= runningFramePaths.length) {
                                         // 所有動畫載入完成
                     spritesLoaded = true;
                     console.log('🎉 所有角色動畫載入完成！');
                     console.log('📊 載入結果:');
                     console.log('  站立動畫:', characterSprites.idle.length, '幀');
                     console.log('  跑步動畫:', characterSprites.running.length, '幀');
                     console.log('⏱️ 動畫速度設定:');
                     console.log(`  站立動畫：每${idleFrameInterval}ms切換一幀 (0.3秒)`);
                     console.log(`  跑步動畫：每${runningFrameInterval}ms切換一幀 (0.07秒)`);
                     console.log('🏃 跑步動畫順序確認:');
                     characterSprites.running.forEach((sprite, i) => {
                         console.log(`  索引${i}: ${runningFramePaths[i]} ✅`);
                     });
                     
                     // 驗證動畫完整性
                     console.log('🔍 動畫完整性檢查:');
                     console.log('  預期跑步動畫順序: character-run-1 → character-run-2 → character-run-3 → character-run-4');
                     console.log('  實際載入順序:', characterSprites.running.map((_, i) => `character-run-${i+1}`).join(' → '));
                     
                     if (characterSprites.running.length === 4) {
                         console.log('✅ 跑步動畫載入完整，共4幀');
                     } else {
                         console.log(`❌ 跑步動畫載入不完整，預期4幀，實際${characterSprites.running.length}幀`);
                     }
                    return;
                }
                
                const img = new Image();
                img.onload = function() {
                    characterSprites.running[index] = img;
                    loadedCount++;
                    console.log(`✅ 跑步動畫 ${index + 1} 載入完成: ${runningFramePaths[index]} (${this.width}x${this.height})`);
                    loadRunningAnimation(index + 1); // 載入下一個
                };
                img.onerror = function() {
                    console.log(`❌ 跑步動畫 ${index + 1} 載入失敗: ${runningFramePaths[index]}`);
                    loadRunningAnimation(index + 1); // 繼續載入下一個
                };
                img.src = runningFramePaths[index];
            }
            
            // 開始按順序載入
            loadIdleAnimation(0);
        }

        // 載入跳躍動畫
        function loadJumpSprite() {
            let loadedCount = 0;
            
            // 載入準備跳躍圖片 (jump-1)
            const jumpPrepareImg = new Image();
            jumpPrepareImg.onload = function() {
                characterSprites.jumpPrepare = jumpPrepareImg;
                loadedCount++;
                console.log('✅ 準備跳躍圖片載入完成: jump-1.svg');
                if (loadedCount === 2) {
                    console.log('🏃‍♂️ 所有跳躍圖片載入完成！');
                }
            };
            jumpPrepareImg.onerror = function() {
                console.log('❌ 準備跳躍圖片載入失敗: jump-1.svg');
                loadedCount++;
            };
            jumpPrepareImg.src = 'jump-1.svg';
            
            // 載入跳躍圖片 (jump-2)
            const jumpImg = new Image();
            jumpImg.onload = function() {
                characterSprites.jumping = jumpImg;
                loadedCount++;
                console.log('✅ 跳躍圖片載入完成: jump-2.svg');
                if (loadedCount === 2) {
                    console.log('🏃‍♂️ 所有跳躍圖片載入完成！');
                }
            };
            jumpImg.onerror = function() {
                console.log('❌ 跳躍圖片載入失敗: jump-2.svg');
                loadedCount++;
            };
            jumpImg.src = 'jump-2.svg';
        }
        
        // 移除上傳功能 - 直接使用指定的圖片文件
        
        // 遊戲尺寸設定 - 按照 513:749 比例
        const GAME_HEIGHT_RATIO = 513 / 749;  // 遊戲高度與螢幕高度的比例
        let GAME_HEIGHT = Math.floor(window.innerHeight * GAME_HEIGHT_RATIO);  // 動態計算遊戲高度
        let GAME_WIDTH = window.innerWidth;  // 遊戲畫面寬度適應視窗
        
        // 初始化
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // 設置遊戲尺寸
            updateCanvasSize();
            
            // 動態計算並設置角色大小
            const playerSize = calculatePlayerSize();
            player.width = playerSize.width;
            player.height = playerSize.height;
            
            // 設置世界高度等於遊戲高度
            world.height = GAME_HEIGHT;
            
            // 設置玩家初始位置（約遊戲高度的一半）
            player.y = Math.floor(GAME_HEIGHT * 0.5);
            
            // 設置渲染質量
            ctx.imageSmoothingEnabled = false; // 像素風格保持銳利
            canvas.oncontextmenu = function(e) { e.preventDefault(); e.stopPropagation(); }
            
            loadBackgroundImage();
            loadCharacterSprites();
            loadJumpSprite();
            loadRoadImages();
            hpLogoManager.loadImage();
            springManager.loadImages();
            cloudManager.loadImages();
            cloudManager2.loadImages();
            lightningManager.loadImages();
            lightningManager2.loadImages();
            createWorld();
            setupEventListeners();
            updateUI();
        }
        
        // 更新Canvas尺寸
        function updateCanvasSize() {
            GAME_WIDTH = window.innerWidth;
            GAME_HEIGHT = Math.floor(window.innerHeight * GAME_HEIGHT_RATIO);
            
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;
            canvas.style.width = GAME_WIDTH + 'px';
            canvas.style.height = GAME_HEIGHT + 'px';
            
            // 重新設置渲染品質
            ctx.imageSmoothingEnabled = false;
            ctx.imageSmoothingQuality = 'high';
        }
        
        function createWorld() {
            // 動態計算road-1元件尺寸
            // 基準：背景高度512對應road-1高度32，等比縮放
            const baseBackgroundHeight = 512;
            const baseRoadHeight = 32;
            const scaleRatio = baseRoadHeight / baseBackgroundHeight; // 32/512 = 1/16
            
            let roadWidth, roadHeight;
            
            // 如果有載入原始尺寸，使用原始比例
            if (roadOriginalSizes['road-1']) {
                const originalSize = roadOriginalSizes['road-1'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-1高度
                roadHeight = Math.floor(GAME_HEIGHT * scaleRatio);
                // 根據原始比例計算寬度
                roadWidth = Math.floor(roadHeight * originalRatio);
                
                console.log(`🎯 動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-1高度${roadHeight}, 寬度${roadWidth} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例
                roadHeight = Math.floor(GAME_HEIGHT * scaleRatio);
                roadWidth = Math.floor(roadHeight * (200/32)); // 預設比例 6.25
                
                console.log(`⚠️ 使用預設比例: road-1高度${roadHeight}, 寬度${roadWidth}`);
            }
            
            // 設定road-1位置：與背景齊左，動態計算底部距離
            const roadX = 0; // 與背景齊左
            const bottomDistanceRatio = 93 / 512; // 93像素距離在512高度背景中的比例 (18.16%)
            const dynamicBottomDistance = Math.floor(GAME_HEIGHT * bottomDistanceRatio);
            const roadY = GAME_HEIGHT - dynamicBottomDistance - roadHeight; // 動態計算底部距離
            
            // 計算road-kanban元件尺寸
            let kanbanWidth, kanbanHeight;
            const kanbanHeightRatio = 105 / 512; // 105像素高度在512背景中的比例 (20.51%)
            
            if (roadOriginalSizes['road-kanban']) {
                const originalSize = roadOriginalSizes['road-kanban'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-kanban高度
                kanbanHeight = Math.floor(GAME_HEIGHT * kanbanHeightRatio);
                // 根據原始比例計算寬度
                kanbanWidth = Math.floor(kanbanHeight * originalRatio);
                
                console.log(`🎯 動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-kanban高度${kanbanHeight}, 寬度${kanbanWidth} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例 94:105
                kanbanHeight = Math.floor(GAME_HEIGHT * kanbanHeightRatio);
                kanbanWidth = Math.floor(kanbanHeight * (94/105)); // 預設比例
                
                console.log(`⚠️ 使用預設比例: road-kanban高度${kanbanHeight}, 寬度${kanbanWidth}`);
            }
            
            // 設定road-kanban位置：底部對齊road-1頂部，左邊距離動態調整
            const kanbanLeftDistanceRatio = 37 / 512; // 37像素距離在512高度背景中的比例 (7.23%)
            const kanbanX = Math.floor(GAME_HEIGHT * kanbanLeftDistanceRatio); // 使用背景高度計算左邊距
            const kanbanY = roadY - kanbanHeight; // 底部對齊road-1頂部
            
            // 計算road-2元件尺寸
            let road2Width, road2Height;
            const road2HeightRatio = 32 / 512; // 32像素高度在512背景中的比例 (6.25%)
            
            if (roadOriginalSizes['road-2']) {
                const originalSize = roadOriginalSizes['road-2'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-2高度
                road2Height = Math.floor(GAME_HEIGHT * road2HeightRatio);
                // 根據原始比例計算寬度
                road2Width = Math.floor(road2Height * originalRatio);
                
                console.log(`🎯 動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-2高度${road2Height}, 寬度${road2Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例 171:32
                road2Height = Math.floor(GAME_HEIGHT * road2HeightRatio);
                road2Width = Math.floor(road2Height * (171/32)); // 預設比例
                
                console.log(`⚠️ 使用預設比例: road-2高度${road2Height}, 寬度${road2Width}`);
            }
            
            // 設定road-2位置：底部對齊背景底部，左邊對齊road-1右邊
            const road2BottomDistanceRatio = 202 / 512; // 202像素距離在512背景中的比例 (39.45%)
            const road2LeftDistanceRatio = 135 / 512; // 135像素距離在512背景中的比例 (26.37%)
            const road2X = Math.floor(GAME_WIDTH * road2LeftDistanceRatio); // 使用背景寬度計算左邊距
            const road2Y = GAME_HEIGHT - Math.floor(GAME_HEIGHT * road2BottomDistanceRatio) - road2Height; // 底部對齊背景底部
            
            // 計算house-1元件尺寸
            let house1Width, house1Height;
            const house1HeightRatio = 221 / 512; // 221像素高度在512背景中的比例 (43.16%)
            
            if (roadOriginalSizes['house-1']) {
                const originalSize = roadOriginalSizes['house-1'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算house-1高度
                house1Height = Math.floor(GAME_HEIGHT * house1HeightRatio);
                // 根據原始比例計算寬度
                house1Width = Math.floor(house1Height * originalRatio);
                
                console.log(`🎯 動態尺寸計算: 遊戲高度${GAME_HEIGHT} → house-1高度${house1Height}, 寬度${house1Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例 4:3
                house1Height = Math.floor(GAME_HEIGHT * house1HeightRatio);
                house1Width = Math.floor(house1Height * (4/3)); // 預設比例
                
                console.log(`⚠️ 使用預設比例: house-1高度${house1Height}, 寬度${house1Width}`);
            }
            
            // 設定house-1位置：底部對齊road-2的頂部，右邊與road-2右邊距離為33
            const house1RightDistanceRatio = 33 / 512; // 33像素距離在512背景中的比例 (6.45%)
            const house1RightDistance = Math.floor(GAME_HEIGHT * house1RightDistanceRatio); // 使用背景高度計算距離
            const house1X = road2X + road2Width - house1Width - house1RightDistance; // 右邊距離road-2右邊33像素
            const house1Y = road2Y - house1Height; // 底部對齊road-2頂部
            
            // 計算road-3元件尺寸
            let road3Width, road3Height;
            const road3HeightRatio = 32 / 512; // 32像素高度在512背景中的比例 (6.25%)
            
            if (roadOriginalSizes['road-3']) {
                const originalSize = roadOriginalSizes['road-3'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-3高度
                road3Height = Math.floor(GAME_HEIGHT * road3HeightRatio);
                // 根據原始比例計算寬度
                road3Width = Math.floor(road3Height * originalRatio);
                
                console.log(`🎯 動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-3高度${road3Height}, 寬度${road3Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設與road-2相同的比例 171:32
                road3Height = Math.floor(GAME_HEIGHT * road3HeightRatio);
                road3Width = Math.floor(road3Height * (171/32)); // 預設比例
                
                console.log(`⚠️ 使用預設比例: road-3高度${road3Height}, 寬度${road3Width}`);
            }
            
            // 設定road-3位置：底部對齊背景底部，左邊對齊road-2右邊
            const road3BottomDistanceRatio = 65 / 512; // 65像素距離在512背景中的比例 (12.70%)
            const road3LeftDistanceRatio = 63 / 512; // 63像素距離在512背景中的比例 (12.30%)
            const road3LeftDistance = Math.floor(GAME_HEIGHT * road3LeftDistanceRatio); // 使用背景高度計算距離
            const road3X = road2X + road2Width + road3LeftDistance; // 左邊對齊road-2右邊，距離63像素
            const road3Y = GAME_HEIGHT - Math.floor(GAME_HEIGHT * road3BottomDistanceRatio) - road3Height; // 底部對齊背景底部，距離65像素
            
            // 計算house-2元件尺寸
            let house2Width, house2Height;
            const house2HeightRatio = 189 / 512; // 189像素高度在512背景中的比例 (36.91%)
            
            if (roadOriginalSizes['house-2']) {
                const originalSize = roadOriginalSizes['house-2'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算house-2高度
                house2Height = Math.floor(GAME_HEIGHT * house2HeightRatio);
                // 根據原始比例計算寬度
                house2Width = Math.floor(house2Height * originalRatio);
                
                console.log(`🎯 動態尺寸計算: 遊戲高度${GAME_HEIGHT} → house-2高度${house2Height}, 寬度${house2Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設房子寬高比為4:3
                house2Height = Math.floor(GAME_HEIGHT * house2HeightRatio);
                house2Width = Math.floor(house2Height * (4/3)); // 預設比例
                
                console.log(`⚠️ 使用預設比例: house-2高度${house2Height}, 寬度${house2Width}`);
            }
            
            // 設定house-2位置：底部對齊road-3的頂部，左邊與road-3左邊距離為25
            const house2LeftDistanceRatio = 25 / 512; // 25像素距離在512背景中的比例 (4.88%)
            const house2LeftDistance = Math.floor(GAME_HEIGHT * house2LeftDistanceRatio); // 使用背景高度計算距離
            const house2X = road3X + house2LeftDistance; // 右邊距離road-3右邊25像素
            const house2Y = road3Y - house2Height; // 底部對齊road-3頂部

            // 計算 house-3 元件尺寸
            let house3Width, house3Height;
            const house3HeightRatio = 211 / 512; // 211像素高度在512背景中的比例 (41.21%)

            if (roadOriginalSizes['house-3']) {
                const originalSize = roadOriginalSizes['house-3'];
                const originalRatio = originalSize.width / originalSize.height;

                // 根據當前遊戲高度計算 house-3 高度
                house3Height = Math.floor(GAME_HEIGHT * house3HeightRatio);
                // 根據原始比例計算寬度
                house3Width = Math.floor(house3Height * originalRatio);

                console.log(`🎯 動態尺寸計算: 遊戲高度${GAME_HEIGHT} → house-3高度${house3Height}, 寬度${house3Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 若無原始尺寸，使用預設 4:3 比例
                house3Height = Math.floor(GAME_HEIGHT * house3HeightRatio);
                house3Width = Math.floor(house3Height * (4 / 3));

                console.log(`⚠️ 使用預設比例: house-3高度${house3Height}, 寬度${house3Width}`);
            }

            // 計算位置：底部對齊 road-3 頂部，右邊與 road-3 右邊距離為 91（依背景高度等比例）
            const house3RightDistanceRatio = 91 / 512; // 17.77%
            const house3RightDistance = Math.floor(GAME_HEIGHT * house3RightDistanceRatio);
            const house3X = road3X + road3Width - house3Width - house3RightDistance;
            const house3Y = road3Y - house3Height;

            // 計算house-4尺寸
            let house4Width, house4Height;
            const house4HeightRatio = 180 / 512; // 180像素高度在512背景中的比例 (35.16%)
            
            if (roadOriginalSizes['house-4']) {
                const originalSize = roadOriginalSizes['house-4'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算house-4高度
                house4Height = Math.floor(GAME_HEIGHT * house4HeightRatio);
                // 根據原始比例計算寬度
                house4Width = Math.floor(house4Height * originalRatio);
                
                console.log(`🎯 House-4動態尺寸計算: 遊戲高度${GAME_HEIGHT} → house-4高度${house4Height}, 寬度${house4Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:3
                house4Height = Math.floor(GAME_HEIGHT * house4HeightRatio);
                house4Width = Math.floor(house4Height * (4/3)); // 預設比例
                
                console.log(`⚠️ House-4使用預設比例: 高度${house4Height}, 寬度${house4Width}`);
            }

            // 計算house-5尺寸
            let house5Width, house5Height;
            const house5HeightRatio = 232 / 512; // 232像素高度在512背景中的比例 (45.31%)
            
            if (roadOriginalSizes['house-5']) {
                const originalSize = roadOriginalSizes['house-5'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算house-5高度
                house5Height = Math.floor(GAME_HEIGHT * house5HeightRatio);
                // 根據原始比例計算寬度
                house5Width = Math.floor(house5Height * originalRatio);
                
                console.log(`🎯 House-5動態尺寸計算: 遊戲高度${GAME_HEIGHT} → house-5高度${house5Height}, 寬度${house5Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:3
                house5Height = Math.floor(GAME_HEIGHT * house5HeightRatio);
                house5Width = Math.floor(house5Height * (4/3)); // 預設比例
                
                console.log(`⚠️ House-5使用預設比例: 高度${house5Height}, 寬度${house5Width}`);
            }

            // house-4和house-5的位置计算将在road-4创建之后进行
            
            // 創建road元件
            world.roads = [
                {
                    x: roadX, 
                    y: roadY, 
                    width: roadWidth, 
                    height: roadHeight,
                    type: 'road-1'
                },
                {
                    x: kanbanX,
                    y: kanbanY,
                    width: kanbanWidth,
                    height: kanbanHeight,
                    type: 'road-kanban'
                },
                {
                    x: road2X,
                    y: road2Y,
                    width: road2Width,
                    height: road2Height,
                    type: 'road-2'
                },
                {
                    x: road3X,
                    y: road3Y,
                    width: road3Width,
                    height: road3Height,
                    type: 'road-3'
                },
                {
                    x: house1X,
                    y: house1Y,
                    width: house1Width,
                    height: house1Height,
                    type: 'house-1'
                },
                {
                    x: house2X,
                    y: house2Y,
                    width: house2Width,
                    height: house2Height,
                    type: 'house-2'
                },
                {
                    x: house3X,
                    y: house3Y,
                    width: house3Width,
                    height: house3Height,
                    type: 'house-3'
                }
            ];

            // 創建Cloud模組
            cloudManager.createClouds(road3X, road3Width, GAME_HEIGHT);

            // 創建三個階梯狀的road-mid
            const roadMidHeightRatio = 32 / 512; // 32像素高度在512背景中的比例 (6.25%)
            let roadMidWidth, roadMidHeight;
            
            if (roadOriginalSizes['road-mid']) {
                const originalSize = roadOriginalSizes['road-mid'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-mid高度
                roadMidHeight = Math.floor(GAME_HEIGHT * roadMidHeightRatio);
                // 根據原始比例計算寬度
                roadMidWidth = Math.floor(roadMidHeight * originalRatio);
                
                console.log(`🎯 Road-mid動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-mid高度${roadMidHeight}, 寬度${roadMidWidth} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:1
                roadMidHeight = Math.floor(GAME_HEIGHT * roadMidHeightRatio);
                roadMidWidth = Math.floor(roadMidHeight * 4); // 預設比例
                
                console.log(`⚠️ Road-mid使用預設比例: 高度${roadMidHeight}, 寬度${roadMidWidth}`);
            }

            // 計算距離比例
            const firstRoadMidBottomDistanceRatio = 127 / 512; // 127像素距離在512背景中的比例 (24.8%)
            const firstRoadMidLeftDistanceRatio = 94 / 512; // 94像素距離在512背景中的比例 (18.36%)
            const roadMidSpacingRatio = 16 / 512; // 16像素間距在512背景中的比例 (3.125%)
            const roadMidVerticalSpacingRatio = 32 / 512; // 32像素垂直間距在512背景中的比例 (6.25%)

            const firstRoadMidBottomDistance = Math.floor(GAME_HEIGHT * firstRoadMidBottomDistanceRatio);
            const firstRoadMidLeftDistance = Math.floor(GAME_HEIGHT * firstRoadMidLeftDistanceRatio);
            const roadMidSpacing = Math.floor(GAME_HEIGHT * roadMidSpacingRatio);
            const roadMidVerticalSpacing = Math.floor(GAME_HEIGHT * roadMidVerticalSpacingRatio);

            // 第一個road-mid位置
            const firstRoadMidX = road3X + road3Width + firstRoadMidLeftDistance;
            const firstRoadMidY = GAME_HEIGHT - firstRoadMidBottomDistance - roadMidHeight;

            // 第二個road-mid位置
            const secondRoadMidX = firstRoadMidX + roadMidWidth + roadMidSpacing;
            const secondRoadMidY = firstRoadMidY - roadMidVerticalSpacing - roadMidHeight;

            // 第三個road-mid位置
            const thirdRoadMidX = secondRoadMidX + roadMidWidth + roadMidSpacing;
            const thirdRoadMidY = secondRoadMidY - roadMidVerticalSpacing - roadMidHeight;

            // 添加三個road-mid到world.roads
            world.roads.push(
                {
                    x: firstRoadMidX,
                    y: firstRoadMidY,
                    width: roadMidWidth,
                    height: roadMidHeight,
                    type: 'road-mid'
                },
                {
                    x: secondRoadMidX,
                    y: secondRoadMidY,
                    width: roadMidWidth,
                    height: roadMidHeight,
                    type: 'road-mid'
                },
                {
                    x: thirdRoadMidX,
                    y: thirdRoadMidY,
                    width: roadMidWidth,
                    height: roadMidHeight,
                    type: 'road-mid'
                }
            );

            console.log('🏗️ 三個階梯狀road-mid創建完成:', world.roads.filter(r => r.type.includes('road-mid')));

            // 創建road-4
            const road4HeightRatio = 32 / 512; // 32像素高度在512背景中的比例，與road-3相同 (6.25%)
            let road4Width, road4Height;
            
            if (roadOriginalSizes['road-4']) {
                const originalSize = roadOriginalSizes['road-4'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-4高度
                road4Height = Math.floor(GAME_HEIGHT * road4HeightRatio);
                // 根據原始比例計算寬度
                road4Width = Math.floor(road4Height * originalRatio);
                
                console.log(`🎯 Road-4動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-4高度${road4Height}, 寬度${road4Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:1
                road4Height = Math.floor(GAME_HEIGHT * road4HeightRatio);
                road4Width = Math.floor(road4Height * 4); // 預設比例
                
                console.log(`⚠️ Road-4使用預設比例: 高度${road4Height}, 寬度${road4Width}`);
            }

            // 計算road-4位置
            const road4BottomDistanceRatio = 143 / 512; // 143像素距離在512背景中的比例 (27.93%)
            const road4LeftDistanceRatio = 40 / 512; // 40像素距離在512背景中的比例 (7.81%)
            
            const road4BottomDistance = Math.floor(GAME_HEIGHT * road4BottomDistanceRatio);
            const road4LeftDistance = Math.floor(GAME_HEIGHT * road4LeftDistanceRatio);
            
            // 找到最後一個road-mid（第三個）的位置
            const lastRoadMid = world.roads.find(road => road.type === 'road-mid' && road.x === thirdRoadMidX);
            const road4X = lastRoadMid.x + lastRoadMid.width + road4LeftDistance;
            const road4Y = GAME_HEIGHT - road4BottomDistance - road4Height;

            // 添加road-4到world.roads
            world.roads.push({
                x: road4X,
                y: road4Y,
                width: road4Width,
                height: road4Height,
                type: 'road-4'
            });

            console.log('🏗️ Road-4創建完成:', { x: road4X, y: road4Y, width: road4Width, height: road4Height });

            // 現在創建house-4和house-5（在road-4創建之後）
            const house4LeftDistanceRatio = 83 / 512; // 83像素距離在512背景中的比例 (16.21%)
            const house5LeftGapRatio = 104 / 512; // 104像素距離在512背景中的比例 (20.31%)
            
            const house4LeftDistance = Math.floor(GAME_HEIGHT * house4LeftDistanceRatio);
            const house5LeftGap = Math.floor(GAME_HEIGHT * house5LeftGapRatio);
            
            const house4X = road4X + house4LeftDistance; // house-4左邊與road-4左邊距離83像素
            const house4Y = road4Y - house4Height; // house-4底部貼齊road-4頂部
            
            const house5X = house4X + house4Width + house5LeftGap; // house-5左邊與house-4右邊距離104像素
            const house5Y = road4Y - house5Height; // house-5底部貼齊road-4頂部

            // 將house-4和house-5添加到world.roads
            world.roads.push(
                {
                    x: house4X,
                    y: house4Y,
                    width: house4Width,
                    height: house4Height,
                    type: 'house-4'
                },
                {
                    x: house5X,
                    y: house5Y,
                    width: house5Width,
                    height: house5Height,
                    type: 'house-5'
                }
            );

            console.log('🏠 House-4創建完成:', { x: house4X, y: house4Y, width: house4Width, height: house4Height });
            console.log('🏠 House-5創建完成:', { x: house5X, y: house5Y, width: house5Width, height: house5Height });
            
            // 設置玩家初始位置在road-1元件上方
            player.x = roadX + 50; // 在road-1左側一點
            player.y = roadY - player.height; // 站在road-1上方
            
            // 清空所有舊的HP Logo
            hpLogoManager.clear();
            
            // 創建road-2右邊的4個HP Logo（水平排列）
            const hpLogoLeftDistanceRatio = 15 / 512; // 15像素距離在512背景中的比例 (2.93%)
            const hpLogoBottomDistanceRatio = 121 / 512; // 121像素距離在512背景中的比例 (23.63%)
            const hpLogoSpacingRatio = 8 / 512; // 8像素間距在512背景中的比例 (1.56%)
            
            const hpLogoLeftDistance = Math.floor(GAME_HEIGHT * hpLogoLeftDistanceRatio);
            const hpLogoBottomDistance = Math.floor(GAME_HEIGHT * hpLogoBottomDistanceRatio);
            const hpLogoSpacing = Math.floor(GAME_HEIGHT * hpLogoSpacingRatio);
            
            const road2 = world.roads.find(road => road.type === 'road-2');
            const firstHpLogoX = road2.x + hpLogoLeftDistance;
            const firstHpLogoY = road2.y - hpLogoBottomDistance - Math.floor(GAME_HEIGHT * (41 / 512)); // 動態計算高度
            
            hpLogoManager.createHorizontalHpLogos(firstHpLogoX, firstHpLogoY, 4, hpLogoSpacing, GAME_HEIGHT);
            
            // 清空所有舊的彈簧
            springManager.clear();
            
            // 使用Spring模組創建彈簧
            const springLeftDistanceRatio = 40 / 512;
            const springLeftDistance = Math.floor(GAME_HEIGHT * springLeftDistanceRatio);
            
            const road3 = world.roads.find(road => road.type === 'road-3');
            const house2 = world.roads.find(road => road.type === 'house-2');
            const springX = house2.x + house2.width + springLeftDistance;
            
            // 先創建彈簧，讓它自動計算Y位置
            const spring = springManager.createSpring(springX, 0, player.width);
            spring.y = road3.y - spring.height; // 底部對齊road-3頂部
            
            // 創建spring上方的3個HP Logo（垂直排列）
            if (spring) {
                const springBottomDistanceRatio = 94 / 512; // 94像素距離在512背景中的比例
                const springBottomDistance = Math.floor(GAME_HEIGHT * springBottomDistanceRatio);
                const verticalSpacing = Math.floor(GAME_HEIGHT * hpLogoSpacingRatio); // 8像素間距
                
                // spring中心X位置
                const springCenterX = spring.x + Math.floor(spring.width / 2);
                // 第一個HP Logo的底部Y位置（spring頂部上方94像素）
                const firstVerticalHpLogoBottomY = spring.y - springBottomDistance;
                
                hpLogoManager.createVerticalHpLogos(springCenterX, firstVerticalHpLogoBottomY, 3, verticalSpacing, GAME_HEIGHT);
            }

            // 在每個road-mid上方創建HP Logo
            const roadMids = world.roads.filter(road => road.type.includes('road-mid'));
            roadMids.forEach((roadMid, index) => {
                // 計算HP Logo的中心X位置（與road-mid垂直置中）
                const hpLogoCenterX = roadMid.x + Math.floor(roadMid.width / 2);
                // HP Logo底部貼齊road-mid頂部
                const hpLogoBottomY = roadMid.y;
                
                // 為每個road-mid創建一個HP Logo
                hpLogoManager.createVerticalHpLogos(hpLogoCenterX, hpLogoBottomY, 1, 0, GAME_HEIGHT);
                
                console.log(`🩹 在road-mid-${index + 1}上方創建HP Logo，位置: (${hpLogoCenterX}, ${hpLogoBottomY})`);
            });

            // 在road-4上創建5個HP Logo（水平排列）
            const road4HpLogoLeftDistanceRatio = 172 / 512; // 172像素距離在512背景中的比例 (33.59%)
            const road4HpLogoLeftDistance = Math.floor(GAME_HEIGHT * road4HpLogoLeftDistanceRatio);
            const road4HpLogoSpacing = Math.floor(GAME_HEIGHT * hpLogoSpacingRatio); // 8像素間距
            
            const firstRoad4HpLogoX = road4X + road4HpLogoLeftDistance; // 第一個HP Logo左邊與road-4左邊距離172像素
            const firstRoad4HpLogoY = road4Y - Math.floor(GAME_HEIGHT * (41 / 512)); // HP Logo底部貼齊road-4頂部
            
            hpLogoManager.createHorizontalHpLogos(firstRoad4HpLogoX, firstRoad4HpLogoY, 5, road4HpLogoSpacing, GAME_HEIGHT);
            
            console.log('🩹 在road-4上創建5個HP Logo完成，位置:', { x: firstRoad4HpLogoX, y: firstRoad4HpLogoY });

            // 創建5個road-short-1（掉落平台）
            const roadShort1HeightRatio = 21 / 512; // 21像素高度在512背景中的比例 (4.10%)
            let roadShort1Width, roadShort1Height;
            
            if (roadOriginalSizes['road-short-1']) {
                const originalSize = roadOriginalSizes['road-short-1'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-short-1高度
                roadShort1Height = Math.floor(GAME_HEIGHT * roadShort1HeightRatio);
                // 根據原始比例計算寬度
                roadShort1Width = Math.floor(roadShort1Height * originalRatio);
                
                console.log(`🎯 Road-short-1動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-short-1高度${roadShort1Height}, 寬度${roadShort1Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為3:1
                roadShort1Height = Math.floor(GAME_HEIGHT * roadShort1HeightRatio);
                roadShort1Width = Math.floor(roadShort1Height * 3); // 預設比例
                
                console.log(`⚠️ Road-short-1使用預設比例: 高度${roadShort1Height}, 寬度${roadShort1Width}`);
            }

            // 計算road-short-1位置
            const roadShort1LeftDistanceRatio = 24 / 512; // 24像素距離在512背景中的比例 (4.69%)
            const roadShort1SpacingRatio = 40 / 512; // 40像素間距在512背景中的比例 (7.81%)
            
            const roadShort1LeftDistance = Math.floor(GAME_HEIGHT * roadShort1LeftDistanceRatio);
            const roadShort1Spacing = Math.floor(GAME_HEIGHT * roadShort1SpacingRatio);
            
            // 第一個road-short-1位置
            const firstRoadShort1X = road4X + road4Width + roadShort1LeftDistance; // road-short-1左邊與road-4右邊距離24像素
            const firstRoadShort1Y = road4Y; // road-short-1頂部與road-4頂部貼齊

            // 創建5個road-short-1並添加到world.roads
            for (let i = 0; i < 5; i++) {
                world.roads.push({
                    x: firstRoadShort1X + i * (roadShort1Width + roadShort1Spacing),
                    y: firstRoadShort1Y,
                    width: roadShort1Width,
                    height: roadShort1Height,
                    type: 'road-short-1',
                    id: `road-short-1-${i + 1}`,
                    isFalling: false,
                    fallStartTime: 0,
                    fallDuration: 1000, // 1秒後掉落
                    originalY: firstRoadShort1Y
                });
            }

            console.log('🏗️ 5個road-short-1創建完成:', world.roads.filter(r => r.type === 'road-short-1'));

            // 創建road-5
            const road5HeightRatio = 32 / 512; // 32像素高度在512背景中的比例，與road-3和road-4相同 (6.25%)
            let road5Width, road5Height;
            
            if (roadOriginalSizes['road-5']) {
                const originalSize = roadOriginalSizes['road-5'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-5高度
                road5Height = Math.floor(GAME_HEIGHT * road5HeightRatio);
                // 根據原始比例計算寬度
                road5Width = Math.floor(road5Height * originalRatio);
                
                console.log(`🎯 Road-5動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-5高度${road5Height}, 寬度${road5Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:1
                road5Height = Math.floor(GAME_HEIGHT * road5HeightRatio);
                road5Width = Math.floor(road5Height * 4); // 預設比例
                
                console.log(`⚠️ Road-5使用預設比例: 高度${road5Height}, 寬度${road5Width}`);
            }

            // 計算road-5位置
            const road5BottomDistanceRatio = 58 / 512; // 58像素距離在512背景中的比例 (11.33%)
            const road5LeftDistanceRatio = 24 / 512; // 24像素距離在512背景中的比例 (4.69%)
            
            const road5BottomDistance = Math.floor(GAME_HEIGHT * road5BottomDistanceRatio);
            const road5LeftDistance = Math.floor(GAME_HEIGHT * road5LeftDistanceRatio);
            
            // 找到最後一個road-short-1的位置
            const lastRoadShort1 = world.roads.find(road => road.type === 'road-short-1' && road.id === 'road-short-1-5');
            const road5X = lastRoadShort1.x + lastRoadShort1.width + road5LeftDistance;
            const road5Y = GAME_HEIGHT - road5BottomDistance - road5Height;

            // 添加road-5到world.roads
            world.roads.push({
                x: road5X,
                y: road5Y,
                width: road5Width,
                height: road5Height,
                type: 'road-5'
            });

            console.log('🏗️ Road-5創建完成:', { x: road5X, y: road5Y, width: road5Width, height: road5Height });

            // 創建house-6
            const house6HeightRatio = 210 / 512; // 210像素高度在512背景中的比例 (41.02%)
            let house6Width, house6Height;
            
            if (roadOriginalSizes['house-6']) {
                const originalSize = roadOriginalSizes['house-6'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算house-6高度
                house6Height = Math.floor(GAME_HEIGHT * house6HeightRatio);
                // 根據原始比例計算寬度
                house6Width = Math.floor(house6Height * originalRatio);
                
                console.log(`🎯 House-6動態尺寸計算: 遊戲高度${GAME_HEIGHT} → house-6高度${house6Height}, 寬度${house6Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:3
                house6Height = Math.floor(GAME_HEIGHT * house6HeightRatio);
                house6Width = Math.floor(house6Height * (4/3)); // 預設比例
                
                console.log(`⚠️ House-6使用預設比例: 高度${house6Height}, 寬度${house6Width}`);
            }

            // 計算house-6位置
            const house6LeftDistanceRatio = 50 / 512; // 50像素距離在512背景中的比例 (9.77%)
            const house6LeftDistance = Math.floor(GAME_HEIGHT * house6LeftDistanceRatio);
            
            const house6X = road5X + house6LeftDistance; // house-6左邊與road-5左邊距離50像素
            const house6Y = road5Y - house6Height; // house-6底部對齊road-5頂部

            // 添加house-6到world.roads
            world.roads.push({
                x: house6X,
                y: house6Y,
                width: house6Width,
                height: house6Height,
                type: 'house-6'
            });

            console.log('🏠 House-6創建完成:', { x: house6X, y: house6Y, width: house6Width, height: house6Height });

            // 使用Spring模組創建第二個彈簧
            const spring2LeftDistanceRatio = 108 / 512; // 108像素距離在512背景中的比例 (21.09%)
            const spring2LeftDistance = Math.floor(GAME_HEIGHT * spring2LeftDistanceRatio);
            
            const spring2X = house6X + house6Width + spring2LeftDistance; // spring左邊距離house-6右邊108像素
            const spring2 = springManager.createSpring(spring2X, 0, player.width);
            spring2.y = road5Y - spring2.height; // spring底部貼齊road-5頂部
            
            console.log('🏃‍♂️ 第二個Spring創建完成:', { x: spring2X, y: spring2.y, width: spring2.width, height: spring2.height });

            // 在第二個spring上方創建3x3九宮格HP Logo
            const hpLogoGridTopDistanceRatio = 96 / 512; // 96像素距離在512背景中的比例 (18.75%)
            const hpLogoGridSpacingRatio = 8 / 512; // 8像素間距在512背景中的比例 (1.56%)
            
            const hpLogoGridTopDistance = Math.floor(GAME_HEIGHT * hpLogoGridTopDistanceRatio);
            const hpLogoGridSpacing = Math.floor(GAME_HEIGHT * hpLogoGridSpacingRatio);
            
            // 計算九宮格的中心X位置（與spring垂直置中）
            const spring2CenterX = spring2X + Math.floor(spring2.width / 2);
            
            // 計算第一個HP Logo的位置（九宮格左上角）
            const hpLogoHeightRatio = 41 / 512; // 41像素高度在512背景中的比例
            const hpLogoHeight = Math.floor(GAME_HEIGHT * hpLogoHeightRatio);
            
            // 根據圖片實際比例計算寬度，如果沒有則假設為正方形
            let hpLogoWidth;
            if (hpLogoManager.image && hpLogoManager.image.complete && hpLogoManager.image.naturalWidth > 0) {
                const originalRatio = hpLogoManager.image.naturalWidth / hpLogoManager.image.naturalHeight;
                hpLogoWidth = Math.floor(hpLogoHeight * originalRatio);
            } else {
                hpLogoWidth = hpLogoHeight; // 預設為正方形
            }
            
            // 計算九宮格的總寬度和高度
            const gridWidth = (hpLogoWidth * 3) + (hpLogoGridSpacing * 2); // 3個HP Logo + 2個間距
            const gridHeight = (hpLogoHeight * 3) + (hpLogoGridSpacing * 2); // 3個HP Logo + 2個間距
            
            // 計算第一個HP Logo的位置（九宮格左上角）
            const gridFirstHpLogoX = spring2CenterX - Math.floor(gridWidth / 2);
            const gridFirstHpLogoY = spring2.y - hpLogoGridTopDistance - gridHeight; // 距離spring頂部96像素
            
            // 創建3x3九宮格HP Logo
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const hpLogoX = gridFirstHpLogoX + col * (hpLogoWidth + hpLogoGridSpacing);
                    const hpLogoY = gridFirstHpLogoY + row * (hpLogoHeight + hpLogoGridSpacing);
                    
                    hpLogoManager.hpLogos.push({
                        x: hpLogoX,
                        y: hpLogoY,
                        width: hpLogoWidth,
                        height: hpLogoHeight,
                        collected: false,
                        id: `grid_${row}_${col}`,
                        type: 'grid'
                    });
                }
            }
            
            console.log('🩹 3x3九宮格HP Logo創建完成，位置:', { 
                centerX: spring2CenterX, 
                firstX: gridFirstHpLogoX, 
                firstY: gridFirstHpLogoY,
                spacing: hpLogoGridSpacing,
                totalCount: hpLogoManager.hpLogos.length
            });

            // 創建house-7
            const house7HeightRatio = 233 / 512; // 233像素高度在512背景中的比例 (45.51%)
            let house7Width, house7Height;
            
            if (roadOriginalSizes['house-7']) {
                const originalSize = roadOriginalSizes['house-7'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算house-7高度
                house7Height = Math.floor(GAME_HEIGHT * house7HeightRatio);
                // 根據原始比例計算寬度
                house7Width = Math.floor(house7Height * originalRatio);
                
                console.log(`🎯 House-7動態尺寸計算: 遊戲高度${GAME_HEIGHT} → house-7高度${house7Height}, 寬度${house7Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:3
                house7Height = Math.floor(GAME_HEIGHT * house7HeightRatio);
                house7Width = Math.floor(house7Height * (4/3)); // 預設比例
                
                console.log(`⚠️ House-7使用預設比例: 高度${house7Height}, 寬度${house7Width}`);
            }

            // 計算house-7位置
            const house7LeftDistanceRatio = 108 / 512; // 108像素距離在512背景中的比例 (21.09%)
            const house7LeftDistance = Math.floor(GAME_HEIGHT * house7LeftDistanceRatio);
            
            const house7X = spring2X + spring2.width + house7LeftDistance; // house-7左邊與spring右邊距離108像素
            const house7Y = road5Y - house7Height; // house-7底部對齊road-5頂部

            // 添加house-7到world.roads
            world.roads.push({
                x: house7X,
                y: house7Y,
                width: house7Width,
                height: house7Height,
                type: 'house-7'
            });

            console.log('🏠 House-7創建完成:', { x: house7X, y: house7Y, width: house7Width, height: house7Height });

            // 創建CloudManager2的cloud（House-7版本）
            cloudManager2.createClouds(house7X, house7Width, GAME_HEIGHT);

            // 創建road-7
            const road7HeightRatio = 32 / 512; // 32像素高度在512背景中的比例，與road-5相同 (6.25%)
            let road7Width, road7Height;
            
            if (roadOriginalSizes['road-7']) {
                const originalSize = roadOriginalSizes['road-7'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-7高度
                road7Height = Math.floor(GAME_HEIGHT * road7HeightRatio);
                // 根據原始比例計算寬度
                road7Width = Math.floor(road7Height * originalRatio);
                
                console.log(`🎯 Road-7動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-7高度${road7Height}, 寬度${road7Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:1
                road7Height = Math.floor(GAME_HEIGHT * road7HeightRatio);
                road7Width = Math.floor(road7Height * 4); // 預設比例
                
                console.log(`⚠️ Road-7使用預設比例: 高度${road7Height}, 寬度${road7Width}`);
            }

            // 計算road-7位置
            const road7BottomDistanceRatio = 120 / 512; // 120像素距離在512背景中的比例 (23.44%)
            const road7LeftDistanceRatio = 68 / 512; // 68像素距離在512背景中的比例 (13.28%)
            
            const road7BottomDistance = Math.floor(GAME_HEIGHT * road7BottomDistanceRatio);
            const road7LeftDistance = Math.floor(GAME_HEIGHT * road7LeftDistanceRatio);
            
            // road-7底部對齊背景底部距離120像素，左邊對齊road-5右邊距離68像素
            const road7X = road5X + road5Width + road7LeftDistance; // road-7左邊與road-5右邊距離68像素
            const road7Y = GAME_HEIGHT - road7BottomDistance - road7Height; // road-7底部距離背景底部120像素

            // 添加road-7到world.roads
            world.roads.push({
                x: road7X,
                y: road7Y,
                width: road7Width,
                height: road7Height,
                type: 'road-7'
            });

            console.log('🏗️ Road-7創建完成:', { x: road7X, y: road7Y, width: road7Width, height: road7Height });

            // 創建road-8
            const road8HeightRatio = 32 / 512; // 32像素高度在512背景中的比例，與road-5相同 (6.25%)
            let road8Width, road8Height;
            
            if (roadOriginalSizes['road-8']) {
                const originalSize = roadOriginalSizes['road-8'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-8高度
                road8Height = Math.floor(GAME_HEIGHT * road8HeightRatio);
                // 根據原始比例計算寬度
                road8Width = Math.floor(road8Height * originalRatio);
                
                console.log(`🎯 Road-8動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-8高度${road8Height}, 寬度${road8Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:1
                road8Height = Math.floor(GAME_HEIGHT * road8HeightRatio);
                road8Width = Math.floor(road8Height * 4); // 預設比例
                
                console.log(`⚠️ Road-8使用預設比例: 高度${road8Height}, 寬度${road8Width}`);
            }

            // 計算road-8位置
            const road8LeftDistanceRatio = 68 / 512; // 68像素距離在512背景中的比例 (13.28%)
            
            const road8LeftDistance = Math.floor(GAME_HEIGHT * road8LeftDistanceRatio);
            
            // road-8頂部對齊road-5頂部，左邊對齊road-7右邊距離68像素
            const road8X = road7X + road7Width + road8LeftDistance; // road-8左邊與road-7右邊距離68像素
            const road8Y = road5Y; // road-8頂部對齊road-5頂部

            // 添加road-8到world.roads
            world.roads.push({
                x: road8X,
                y: road8Y,
                width: road8Width,
                height: road8Height,
                type: 'road-8'
            });

            console.log('🏗️ Road-8創建完成:', { x: road8X, y: road8Y, width: road8Width, height: road8Height });

            // 創建第一組水平排列的HP Logo（3個，與road-7垂直排列）
            const road7HpLogoSpacingRatio = 8 / 512; // 8像素間距在512背景中的比例 (1.56%)
            const road7HpLogoBottomDistanceRatio = 160 / 512; // 124像素距離在512背景中的比例 (24.22%)
            
            const road7HpLogoSpacing = Math.floor(GAME_HEIGHT * road7HpLogoSpacingRatio);
            const road7HpLogoBottomDistance = Math.floor(GAME_HEIGHT * road7HpLogoBottomDistanceRatio);
            
            // 計算第一組HP Logo的位置（與road-7垂直排列）
            const road7CenterX = road7X + Math.floor(road7Width / 2); // road-7中心X位置
            const road7HpLogoBottomY = road7Y - road7HpLogoBottomDistance; // HP Logo底部位置
            
            // 計算第一組HP Logo的起始X位置（置中排列）
            const road7HpLogoHeightRatio = 41 / 512; // 41像素高度在512背景中的比例
            const road7HpLogoHeight = Math.floor(GAME_HEIGHT * road7HpLogoHeightRatio);
            const road7HpLogoWidth = road7HpLogoHeight; // 假設為正方形
            const road7HpLogosTotalWidth = (road7HpLogoWidth * 3) + (road7HpLogoSpacing * 2); // 3個HP Logo + 2個間距
            const road7HpLogoStartX = road7CenterX - Math.floor(road7HpLogosTotalWidth / 2); // 置中排列的起始X位置
            
            // 創建第一組3個水平排列的HP Logo
            hpLogoManager.createHorizontalHpLogos(road7HpLogoStartX, road7HpLogoBottomY, 3, road7HpLogoSpacing, GAME_HEIGHT);
            
            console.log('🩹 第一組HP Logo創建完成（3個，與road-7垂直排列）');

            // 創建第二組水平排列的HP Logo（6個，在road-8上方）
            const road8HpLogoSpacingRatio = 8 / 512; // 8像素間距在512背景中的比例 (1.56%)
            const road8HpLogoLeftDistanceRatio = 78 / 512; // 78像素距離在512背景中的比例 (15.23%)
            
            const road8HpLogoSpacing = Math.floor(GAME_HEIGHT * road8HpLogoSpacingRatio);
            const road8HpLogoLeftDistance = Math.floor(GAME_HEIGHT * road8HpLogoLeftDistanceRatio);
            
            // 計算第二組HP Logo的位置（在road-8上方）
            const road8HpLogoX = road8X + road8HpLogoLeftDistance; // HP Logo左邊位置
            const road8HpLogoHeightRatio = 41 / 512; // 41像素高度在512背景中的比例
            const road8HpLogoHeight = Math.floor(GAME_HEIGHT * road8HpLogoHeightRatio);
            const road8HpLogoY = road8Y - road8HpLogoHeight; // HP Logo底部與road-8頂部貼齊
            
            // 創建第二組6個水平排列的HP Logo
            hpLogoManager.createHorizontalHpLogos(road8HpLogoX, road8HpLogoY, 6, road8HpLogoSpacing, GAME_HEIGHT);
            
            console.log('🩹 第二組HP Logo創建完成（6個，在road-8上方）');

            // 創建house-8
            const house8HeightRatio = 162 / 512; // 162像素高度在512背景中的比例 (31.64%)
            let house8Width, house8Height;
            
            if (roadOriginalSizes['house-8']) {
                const originalSize = roadOriginalSizes['house-8'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算house-8高度
                house8Height = Math.floor(GAME_HEIGHT * house8HeightRatio);
                // 根據原始比例計算寬度
                house8Width = Math.floor(house8Height * originalRatio);
                
                console.log(`🎯 House-8動態尺寸計算: 遊戲高度${GAME_HEIGHT} → house-8高度${house8Height}, 寬度${house8Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:3
                house8Height = Math.floor(GAME_HEIGHT * house8HeightRatio);
                house8Width = Math.floor(house8Height * (4/3)); // 預設比例
                
                console.log(`⚠️ House-8使用預設比例: 高度${house8Height}, 寬度${house8Width}`);
            }

            // 計算house-8位置
            const house8LeftDistanceRatio = 170 / 512; // 170像素距離在512背景中的比例 (33.20%)
            const house8LeftDistance = Math.floor(GAME_HEIGHT * house8LeftDistanceRatio);
            
            const house8X = road8X + house8LeftDistance; // house-8左邊與road-8左邊距離170像素
            const house8Y = road8Y - house8Height; // house-8底部對齊road-8頂部

            // 添加house-8到world.roads
            world.roads.push({
                x: house8X,
                y: house8Y,
                width: house8Width,
                height: house8Height,
                type: 'house-8'
            });

            console.log('🏠 House-8創建完成:', { x: house8X, y: house8Y, width: house8Width, height: house8Height });

            // 使用Spring模組創建第三個彈簧
            const spring3LeftDistanceRatio = 132 / 512; // 132像素距離在512背景中的比例 (25.78%)
            const spring3LeftDistance = Math.floor(GAME_HEIGHT * spring3LeftDistanceRatio);
            
            const spring3X = house8X + house8Width + spring3LeftDistance; // spring左邊與house-8右邊距離132像素
            const spring3 = springManager.createSpring(spring3X, 0, player.width);
            spring3.y = road8Y - spring3.height; // spring底部對齊road-8頂部
            
            console.log('🏃‍♂️ 第三個Spring創建完成:', { x: spring3X, y: spring3.y, width: spring3.width, height: spring3.height });

            // 創建bridge-1
            const bridge1HeightRatio = 122 / 512; // 122像素高度在512背景中的比例 (23.83%)
            let bridge1Width, bridge1Height;
            
            if (roadOriginalSizes['bridge-1']) {
                const originalSize = roadOriginalSizes['bridge-1'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算bridge-1高度
                bridge1Height = Math.floor(GAME_HEIGHT * bridge1HeightRatio);
                // 根據原始比例計算寬度
                bridge1Width = Math.floor(bridge1Height * originalRatio);
                
                console.log(`🎯 Bridge-1動態尺寸計算: 遊戲高度${GAME_HEIGHT} → bridge-1高度${bridge1Height}, 寬度${bridge1Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:1
                bridge1Height = Math.floor(GAME_HEIGHT * bridge1HeightRatio);
                bridge1Width = Math.floor(bridge1Height * 4); // 預設比例
                
                console.log(`⚠️ Bridge-1使用預設比例: 高度${bridge1Height}, 寬度${bridge1Width}`);
            }

            // 計算bridge-1位置
            const bridge1LeftDistanceRatio = 24 / 512; // 24像素距離在512背景中的比例 (4.69%)
            const bridge1LeftDistance = Math.floor(GAME_HEIGHT * bridge1LeftDistanceRatio);
            
            const bridge1X = spring3X + spring3.width + bridge1LeftDistance; // bridge-1左邊與spring右邊距離24像素
            const bridge1Y = road8Y - bridge1Height; // bridge-1底部對齊road-8頂部

            // 添加bridge-1到world.roads
            world.roads.push({
                x: bridge1X,
                y: bridge1Y,
                width: bridge1Width,
                height: bridge1Height,
                type: 'bridge-1'
            });

            console.log('🌉 Bridge-1創建完成:', { x: bridge1X, y: bridge1Y, width: bridge1Width, height: bridge1Height });

            // 創建8個road-short-2（掉落平台）
            const roadShort2HeightRatio = 21 / 512; // 21像素高度在512背景中的比例 (4.10%)
            let roadShort2Width, roadShort2Height;
            
            if (roadOriginalSizes['road-short-2']) {
                const originalSize = roadOriginalSizes['road-short-2'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-short-2高度
                roadShort2Height = Math.floor(GAME_HEIGHT * roadShort2HeightRatio);
                // 根據原始比例計算寬度
                roadShort2Width = Math.floor(roadShort2Height * originalRatio);
                
                console.log(`🎯 Road-short-2動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-short-2高度${roadShort2Height}, 寬度${roadShort2Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:1
                roadShort2Height = Math.floor(GAME_HEIGHT * roadShort2HeightRatio);
                roadShort2Width = Math.floor(roadShort2Height * 4); // 預設比例
                
                console.log(`⚠️ Road-short-2使用預設比例: 高度${roadShort2Height}, 寬度${roadShort2Width}`);
            }

            // 計算road-short-2位置
            const roadShort2LeftDistanceRatio = 24 / 512; // 24像素距離在512背景中的比例 (4.69%)
            const roadShort2SpacingRatio = 40 / 512; // 40像素間距在512背景中的比例 (7.81%)
            
            const roadShort2LeftDistance = Math.floor(GAME_HEIGHT * roadShort2LeftDistanceRatio);
            const roadShort2Spacing = Math.floor(GAME_HEIGHT * roadShort2SpacingRatio);
            
            // 第一個road-short-2位置
            const firstRoadShort2X = bridge1X + bridge1Width + roadShort2LeftDistance; // road-short-2左邊與bridge-1右邊距離24像素
            const firstRoadShort2Y = bridge1Y; // road-short-2頂部與bridge-1頂部貼齊
            
            // 創建8個road-short-2並添加到world.roads
            for (let i = 0; i < 8; i++) {
                const roadShort2X = firstRoadShort2X + i * (roadShort2Width + roadShort2Spacing);
                const roadShort2Y = firstRoadShort2Y;
                
                world.roads.push({
                    x: roadShort2X,
                    y: roadShort2Y,
                    width: roadShort2Width,
                    height: roadShort2Height,
                    type: 'road-short-2',
                    id: `road-short-2-${i + 1}`,
                    isFalling: false,
                    fallStartTime: null,
                    fallDuration: 1000, // 1秒掉落時間
                    originalY: roadShort2Y // 記錄原始Y位置
                });
            }
            
            console.log('🏗️ 8個road-short-2創建完成:', world.roads.filter(r => r.type === 'road-short-2'));

            // 創建bridge-2
            const bridge2HeightRatio = 122 / 512; // 122像素高度在512背景中的比例 (23.83%)
            let bridge2Width, bridge2Height;
            
            if (roadOriginalSizes['bridge-2']) {
                const originalSize = roadOriginalSizes['bridge-2'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算bridge-2高度
                bridge2Height = Math.floor(GAME_HEIGHT * bridge2HeightRatio);
                // 根據原始比例計算寬度
                bridge2Width = Math.floor(bridge2Height * originalRatio);
                
                console.log(`🎯 Bridge-2動態尺寸計算: 遊戲高度${GAME_HEIGHT} → bridge-2高度${bridge2Height}, 寬度${bridge2Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:1
                bridge2Height = Math.floor(GAME_HEIGHT * bridge2HeightRatio);
                bridge2Width = Math.floor(bridge2Height * 4); // 預設比例
                
                console.log(`⚠️ Bridge-2使用預設比例: 高度${bridge2Height}, 寬度${bridge2Width}`);
            }

            // 計算bridge-2位置
            const bridge2LeftDistanceRatio = 24 / 512; // 24像素距離在512背景中的比例 (4.69%)
            const bridge2LeftDistance = Math.floor(GAME_HEIGHT * bridge2LeftDistanceRatio);
            
            // 找到最後一個road-short-2的位置
            const lastRoadShort2 = world.roads.find(road => road.type === 'road-short-2' && road.id === 'road-short-2-8');
            const bridge2X = lastRoadShort2.x + lastRoadShort2.width + bridge2LeftDistance; // bridge-2左邊與最後一個road-short-2右邊距離24像素
            const bridge2Y = lastRoadShort2.y; // bridge-2頂部對齊road-short-2的頂部

            // 添加bridge-2到world.roads
            world.roads.push({
                x: bridge2X,
                y: bridge2Y,
                width: bridge2Width,
                height: bridge2Height,
                type: 'bridge-2'
            });

            console.log('🌉 Bridge-2創建完成:', { x: bridge2X, y: bridge2Y, width: bridge2Width, height: bridge2Height });

            // 創建road-9
            const road9HeightRatio = 32 / 512; // 32像素高度在512背景中的比例，與road-5相同 (6.25%)
            let road9Width, road9Height;
            
            if (roadOriginalSizes['road-9']) {
                const originalSize = roadOriginalSizes['road-9'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算road-9高度
                road9Height = Math.floor(GAME_HEIGHT * road9HeightRatio);
                // 根據原始比例計算寬度
                road9Width = Math.floor(road9Height * originalRatio);
                
                console.log(`🎯 Road-9動態尺寸計算: 遊戲高度${GAME_HEIGHT} → road-9高度${road9Height}, 寬度${road9Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:1
                road9Height = Math.floor(GAME_HEIGHT * road9HeightRatio);
                road9Width = Math.floor(road9Height * 4); // 預設比例
                
                console.log(`⚠️ Road-9使用預設比例: 高度${road9Height}, 寬度${road9Width}`);
            }

            // 計算road-9位置
            const road9LeftDistanceRatio = 49 / 512; // 49像素距離在512背景中的比例 (9.57%)
            const road9LeftDistance = Math.floor(GAME_HEIGHT * road9LeftDistanceRatio);
            
            const road9X = bridge2X + road9LeftDistance; // road-9左邊與bridge-2左邊距離49像素
            const road9Y = bridge2Y + bridge2Height; // road-9頂部對齊bridge-2底部

            // 添加road-9到world.roads
            world.roads.push({
                x: road9X,
                y: road9Y,
                width: road9Width,
                height: road9Height,
                type: 'road-9'
            });

            console.log('🏗️ Road-9創建完成:', { x: road9X, y: road9Y, width: road9Width, height: road9Height });

            // 創建一組水平排列的HP Logo（3個）
            const road9HpLogoSpacingRatio = 8 / 512; // 8像素間距在512背景中的比例 (1.56%)
            const road9HpLogoLeftDistanceRatio = 110 / 512; // 110像素距離在512背景中的比例 (21.48%)
            
            const road9HpLogoSpacing = Math.floor(GAME_HEIGHT * road9HpLogoSpacingRatio);
            const road9HpLogoLeftDistance = Math.floor(GAME_HEIGHT * road9HpLogoLeftDistanceRatio);
            
            // 計算HP Logo的位置
            const road9HpLogoX = bridge2X + bridge2Width + road9HpLogoLeftDistance; // HP Logo左邊與bridge-2右邊距離110像素
            const road9HpLogoHeightRatio = 41 / 512; // 41像素高度在512背景中的比例
            const road9HpLogoHeight = Math.floor(GAME_HEIGHT * road9HpLogoHeightRatio);
            const road9HpLogoY = road9Y - road9HpLogoHeight; // HP Logo底部與road-9頂部貼齊
            
            // 創建3個水平排列的HP Logo
            hpLogoManager.createHorizontalHpLogos(road9HpLogoX, road9HpLogoY, 3, road9HpLogoSpacing, GAME_HEIGHT);
            
            console.log('🩹 Road-9上方HP Logo創建完成（3個）');

            // 創建laboratory-1
            const laboratory1HeightRatio = 209 / 512; // 209像素高度在512背景中的比例 (40.82%)
            let laboratory1Width, laboratory1Height;
            
            if (roadOriginalSizes['laboratory-1']) {
                const originalSize = roadOriginalSizes['laboratory-1'];
                const originalRatio = originalSize.width / originalSize.height;
                
                // 根據當前遊戲高度計算laboratory-1高度
                laboratory1Height = Math.floor(GAME_HEIGHT * laboratory1HeightRatio);
                // 根據原始比例計算寬度
                laboratory1Width = Math.floor(laboratory1Height * originalRatio);
                
                console.log(`🎯 Laboratory-1動態尺寸計算: 遊戲高度${GAME_HEIGHT} → laboratory-1高度${laboratory1Height}, 寬度${laboratory1Width} (原始比例${originalRatio.toFixed(2)})`);
            } else {
                // 如果沒有原始尺寸，使用預設比例，假設寬高比為4:3
                laboratory1Height = Math.floor(GAME_HEIGHT * laboratory1HeightRatio);
                laboratory1Width = Math.floor(laboratory1Height * (4/3)); // 預設比例
                
                console.log(`⚠️ Laboratory-1使用預設比例: 高度${laboratory1Height}, 寬度${laboratory1Width}`);
            }

            // 計算laboratory-1位置
            const laboratory1LeftDistanceRatio = 112 / 512; // 112像素距離在512背景中的比例 (21.88%)
            const laboratory1LeftDistance = Math.floor(GAME_HEIGHT * laboratory1LeftDistanceRatio);
            
            // 計算HP Logo模組的右邊位置
            const road9HpLogoWidth = road9HpLogoHeight; // 假設為正方形
            const hpLogosTotalWidth = (road9HpLogoWidth * 3) + (road9HpLogoSpacing * 2); // 3個HP Logo + 2個間距
            const hpLogosRightX = road9HpLogoX + hpLogosTotalWidth;
            
            const laboratory1X = hpLogosRightX + laboratory1LeftDistance; // laboratory-1左邊與hp-logo模組右邊距離112像素
            const laboratory1Y = road9Y - laboratory1Height; // laboratory-1底部貼齊road-9的頂部

            // 添加laboratory-1到world.roads
            world.roads.push({
                x: laboratory1X,
                y: laboratory1Y,
                width: laboratory1Width,
                height: laboratory1Height,
                type: 'laboratory-1',
                isTransformed: false,
                transformStartTime: null,
                transformDuration: 200 // 0.2秒轉換時間
            });

            console.log('🏥 Laboratory-1創建完成:', { x: laboratory1X, y: laboratory1Y, width: laboratory1Width, height: laboratory1Height });
            
            // 同步到舊系統（向後兼容）
            springs = springManager.springs;
            hpLogos = hpLogoManager.hpLogos;
            
            // 動態計算世界寬度，確保包含所有元素
            let maxX = 0;
            
            // 檢查所有road元素的最右邊位置
            world.roads.forEach(road => {
                const roadRightX = road.x + road.width;
                if (roadRightX > maxX) {
                    maxX = roadRightX;
                }
            });
            
            // 檢查所有HP Logo的最右邊位置
            hpLogoManager.hpLogos.forEach(hpLogo => {
                const hpLogoRightX = hpLogo.x + hpLogo.width;
                if (hpLogoRightX > maxX) {
                    maxX = hpLogoRightX;
                }
            });
            
            // 檢查所有Spring的最右邊位置
            springManager.springs.forEach(spring => {
                const springRightX = spring.x + spring.width;
                if (springRightX > maxX) {
                    maxX = springRightX;
                }
            });
            
            // 設定世界寬度為road-9最右邊，限制遊戲範圍
            world.width = road9X + road9Width;
            
            console.log(`🌍 世界寬度限制在road-9右邊: ${world.width}px`);
            
            // 遊戲終點設定在road-9最右邊
            world.endpoint = road9X + road9Width;
            console.log(`🎯 遊戲終點設定在: ${world.endpoint}px (road-9最右邊)`);
        }
        
        function setupEventListeners() {
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                if (e.code === 'Space') e.preventDefault();
            });
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });
            window.addEventListener('resize', () => {
                // 更新遊戲尺寸以適應新的視窗尺寸
                updateCanvasSize();
                world.height = GAME_HEIGHT; // 同時更新世界高度
                
                // 動態重新計算角色大小
                const playerSize = calculatePlayerSize();
                player.width = playerSize.width;
                player.height = playerSize.height;
                
                // 重新創建世界以適應新尺寸
                createWorld();
                
                // 重新計算Spring尺寸（窗口大小改變時）
                if (springManager.springs.length > 0 && springManager.imagesLoaded) {
                    springManager.updateAllDimensions();
                }
                
                // 調整玩家位置
                player.y = Math.floor(GAME_HEIGHT * 0.5);
            });
        }
        
        function nextPage() {
            if (currentStoryPage < maxStoryPages) {
                document.querySelector(`.story-page[data-page="${currentStoryPage}"]`).classList.remove('active');
                currentStoryPage++;
                document.querySelector(`.story-page[data-page="${currentStoryPage}"]`).classList.add('active');
                
                if (currentStoryPage === maxStoryPages) {
                    document.getElementById('nextBtn').classList.add('hidden');
                    document.getElementById('startBtn').classList.remove('hidden');
                }
            }
        }
        
        function startGame() {
            document.getElementById('storyModal').classList.add('hidden');
            gameState = 'playing';
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
            }
            gameLoop();
        }
        
        function update() {
            if (gameState !== 'playing') return;
            updatePlayer();
            updateCamera();
            checkCollisions();
            springManager.checkTriggerCollisions(player);
            updateFallingPlatforms();
            updateLaboratory();
            cloudManager.update();
            cloudManager2.update();
            // 檢查主角是否走到house-3來觸發cloud動畫
            const house3 = world.roads.find(road => road.type === 'house-3');
            if (house3) {
                cloudManager.checkTrigger(player, house3.x, house3.width);
            }
            // 檢查主角是否走到house-7來觸發cloud2動畫
            const house7 = world.roads.find(road => road.type === 'house-7');
            if (house7) {
                cloudManager2.checkTrigger(player, house7.x, house7.width);
            }
            // 更新閃電系統
            lightningManager.update(cloudManager.clouds, GAME_HEIGHT);
            lightningManager2.update(cloudManager2.clouds, GAME_HEIGHT);
            // 檢查閃電碰撞
            if (lightningManager.checkCollisions(player)) {
                takeDamage(1); // 閃電造成1點傷害
                // 讓主角閃爍兩下
                player.alpha = 0.0;
                setTimeout(() => {
                    player.alpha = 1;
                }, 200);
                setTimeout(() => {
                    player.alpha = 0.0;
                }, 400);
                setTimeout(() => {
                    player.alpha = 1;
                }, 600);
            }
            // 檢查閃電2碰撞
            if (lightningManager2.checkCollisions(player)) {
                takeDamage(1); // 閃電2造成1點傷害
                // 讓主角閃爍兩下
                player.alpha = 0.0;
                setTimeout(() => {
                    player.alpha = 1;
                }, 200);
                setTimeout(() => {
                    player.alpha = 0.0;
                }, 400);
                setTimeout(() => {
                    player.alpha = 1;
                }, 600);
            }
            checkEndpoint();
        }
        
        function updatePlayer() {
            const wasMoving = Math.abs(player.velocityX) > 0.1;
            
            // 如果主角控制被禁用，停止移動
            if (player.controlDisabled) {
                player.velocityX *= 0.9; // 逐漸停止
                return;
            }
            
            if (keys['ArrowLeft']) {
                player.velocityX = -3;
                player.facingRight = false;
            } else if (keys['ArrowRight']) {
                player.velocityX = 3;
                player.facingRight = true;
            } else {
                player.velocityX *= 0.9;
            }
            
            if (keys['Space'] && player.onGround) {
                player.velocityY = -8;
                player.onGround = false;
                // 開始跳躍狀態追蹤
                jumpState = 'preparing';
                jumpStartTime = Date.now();
            }
            
            // 更新跳躍狀態
            updateJumpState();
            
            // 更新動畫狀態
            const isMoving = Math.abs(player.velocityX) > 0.1;
            const isJumping = !player.onGround; // 角色不在地面上就是跳躍狀態
            
            let newAnimation;
            if (isJumping) {
                if (jumpState === 'preparing') {
                    newAnimation = 'jumpPrepare';
                } else {
                    newAnimation = 'jumping';
                }
            } else if (isMoving) {
                newAnimation = 'running';
            } else {
                newAnimation = 'idle';
            }
            
            // 如果動畫狀態改變，重置動畫幀索引和時間
            if (newAnimation !== currentAnimation) {
                currentAnimation = newAnimation;
                animationFrame = 0; // 重置到第一幀
                lastFrameTime = Date.now(); // 重置時間，避免時間混亂
            }
            
            player.velocityY += world.gravity;
            player.x += player.velocityX;
            player.y += player.velocityY;
            
            if (player.x < 0) player.x = 0;
            if (player.x > world.width - player.width) player.x = world.width - player.width;
            if (player.y > world.height) takeDamage(100);
            
            // 更新動畫幀
            updateAnimation();
        }

        // 更新跳躍狀態
        function updateJumpState() {
            if (jumpState === 'preparing') {
                const currentTime = Date.now();
                if (currentTime - jumpStartTime > jumpPrepareTime) {
                    jumpState = 'jumping';
                }
            } else if (jumpState === 'jumping' && player.onGround) {
                jumpState = 'none';
            }
        }
        
        function updateAnimation() {
            const currentTime = Date.now();
            
            // 跳躍動畫不需要更新幀，使用單一圖片
            if (currentAnimation === 'jumping' || currentAnimation === 'jumpPrepare') {
                return;
            }
            
            // 根據動畫類型選擇不同的間隔時間
            const currentInterval = currentAnimation === 'running' ? runningFrameInterval : idleFrameInterval;
            
            if (currentTime - lastFrameTime > currentInterval) {
                const animFrames = characterSprites[currentAnimation];
                if (animFrames && animFrames.length > 0) {
                    // 確保動畫幀索引在有效範圍內
                    if (animationFrame >= animFrames.length) {
                        animationFrame = 0;
                    }
                    
                    const previousFrame = animationFrame;
                    animationFrame = (animationFrame + 1) % animFrames.length;
                    
                    // 調試：僅顯示動畫循環重啟
                    if (currentAnimation === 'running' && previousFrame === 3 && animationFrame === 0) {
                        console.log(`🔄 跑步動畫循環重啟: character-run-4 → character-run-1 (${runningFrameInterval}ms間隔)`);
                    } else if (currentAnimation === 'idle' && previousFrame === 1 && animationFrame === 0) {
                        console.log(`🔄 站立動畫循環重啟: character-idle-2 → character-idle-1 (${idleFrameInterval}ms間隔)`);
                    }
                } else {
                    // 如果沒有動畫，重置動畫幀
                    animationFrame = 0;
                    console.log(`⚠️ 沒有找到 ${currentAnimation} 動畫幀，重置為0`);
                }
                lastFrameTime = currentTime;
            }
        }
        
        function updateCamera() {
            // 使用Math.floor確保攝影機位置為整數，避免閃爍
            camera.x = Math.floor(player.x - GAME_WIDTH / 2);
            camera.y = Math.floor(player.y - GAME_HEIGHT / 2);
            
            if (camera.x < 0) camera.x = 0;
            if (camera.x > world.width - GAME_WIDTH) camera.x = Math.max(0, world.width - GAME_WIDTH);
            if (camera.y < 0) camera.y = 0;
            if (camera.y > world.height - GAME_HEIGHT) camera.y = world.height - GAME_HEIGHT;
        }
        

        

        
        function checkCollisions() {
            player.onGround = false;
            
            // 檢查與路面的碰撞
            world.roads.forEach(road => {
                            // road-kanban、house-1、house-2、house-3、house-4、house-5、house-6、house-7、house-8 作為背景，不參與碰撞檢測
            if (road.type === 'road-kanban' || road.type === 'house-1' || road.type === 'house-2' || road.type === 'house-3' || road.type === 'house-4' || road.type === 'house-5' || road.type === 'house-6' || road.type === 'house-7' || road.type === 'house-8') {
                    return; // 跳過背景元素的碰撞檢測
                }
                
                if (player.x < road.x + road.width &&
                    player.x + player.width > road.x &&
                    player.y < road.y + road.height &&
                    player.y + player.height > road.y) {
                    
                    if (player.velocityY > 0 && player.y < road.y) {
                        player.y = road.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                        
                        // 如果是road-short-1或road-short-2，觸發掉落
                        if ((road.type === 'road-short-1' || road.type === 'road-short-2') && !road.isFalling) {
                            road.isFalling = true;
                            road.fallStartTime = Date.now();
                            console.log(`⚠️ 玩家踩到 ${road.id}，開始掉落！`);
                        }
                    }
                }
            });
            
            // 使用HP Logo管理器檢查碰撞
            const newlyCollected = hpLogoManager.checkCollisions(player);
            if (newlyCollected > 0) {
                            console.log('💊 HP Logo被收集！');
                updateUI();
            }
            
            // 使用Spring模組檢查障礙物碰撞
            springManager.checkObstacleCollisions(player);
        }


        
        function updateFallingPlatforms() {
            const currentTime = Date.now();
            
            world.roads.forEach(road => {
                if ((road.type === 'road-short-1' || road.type === 'road-short-2') && road.isFalling) {
                    const fallProgress = (currentTime - road.fallStartTime) / road.fallDuration;
                    
                    if (fallProgress >= 1) {
                        // 掉落完成，移除平台
                        const index = world.roads.indexOf(road);
                        if (index > -1) {
                            world.roads.splice(index, 1);
                            console.log(`💥 ${road.id} 掉落完成，已移除`);
                        }
                    } else {
                        // 正在掉落，更新Y位置
                        const fallDistance = 200; // 掉落距離
                        road.y = road.originalY + (fallDistance * fallProgress);
                    }
                }
            });
        }

        function updateLaboratory() {
            const currentTime = Date.now();
            
            world.roads.forEach(road => {
                if (road.type === 'laboratory-1' && !road.isTransformed) {
                    // 檢查主角是否走到laboratory-1的寬度1/5位置
                    const triggerX = road.x + (road.width * 0.2); // 1/5 = 0.2
                    
                    if (player.x >= triggerX) {
                        road.isTransformed = true;
                        road.transformStartTime = currentTime;
                        road.type = 'laboratory-2';
                        player.controlDisabled = true; // 禁用主角控制
                        console.log('🏥 Laboratory-1轉換為Laboratory-2！主角控制已禁用');
                    }
                } else if (road.type === 'laboratory-2' && road.isTransformed) {
                    const transformProgress = (currentTime - road.transformStartTime) / road.transformDuration;
                    
                    if (transformProgress >= 1) {
                        // 轉換完成，開始畫面變黑
                        console.log('🎉 遊戲勝利！主角成功進入實驗室！');
                        gameState = 'victory';
                        startVictorySequence();
                    } else {
                        // 正在轉換，主角透明度逐漸降低
                        const alpha = 1 - transformProgress;
                        player.alpha = alpha;
                    }
                }
            });
        }

        function startVictorySequence() {
            // 開始勝利序列
            victoryStartTime = Date.now();
            victoryDuration = 2000; // 2秒變黑時間
            console.log('🎬 開始勝利序列：畫面變黑');
        }

        function checkEndpoint() {
            // 檢查主角是否到達遊戲終點
            if (world.endpoint && player.x >= world.endpoint) {
                console.log('🎯 主角到達遊戲終點！');
                // 主角不能繼續往右走
                player.x = world.endpoint;
            }
        }
        
        function takeDamage(amount) {
            player.health -= amount;
            if (player.health <= 0) {
                player.health = 0;
                endGame(false);
            }
            updateUI();
        }
        
        function useHealthPotion() {
            // UI元素已移除，此函數保留以備將來使用
        }
        
        function useShield() {
            // UI元素已移除，此函數保留以備將來使用
        }
        
        function updateUI() {
            // UI元素已移除，此函數保留以備將來使用
        }
        
        function endGame(success) {
            // 停止遊戲循環
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            gameState = 'ended';
            const modal = document.getElementById('endingModal');
            const title = document.getElementById('endingTitle');
            const text = document.getElementById('endingText');
            
            if (success) {
                title.textContent = '🎉 任務成功！';
                text.innerHTML = `恭喜你成功逃出了危險！<br><br>你發現的秘密將改變整個世界...<br><br>在你的努力下，人類終於找到了<br>突破科技極限的關鍵。<br><br>新的時代即將來臨！`;
            } else {
                title.textContent = '💀 任務失敗';
                text.innerHTML = `你在逃脫過程中不幸犧牲了...<br><br>但你的勇氣激勵了其他研究員，<br><br>他們將繼承你的意志，<br>繼續尋找真相。<br><br>你的犧牲不會白費！`;
            }
            
            modal.style.display = 'flex';
        }
        
        function restartGame() {
            // 停止遊戲循環
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            gameState = 'story';
            currentStoryPage = 1;
            
            // 動態計算角色大小
            const playerSize = calculatePlayerSize();
            
            // 完全重置玩家狀態
            player = {
                x: 100, y: Math.floor(GAME_HEIGHT * 0.5), 
                width: playerSize.width, height: playerSize.height,
                velocityX: 0, velocityY: 0, onGround: false,
                health: 100, maxHealth: 100,
                shieldActive: false, shieldHits: 0,
                facingRight: true,
                alpha: 1,
                controlDisabled: false
            };
            
            // 重置動畫狀態
            currentAnimation = 'idle';
            animationFrame = 0;
            lastFrameTime = Date.now();
            
            // 重置勝利序列
            victoryStartTime = null;
            
            // 重置跳躍狀態
            jumpState = 'none';
            jumpStartTime = 0;
            
            // 重置攝影機
            camera = { x: 0, y: 0 };
            
            // 重置世界
            createWorld();
            
            // 重置庫存
            inventory = { healthPotions: 2, shields: 1 };
            
            // 重置HP Logo收集計數和狀態
            // collectedHpCount重置已移除
            hpLogoManager.reset();
            
            // 重置road-short-1和road-short-2掉落狀態
            world.roads.forEach(road => {
                if (road.type === 'road-short-1' || road.type === 'road-short-2') {
                    road.isFalling = false;
                    road.fallStartTime = 0;
                    road.y = road.originalY;
                }
            });
            
            // Spring已在createWorld()中清空並重新創建，只需重置狀態
            springManager.reset();
            cloudManager.reset();
            cloudManager2.reset();
            lightningManager.reset();
            lightningManager2.reset();
            
            // 清除所有按鍵狀態
            keys = {};
            
            updateUI();
            
            document.getElementById('endingModal').style.display = 'none';
            document.getElementById('storyModal').classList.remove('hidden');
            
            document.querySelectorAll('.story-page').forEach(page => page.classList.remove('active'));
            document.querySelector('.story-page[data-page="1"]').classList.add('active');
            document.getElementById('nextBtn').classList.remove('hidden');
            document.getElementById('startBtn').classList.add('hidden');
        }
        
        function render() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            drawBackground();
            drawRoads();
            hpLogoManager.draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT);
            springManager.draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT);
            cloudManager.draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT);
            cloudManager2.draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT);
            lightningManager.draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT);
            lightningManager2.draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT);
            // drawEndpoint(); // 已刪除 lab 藍色框框
            drawPlayer();
            
            // 如果處於勝利狀態，繪製變黑效果
            if (gameState === 'victory' && victoryStartTime) {
                const currentTime = Date.now();
                const elapsed = currentTime - victoryStartTime;
                const progress = Math.min(elapsed / victoryDuration, 1);
                
                // 繪製漸變黑色遮罩
                ctx.fillStyle = `rgba(0, 0, 0, ${progress})`;
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                
                // 如果變黑完成，可以準備顯示勝利動畫
                if (progress >= 1) {
                    console.log('🎬 畫面變黑完成，準備顯示勝利動畫');
                    // 這裡可以加入勝利動畫的邏輯
                }
            }
        }
        
        function drawBackground() {
            if (backgroundLoaded && backgroundImage) {
                // 計算背景圖片的縮放比例，讓圖片高度填滿畫面
                const scale = GAME_HEIGHT / backgroundHeight;
                const scaledWidth = Math.floor(backgroundWidth * scale);
                const scaledHeight = GAME_HEIGHT;
                
                // 計算背景的滾動位置（視差效果）
                const parallaxSpeed = 0.3; // 背景滾動速度（相對於攝影機速度）
                const backgroundOffsetX = Math.floor(camera.x * parallaxSpeed) % scaledWidth;
                
                // 計算需要繪製的背景圖片數量，確保完整覆蓋
                const startTile = Math.floor(-backgroundOffsetX / scaledWidth) - 1;
                const endTile = Math.ceil((GAME_WIDTH - backgroundOffsetX) / scaledWidth) + 1;
                
                // 繪製背景圖片以實現無限滾動，確保整數位置
                for (let i = startTile; i <= endTile; i++) {
                    const x = Math.floor(i * scaledWidth - backgroundOffsetX);
                    // 確保繪製尺寸也是整數
                    ctx.drawImage(backgroundImage, x, 0, Math.floor(scaledWidth), Math.floor(scaledHeight));
                }
            } else {
                // 如果背景圖片載入失敗，使用原來的星空背景
                ctx.fillStyle = '#ffffff';
                for (let i = 0; i < 100; i++) {
                    const x = (i * 137) % world.width - camera.x;
                    const y = (i * 73) % world.height - camera.y;
                    if (x >= -10 && x <= GAME_WIDTH + 10 && y >= -10 && y <= GAME_HEIGHT + 10) {
                        ctx.fillRect(x, y, 2, 2);
                    }
                }
            }
        }
        
        // 路面圖片載入
        let roadImages = {};
        let roadOriginalSizes = {}; // 儲存原始尺寸
        let roadsLoaded = false;

        // HP Logo 系統
        // HP Logo系統已移至HpLogoManager模組
        let hpLogos = []; // 向後兼容
        // collectedHpCount變數已移除，因為UI元素已移除

        // Spring 彈簧系統
        let springs = [];
        let springImages = {}; // 存储spring-1到spring-4的图片
        let springsLoaded = false;

        // ===============================
        // Lightning 閃電模組
        // ===============================
        // Lightning 閃電模組 (House-3)
        // ===============================
        class LightningManager {
            constructor() {
                this.lightnings = [];
                this.imagesLoaded = false;
                this.images = {};
                this.isActive = false;
                this.lastLightningTime = 0;
                this.lightningInterval = 300; // 0.8秒產生一次閃電
                this.lightningDuration = 2000; // 2秒閃電持續時間
                this.maxLightnings = 10; // 最多同時存在5個閃電
                this.cloudLastLightningTime = {}; // 記錄每個cloud最後產生閃電的時間
                this.cloudLightningInterval = 800; // 每個cloud 1.2秒才能產生一次閃電
                this.playerLastHitTime = 0; // 記錄主角最後被擊中的時間
                this.playerHitCooldown = 1000; // 主角被擊中後1秒內不會再次受傷
            }

            // 載入Lightning圖片
            loadImages() {
                const lightningTypes = ['lightning'];
                let loadedCount = 0;

                lightningTypes.forEach(type => {
                    const img = new Image();
                    img.onload = () => {
                        this.images[type] = img;
                        loadedCount++;
                        if (loadedCount === lightningTypes.length) {
                            this.imagesLoaded = true;
                            console.log('⚡ Lightning圖片載入完成');
                        }
                    };
                    img.onerror = () => {
                        console.log(`❌ Lightning圖片載入失敗: ${type}`);
                        loadedCount++;
                        if (loadedCount === lightningTypes.length) {
                            this.imagesLoaded = true;
                        }
                    };
                    img.src = `${type}.svg`;
                });
            }

            // 啟動閃電系統
            startLightning() {
                this.isActive = true;
                this.lastLightningTime = Date.now();
                console.log('⚡ Lightning系統啟動！');
            }

            // 更新閃電
            update(clouds, GAME_HEIGHT) {
                if (!this.isActive || !clouds || clouds.length === 0) return;

                const currentTime = Date.now();

                // 檢查是否有cloud在動畫中
                const activeClouds = clouds.filter(cloud => cloud.isAnimating);
                if (activeClouds.length === 0) return;

                // 連續性產生閃電（不限制cloud間隔，但限制總數量）
                if (this.lightnings.length < this.maxLightnings) {
                    // 隨機選擇一個動畫中的cloud
                    const randomCloud = activeClouds[Math.floor(Math.random() * activeClouds.length)];
                    
                    // 添加一些隨機性，讓閃電產生更自然
                    const randomDelay = Math.random() * 500; // 0-500ms的隨機延遲
                    if (currentTime - this.lastLightningTime > this.lightningInterval + randomDelay) {
                        this.createLightning(randomCloud, GAME_HEIGHT);
                        this.lastLightningTime = currentTime;
                    }
                }

                // 更新現有閃電
                this.lightnings.forEach((lightning, index) => {
                    const elapsed = currentTime - lightning.startTime;
                    const progress = elapsed / this.lightningDuration;

                    if (progress >= 1) {
                        // 閃電結束，移除
                        this.lightnings.splice(index, 1);
                    } else {
                        // 更新閃電位置（從cloud往下落）
                        const fallDistance = GAME_HEIGHT; // 掉落距離為整個遊戲高度
                        lightning.y = lightning.cloudY + (fallDistance * progress);
                    }
                });
            }

            // 創建閃電
            createLightning(cloud, GAME_HEIGHT) {
                // 計算lightning尺寸
                const lightningHeightRatio = 24 / 512; // 24像素高度在512背景中的比例 (4.69%)
                const lightningHeight = Math.floor(GAME_HEIGHT * lightningHeightRatio);
                
                let lightningWidth;
                if (roadOriginalSizes['lightning']) {
                    const originalSize = roadOriginalSizes['lightning'];
                    const originalRatio = originalSize.width / originalSize.height;
                    lightningWidth = Math.floor(lightningHeight * originalRatio);
                } else if (this.images['lightning'] && this.images['lightning'].complete) {
                    const ratio = this.images['lightning'].naturalWidth / this.images['lightning'].naturalHeight;
                    lightningWidth = Math.floor(lightningHeight * ratio);
                } else {
                    lightningWidth = lightningHeight; // 預設為正方形
                }

                // 在cloud範圍內隨機位置
                const minX = cloud.x;
                const maxX = cloud.x + cloud.width - lightningWidth;
                const lightningX = minX + Math.random() * (maxX - minX);

                const lightning = {
                    x: lightningX,
                    y: cloud.y + cloud.height, // 從cloud底部開始
                    width: lightningWidth,
                    height: lightningHeight,
                    cloudY: cloud.y + cloud.height, // 記錄cloud底部位置
                    startTime: Date.now(),
                    type: 'lightning'
                };

                this.lightnings.push(lightning);
                console.log('⚡ 新閃電產生！位置:', { x: lightningX, y: lightning.y, cloud: cloud.type });
            }

            // 檢查與主角的碰撞
            checkCollisions(player) {
                if (!this.isActive) return false;

                const currentTime = Date.now();
                
                // 檢查是否在冷卻期內
                if (currentTime - this.playerLastHitTime < this.playerHitCooldown) {
                    return false;
                }

                let hit = false;
                this.lightnings.forEach(lightning => {
                    if (player.x < lightning.x + lightning.width &&
                        player.x + player.width > lightning.x &&
                        player.y < lightning.y + lightning.height &&
                        player.y + player.height > lightning.y) {
                        
                        hit = true;
                        this.playerLastHitTime = currentTime; // 記錄被擊中時間
                        console.log('⚡ 主角被閃電擊中！HP:', player.health);
                    }
                });

                return hit;
            }

            // 繪製閃電
            draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT) {
                if (!this.isActive) return;

                this.lightnings.forEach(lightning => {
                    const x = Math.floor(lightning.x - camera.x);
                    const y = Math.floor(lightning.y - camera.y);
                    
                    // 檢查是否在畫面內
                    if (x + lightning.width >= 0 && x <= GAME_WIDTH &&
                        y + lightning.height >= 0 && y <= GAME_HEIGHT) {
                        
                        if (this.imagesLoaded && this.images['lightning']) {
                            ctx.save();
                            ctx.imageSmoothingEnabled = false;
                            ctx.drawImage(this.images['lightning'], x, y, lightning.width, lightning.height);
                            ctx.restore();
                        } else {
                            // 如果圖片未載入，繪製預設的閃電形狀
                            ctx.fillStyle = '#FFFF00';
                            ctx.fillRect(x, y, lightning.width, lightning.height);
                        }
                    }
                });
            }

            // 重置
            reset() {
                this.lightnings = [];
                this.isActive = false;
                this.lastLightningTime = 0;
                this.cloudLastLightningTime = {};
                this.playerLastHitTime = 0;
            }
        }

        // ===============================
        // Lightning 閃電模組 (House-7)
        // ===============================
        class LightningManager2 {
            constructor() {
                this.lightnings = [];
                this.imagesLoaded = false;
                this.images = {};
                this.isActive = false;
                this.lastLightningTime = 0;
                this.lightningInterval = 300; // 0.3秒產生一次閃電
                this.lightningDuration = 2000; // 2秒閃電持續時間
                this.maxLightnings = 10; // 最多同時存在10個閃電
                this.cloudLastLightningTime = {}; // 記錄每個cloud最後產生閃電的時間
                this.cloudLightningInterval = 800; // 每個cloud 0.8秒才能產生一次閃電
                this.playerLastHitTime = 0; // 記錄主角最後被擊中的時間
                this.playerHitCooldown = 1000; // 主角被擊中後1秒內不會再次受傷
            }

            // 載入Lightning圖片
            loadImages() {
                const lightningTypes = ['lightning'];
                let loadedCount = 0;

                lightningTypes.forEach(type => {
                    const img = new Image();
                    img.onload = () => {
                        this.images[type] = img;
                        loadedCount++;
                        if (loadedCount === lightningTypes.length) {
                            this.imagesLoaded = true;
                            console.log('⚡ Lightning2圖片載入完成');
                        }
                    };
                    img.onerror = () => {
                        console.log(`❌ Lightning2圖片載入失敗: ${type}`);
                        loadedCount++;
                        if (loadedCount === lightningTypes.length) {
                            this.imagesLoaded = true;
                        }
                    };
                    img.src = `${type}.svg`;
                });
            }

            // 啟動閃電系統
            startLightning() {
                this.isActive = true;
                this.lastLightningTime = Date.now();
                console.log('⚡ Lightning2系統啟動！');
            }

            // 更新閃電
            update(clouds, GAME_HEIGHT) {
                if (!this.isActive || !clouds || clouds.length === 0) return;

                const currentTime = Date.now();

                // 檢查是否有cloud在動畫中
                const activeClouds = clouds.filter(cloud => cloud.isAnimating);
                if (activeClouds.length === 0) return;

                // 連續性產生閃電（不限制cloud間隔，但限制總數量）
                if (this.lightnings.length < this.maxLightnings) {
                    // 隨機選擇一個動畫中的cloud
                    const randomCloud = activeClouds[Math.floor(Math.random() * activeClouds.length)];
                    
                    // 添加一些隨機性，讓閃電產生更自然
                    const randomDelay = Math.random() * 500; // 0-500ms的隨機延遲
                    if (currentTime - this.lastLightningTime > this.lightningInterval + randomDelay) {
                        this.createLightning(randomCloud, GAME_HEIGHT);
                        this.lastLightningTime = currentTime;
                    }
                }

                // 更新現有閃電
                this.lightnings.forEach((lightning, index) => {
                    const elapsed = currentTime - lightning.startTime;
                    const progress = elapsed / this.lightningDuration;

                    if (progress >= 1) {
                        // 閃電結束，移除
                        this.lightnings.splice(index, 1);
                    } else {
                        // 更新閃電位置（從cloud往下落）
                        const fallDistance = GAME_HEIGHT; // 掉落距離為整個遊戲高度
                        lightning.y = lightning.cloudY + (fallDistance * progress);
                    }
                });
            }

            // 創建閃電
            createLightning(cloud, GAME_HEIGHT) {
                // 計算lightning尺寸
                const lightningHeightRatio = 24 / 512; // 24像素高度在512背景中的比例 (4.69%)
                const lightningHeight = Math.floor(GAME_HEIGHT * lightningHeightRatio);
                
                let lightningWidth;
                if (roadOriginalSizes['lightning']) {
                    const originalSize = roadOriginalSizes['lightning'];
                    const originalRatio = originalSize.width / originalSize.height;
                    lightningWidth = Math.floor(lightningHeight * originalRatio);
                } else if (this.images['lightning'] && this.images['lightning'].complete) {
                    const ratio = this.images['lightning'].naturalWidth / this.images['lightning'].naturalHeight;
                    lightningWidth = Math.floor(lightningHeight * ratio);
                } else {
                    lightningWidth = lightningHeight; // 預設為正方形
                }

                // 在cloud範圍內隨機位置
                const minX = cloud.x;
                const maxX = cloud.x + cloud.width - lightningWidth;
                const lightningX = minX + Math.random() * (maxX - minX);

                const lightning = {
                    x: lightningX,
                    y: cloud.y + cloud.height, // 從cloud底部開始
                    width: lightningWidth,
                    height: lightningHeight,
                    cloudY: cloud.y + cloud.height, // 記錄cloud底部位置
                    startTime: Date.now(),
                    type: 'lightning'
                };

                this.lightnings.push(lightning);
                console.log('⚡ 新閃電2產生！位置:', { x: lightningX, y: lightning.y, cloud: cloud.type });
            }

            // 檢查與主角的碰撞
            checkCollisions(player) {
                if (!this.isActive) return false;

                const currentTime = Date.now();
                
                // 檢查是否在冷卻期內
                if (currentTime - this.playerLastHitTime < this.playerHitCooldown) {
                    return false;
                }

                let hit = false;
                this.lightnings.forEach(lightning => {
                    if (player.x < lightning.x + lightning.width &&
                        player.x + player.width > lightning.x &&
                        player.y < lightning.y + lightning.height &&
                        player.y + player.height > lightning.y) {
                        
                        hit = true;
                        this.playerLastHitTime = currentTime; // 記錄被擊中時間
                        console.log('⚡ 主角被閃電2擊中！HP:', player.health);
                    }
                });

                return hit;
            }

            // 繪製閃電
            draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT) {
                if (!this.isActive) return;

                this.lightnings.forEach(lightning => {
                    const x = Math.floor(lightning.x - camera.x);
                    const y = Math.floor(lightning.y - camera.y);
                    
                    // 檢查是否在畫面內
                    if (x + lightning.width >= 0 && x <= GAME_WIDTH &&
                        y + lightning.height >= 0 && y <= GAME_HEIGHT) {
                        
                        if (this.imagesLoaded && this.images['lightning']) {
                            ctx.save();
                            ctx.imageSmoothingEnabled = false;
                            ctx.drawImage(this.images['lightning'], x, y, lightning.width, lightning.height);
                            ctx.restore();
                        } else {
                            // 如果圖片未載入，繪製預設的閃電形狀
                            ctx.fillStyle = '#FFFF00';
                            ctx.fillRect(x, y, lightning.width, lightning.height);
                        }
                    }
                });
            }

            // 重置
            reset() {
                this.lightnings = [];
                this.isActive = false;
                this.lastLightningTime = 0;
                this.cloudLastLightningTime = {};
                this.playerLastHitTime = 0;
            }
        }

        // ===============================
        // Cloud 雲朵模組 (House-3)
        // ===============================
        class CloudManager {
            constructor() {
                this.clouds = [];
                this.imagesLoaded = false;
                this.images = {};
                this.animationStarted = false;
                this.startTime = null;
                this.cloud1StartTime = null;
                this.cloud2StartTime = null;
                this.cloud3StartTime = null;
                this.animationDuration = 1000; // 1秒滑入動畫
                this.cloudDelay = 300; // 0.3秒延遲
            }

            // 載入Cloud圖片
            loadImages() {
                const cloudTypes = ['cloud-1', 'cloud-2', 'cloud-3'];
                let loadedCount = 0;

                cloudTypes.forEach(type => {
                    const img = new Image();
                    img.onload = () => {
                        this.images[type] = img;
                        loadedCount++;
                        if (loadedCount === cloudTypes.length) {
                            this.imagesLoaded = true;
                            console.log('☁️ Cloud圖片載入完成');
                        }
                    };
                    img.onerror = () => {
                        console.log(`❌ Cloud圖片載入失敗: ${type}`);
                        loadedCount++;
                        if (loadedCount === cloudTypes.length) {
                            this.imagesLoaded = true;
                        }
                    };
                    img.src = `${type}.svg`;
                });
            }

            // 創建Cloud雲朵
            createClouds(road3X, road3Width, GAME_HEIGHT) {
                // 計算Cloud尺寸
                const cloud1HeightRatio = 96 / 512; // 96像素高度在512背景中的比例 (18.75%)
                const cloud2HeightRatio = 79 / 512; // 79像素高度在512背景中的比例 (15.43%)
                const cloud3HeightRatio = 77 / 512; // 77像素高度在512背景中的比例 (15.04%)

                const cloud1Height = Math.floor(GAME_HEIGHT * cloud1HeightRatio);
                const cloud2Height = Math.floor(GAME_HEIGHT * cloud2HeightRatio);
                const cloud3Height = Math.floor(GAME_HEIGHT * cloud3HeightRatio);

                // 計算Cloud寬度（保持原始比例）
                let cloud1Width, cloud2Width, cloud3Width;

                // 使用roadOriginalSizes來獲取原始比例
                if (roadOriginalSizes['cloud-1']) {
                    const originalSize = roadOriginalSizes['cloud-1'];
                    const originalRatio = originalSize.width / originalSize.height;
                    cloud1Width = Math.floor(cloud1Height * originalRatio);
                } else if (this.images['cloud-1'] && this.images['cloud-1'].complete) {
                    const ratio = this.images['cloud-1'].naturalWidth / this.images['cloud-1'].naturalHeight;
                    cloud1Width = Math.floor(cloud1Height * ratio);
                } else {
                    cloud1Width = cloud1Height; // 預設為正方形
                }

                if (roadOriginalSizes['cloud-2']) {
                    const originalSize = roadOriginalSizes['cloud-2'];
                    const originalRatio = originalSize.width / originalSize.height;
                    cloud2Width = Math.floor(cloud2Height * originalRatio);
                } else if (this.images['cloud-2'] && this.images['cloud-2'].complete) {
                    const ratio = this.images['cloud-2'].naturalWidth / this.images['cloud-2'].naturalHeight;
                    cloud2Width = Math.floor(cloud2Height * ratio);
                } else {
                    cloud2Width = cloud2Height; // 預設為正方形
                }

                if (roadOriginalSizes['cloud-3']) {
                    const originalSize = roadOriginalSizes['cloud-3'];
                    const originalRatio = originalSize.width / originalSize.height;
                    cloud3Width = Math.floor(cloud3Height * originalRatio);
                } else if (this.images['cloud-3'] && this.images['cloud-3'].complete) {
                    const ratio = this.images['cloud-3'].naturalWidth / this.images['cloud-3'].naturalHeight;
                    cloud3Width = Math.floor(cloud3Height * ratio);
                } else {
                    cloud3Width = cloud3Height; // 預設為正方形
                }

                // 計算Cloud位置
                const cloudLeftDistanceRatio = 8 / 512; // 8像素距離在512背景中的比例 (1.56%)
                const cloud1TopDistanceRatio = 15 / 512; // 15像素距離在512背景中的比例 (2.93%)
                const cloud2TopDistanceRatio = 19 / 512; // 19像素距離在512背景中的比例 (3.71%)
                const cloud3TopDistanceRatio = 15 / 512; // 15像素距離在512背景中的比例 (2.93%)
                const cloud2LeftDistanceRatio = 14 / 512; // 14像素距離在512背景中的比例 (2.73%)
                const cloud3LeftDistanceRatio = 48 / 512; // 48像素距離在512背景中的比例 (9.38%)

                const cloudLeftDistance = Math.floor(GAME_HEIGHT * cloudLeftDistanceRatio);
                const cloud1TopDistance = Math.floor(GAME_HEIGHT * cloud1TopDistanceRatio);
                const cloud2TopDistance = Math.floor(GAME_HEIGHT * cloud2TopDistanceRatio);
                const cloud3TopDistance = Math.floor(GAME_HEIGHT * cloud3TopDistanceRatio);
                const cloud2LeftDistance = Math.floor(GAME_HEIGHT * cloud2LeftDistanceRatio);
                const cloud3LeftDistance = Math.floor(GAME_HEIGHT * cloud3LeftDistanceRatio);

                // 計算Cloud的最終位置
                const cloud1FinalX = road3X + road3Width + cloudLeftDistance;
                const cloud1FinalY = cloud1TopDistance;
                const cloud2FinalX = cloud1FinalX + cloud1Width + cloud2LeftDistance;
                const cloud2FinalY = cloud2TopDistance;
                const cloud3FinalX = cloud2FinalX + cloud2Width + cloud3LeftDistance;
                const cloud3FinalY = cloud3TopDistance;

                // 創建Cloud物件（初始位置在畫面外）
                this.clouds = [
                    {
                        x: cloud1FinalX,
                        y: -cloud1Height, // 初始在畫面外
                        width: cloud1Width,
                        height: cloud1Height,
                        finalY: cloud1FinalY,
                        type: 'cloud-1',
                        isAnimating: false
                    },
                    {
                        x: cloud2FinalX,
                        y: -cloud2Height, // 初始在畫面外
                        width: cloud2Width,
                        height: cloud2Height,
                        finalY: cloud2FinalY,
                        type: 'cloud-2',
                        isAnimating: false
                    },
                    {
                        x: cloud3FinalX,
                        y: -cloud3Height, // 初始在畫面外
                        width: cloud3Width,
                        height: cloud3Height,
                        finalY: cloud3FinalY,
                        type: 'cloud-3',
                        isAnimating: false
                    }
                ];

                console.log('☁️ Cloud模組創建完成:', this.clouds);
            }

            // 啟動動畫
            startAnimation() {
                if (this.animationStarted) return;
                
                this.animationStarted = true;
                this.startTime = Date.now();
                this.cloud1StartTime = this.startTime;
                this.cloud2StartTime = this.startTime + this.cloudDelay;
                this.cloud3StartTime = this.startTime + (this.cloudDelay * 2);
                
                console.log('☁️ Cloud動畫啟動！');
                
                // 啟動閃電系統
                lightningManager.startLightning();
            }

            // 更新動畫
            update() {
                if (!this.animationStarted || !this.clouds || this.clouds.length === 0) return;

                const currentTime = Date.now();

                // 更新cloud-1
                if (this.clouds[0] && currentTime >= this.cloud1StartTime) {
                    this.clouds[0].isAnimating = true;
                    const elapsed = currentTime - this.cloud1StartTime;
                    const progress = Math.min(elapsed / this.animationDuration, 1);
                    
                    // ease out動畫
                    const easeOutProgress = 1 - Math.pow(1 - progress, 3);
                    this.clouds[0].y = -this.clouds[0].height + (easeOutProgress * (this.clouds[0].finalY + this.clouds[0].height));
                }

                // 更新cloud-2
                if (this.clouds[1] && currentTime >= this.cloud2StartTime) {
                    this.clouds[1].isAnimating = true;
                    const elapsed = currentTime - this.cloud2StartTime;
                    const progress = Math.min(elapsed / this.animationDuration, 1);
                    
                    const easeOutProgress = 1 - Math.pow(1 - progress, 3);
                    this.clouds[1].y = -this.clouds[1].height + (easeOutProgress * (this.clouds[1].finalY + this.clouds[1].height));
                }

                // 更新cloud-3
                if (this.clouds[2] && currentTime >= this.cloud3StartTime) {
                    this.clouds[2].isAnimating = true;
                    const elapsed = currentTime - this.cloud3StartTime;
                    const progress = Math.min(elapsed / this.animationDuration, 1);
                    
                    const easeOutProgress = 1 - Math.pow(1 - progress, 3);
                    this.clouds[2].y = -this.clouds[2].height + (easeOutProgress * (this.clouds[2].finalY + this.clouds[2].height));
                }
            }

            // 繪製Cloud
            draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT) {
                if (!this.clouds || this.clouds.length === 0) return;
                
                this.clouds.forEach(cloud => {
                    if (cloud && cloud.isAnimating) {
                        const x = Math.floor(cloud.x - camera.x);
                        const y = Math.floor(cloud.y - camera.y);
                        
                        // 檢查是否在畫面內
                        if (x + cloud.width >= 0 && x <= GAME_WIDTH &&
                            y + cloud.height >= 0 && y <= GAME_HEIGHT) {
                            
                            if (this.imagesLoaded && this.images[cloud.type]) {
                                ctx.save();
                                ctx.imageSmoothingEnabled = false;
                                ctx.drawImage(this.images[cloud.type], x, y, cloud.width, cloud.height);
                                ctx.restore();
                            } else {
                                // 如果圖片未載入，繪製預設的雲朵形狀
                                ctx.fillStyle = '#ffffff';
                                ctx.fillRect(x, y, cloud.width, cloud.height);
                            }
                        }
                    }
                });
            }

            // 重置
            reset() {
                this.clouds = [];
                this.animationStarted = false;
                this.startTime = null;
                this.cloud1StartTime = null;
                this.cloud2StartTime = null;
                this.cloud3StartTime = null;
            }

            // 檢查是否應該啟動動畫
            checkTrigger(player, house3X, house3Width) {
                if (this.animationStarted) return;
                
                // 檢查主角是否走到house-3
                if (player.x >= house3X && player.x <= house3X + house3Width) {
                    this.startAnimation();
                }
            }
        }

        // ===============================
        // Cloud 雲朵模組 (House-7)
        // ===============================
        class CloudManager2 {
            constructor() {
                this.clouds = [];
                this.imagesLoaded = false;
                this.images = {};
                this.animationStarted = false;
                this.startTime = null;
                this.cloud1StartTime = null;
                this.cloud2StartTime = null;
                this.cloud3StartTime = null;
                this.animationDuration = 1000; // 1秒滑入動畫
                this.cloudDelay = 300; // 0.3秒延遲
            }

            // 載入Cloud圖片
            loadImages() {
                const cloudTypes = ['cloud-1', 'cloud-2', 'cloud-3'];
                let loadedCount = 0;

                cloudTypes.forEach(type => {
                    const img = new Image();
                    img.onload = () => {
                        this.images[type] = img;
                        loadedCount++;
                        if (loadedCount === cloudTypes.length) {
                            this.imagesLoaded = true;
                            console.log('☁️ Cloud2圖片載入完成');
                        }
                    };
                    img.onerror = () => {
                        console.log(`❌ Cloud2圖片載入失敗: ${type}`);
                        loadedCount++;
                        if (loadedCount === cloudTypes.length) {
                            this.imagesLoaded = true;
                        }
                    };
                    img.src = `${type}.svg`;
                });
            }

            // 創建Cloud雲朵 (House-7版本)
            createClouds(house7X, house7Width, GAME_HEIGHT) {
                // 計算Cloud尺寸
                const cloud1HeightRatio = 96 / 512; // 96像素高度在512背景中的比例 (18.75%)
                const cloud2HeightRatio = 79 / 512; // 79像素高度在512背景中的比例 (15.43%)
                const cloud3HeightRatio = 77 / 512; // 77像素高度在512背景中的比例 (15.04%)

                const cloud1Height = Math.floor(GAME_HEIGHT * cloud1HeightRatio);
                const cloud2Height = Math.floor(GAME_HEIGHT * cloud2HeightRatio);
                const cloud3Height = Math.floor(GAME_HEIGHT * cloud3HeightRatio);

                // 計算Cloud寬度（保持原始比例）
                let cloud1Width, cloud2Width, cloud3Width;

                // 使用roadOriginalSizes來獲取原始比例
                if (roadOriginalSizes['cloud-1']) {
                    const originalSize = roadOriginalSizes['cloud-1'];
                    const originalRatio = originalSize.width / originalSize.height;
                    cloud1Width = Math.floor(cloud1Height * originalRatio);
                } else if (this.images['cloud-1'] && this.images['cloud-1'].complete) {
                    const ratio = this.images['cloud-1'].naturalWidth / this.images['cloud-1'].naturalHeight;
                    cloud1Width = Math.floor(cloud1Height * ratio);
                } else {
                    cloud1Width = cloud1Height; // 預設為正方形
                }

                if (roadOriginalSizes['cloud-2']) {
                    const originalSize = roadOriginalSizes['cloud-2'];
                    const originalRatio = originalSize.width / originalSize.height;
                    cloud2Width = Math.floor(cloud2Height * originalRatio);
                } else if (this.images['cloud-2'] && this.images['cloud-2'].complete) {
                    const ratio = this.images['cloud-2'].naturalWidth / this.images['cloud-2'].naturalHeight;
                    cloud2Width = Math.floor(cloud2Height * ratio);
                } else {
                    cloud2Width = cloud2Height; // 預設為正方形
                }

                if (roadOriginalSizes['cloud-3']) {
                    const originalSize = roadOriginalSizes['cloud-3'];
                    const originalRatio = originalSize.width / originalSize.height;
                    cloud3Width = Math.floor(cloud3Height * originalRatio);
                } else if (this.images['cloud-3'] && this.images['cloud-3'].complete) {
                    const ratio = this.images['cloud-3'].naturalWidth / this.images['cloud-3'].naturalHeight;
                    cloud3Width = Math.floor(cloud3Height * ratio);
                } else {
                    cloud3Width = cloud3Height; // 預設為正方形
                }

                // 計算Cloud位置 (House-7版本)
                const cloud1TopDistanceRatio = 15 / 512; // 15像素距離在512背景中的比例 (2.93%)
                const cloud2TopDistanceRatio = 19 / 512; // 19像素距離在512背景中的比例 (3.71%)
                const cloud3TopDistanceRatio = 15 / 512; // 15像素距離在512背景中的比例 (2.93%)
                const cloud2LeftDistanceRatio = 14 / 512; // 14像素距離在512背景中的比例 (2.73%)
                const cloud3LeftDistanceRatio = 48 / 512; // 48像素距離在512背景中的比例 (9.38%)

                const cloud1TopDistance = Math.floor(GAME_HEIGHT * cloud1TopDistanceRatio);
                const cloud2TopDistance = Math.floor(GAME_HEIGHT * cloud2TopDistanceRatio);
                const cloud3TopDistance = Math.floor(GAME_HEIGHT * cloud3TopDistanceRatio);
                const cloud2LeftDistance = Math.floor(GAME_HEIGHT * cloud2LeftDistanceRatio);
                const cloud3LeftDistance = Math.floor(GAME_HEIGHT * cloud3LeftDistanceRatio);

                // 計算Cloud的最終位置 (House-7版本) - 左邊貼齊house-7右邊
                const cloud1FinalX = house7X + house7Width; // cloud1左邊貼齊house-7右邊
                const cloud1FinalY = cloud1TopDistance;
                const cloud2FinalX = cloud1FinalX + cloud1Width + cloud2LeftDistance;
                const cloud2FinalY = cloud2TopDistance;
                const cloud3FinalX = cloud2FinalX + cloud2Width + cloud3LeftDistance;
                const cloud3FinalY = cloud3TopDistance;

                // 創建Cloud物件（初始位置在畫面外）
                this.clouds = [
                    {
                        x: cloud1FinalX,
                        y: -cloud1Height, // 初始在畫面外
                        width: cloud1Width,
                        height: cloud1Height,
                        finalY: cloud1FinalY,
                        type: 'cloud-1',
                        isAnimating: false
                    },
                    {
                        x: cloud2FinalX,
                        y: -cloud2Height, // 初始在畫面外
                        width: cloud2Width,
                        height: cloud2Height,
                        finalY: cloud2FinalY,
                        type: 'cloud-2',
                        isAnimating: false
                    },
                    {
                        x: cloud3FinalX,
                        y: -cloud3Height, // 初始在畫面外
                        width: cloud3Width,
                        height: cloud3Height,
                        finalY: cloud3FinalY,
                        type: 'cloud-3',
                        isAnimating: false
                    }
                ];

                console.log('☁️ Cloud2模組創建完成:', this.clouds);
            }

            // 啟動動畫
            startAnimation() {
                if (this.animationStarted) return;
                
                this.animationStarted = true;
                this.startTime = Date.now();
                this.cloud1StartTime = this.startTime;
                this.cloud2StartTime = this.startTime + this.cloudDelay;
                this.cloud3StartTime = this.startTime + (this.cloudDelay * 2);
                
                console.log('☁️ Cloud2動畫啟動！');
                
                // 啟動閃電系統
                lightningManager2.startLightning();
            }

            // 更新動畫
            update() {
                if (!this.animationStarted || !this.clouds || this.clouds.length === 0) return;

                const currentTime = Date.now();

                // 更新cloud-1
                if (this.clouds[0] && currentTime >= this.cloud1StartTime) {
                    this.clouds[0].isAnimating = true;
                    const elapsed = currentTime - this.cloud1StartTime;
                    const progress = Math.min(elapsed / this.animationDuration, 1);
                    
                    // ease out動畫
                    const easeOutProgress = 1 - Math.pow(1 - progress, 3);
                    this.clouds[0].y = -this.clouds[0].height + (easeOutProgress * (this.clouds[0].finalY + this.clouds[0].height));
                }

                // 更新cloud-2
                if (this.clouds[1] && currentTime >= this.cloud2StartTime) {
                    this.clouds[1].isAnimating = true;
                    const elapsed = currentTime - this.cloud2StartTime;
                    const progress = Math.min(elapsed / this.animationDuration, 1);
                    
                    const easeOutProgress = 1 - Math.pow(1 - progress, 3);
                    this.clouds[1].y = -this.clouds[1].height + (easeOutProgress * (this.clouds[1].finalY + this.clouds[1].height));
                }

                // 更新cloud-3
                if (this.clouds[2] && currentTime >= this.cloud3StartTime) {
                    this.clouds[2].isAnimating = true;
                    const elapsed = currentTime - this.cloud3StartTime;
                    const progress = Math.min(elapsed / this.animationDuration, 1);
                    
                    const easeOutProgress = 1 - Math.pow(1 - progress, 3);
                    this.clouds[2].y = -this.clouds[2].height + (easeOutProgress * (this.clouds[2].finalY + this.clouds[2].height));
                }
            }

            // 繪製Cloud
            draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT) {
                if (!this.clouds || this.clouds.length === 0) return;
                
                this.clouds.forEach(cloud => {
                    if (cloud && cloud.isAnimating) {
                        const x = Math.floor(cloud.x - camera.x);
                        const y = Math.floor(cloud.y - camera.y);
                        
                        // 檢查是否在畫面內
                        if (x + cloud.width >= 0 && x <= GAME_WIDTH &&
                            y + cloud.height >= 0 && y <= GAME_HEIGHT) {
                            
                            if (this.imagesLoaded && this.images[cloud.type]) {
                                ctx.save();
                                ctx.imageSmoothingEnabled = false;
                                ctx.drawImage(this.images[cloud.type], x, y, cloud.width, cloud.height);
                                ctx.restore();
                            } else {
                                // 如果圖片未載入，繪製預設的雲朵形狀
                                ctx.fillStyle = '#ffffff';
                                ctx.fillRect(x, y, cloud.width, cloud.height);
                            }
                        }
                    }
                });
            }

            // 重置
            reset() {
                this.clouds = [];
                this.animationStarted = false;
                this.startTime = null;
                this.cloud1StartTime = null;
                this.cloud2StartTime = null;
                this.cloud3StartTime = null;
            }

            // 檢查是否應該啟動動畫
            checkTrigger(player, house7X, house7Width) {
                if (this.animationStarted) return;
                
                // 檢查主角是否走到house-7
                if (player.x >= house7X && player.x <= house7X + house7Width) {
                    this.startAnimation();
                }
            }
        }

        // ===============================
        // Spring 彈簧模組
        // ===============================
        class SpringManager {
            constructor() {
                this.springs = [];
                this.images = {};
                this.imagesLoaded = false;
            }

            // 載入Spring圖片
            loadImages() {
                const springTypes = ['spring-1', 'spring-2', 'spring-3', 'spring-4'];
                let loadedCount = 0;
                
                springTypes.forEach(type => {
                    const img = new Image();
                    img.onload = () => {
                        this.images[type] = img;
                        loadedCount++;
                        console.log(`✅ 彈簧圖片載入完成: ${type}.svg`);
                        
                        if (loadedCount === springTypes.length) {
                            this.imagesLoaded = true;
                            console.log('🏃‍♂️ 所有彈簧圖片載入完成！');
                            // 圖片載入完成後重新計算Spring尺寸
                            this.updateAllDimensions();
                        }
                    };
                    img.onerror = () => {
                        console.log(`❌ 彈簧圖片載入失敗: ${type}.svg`);
                        loadedCount++;
                        if (loadedCount === springTypes.length) {
                            this.imagesLoaded = true;
                        }
                    };
                    img.src = `${type}.svg`;
                });
            }

            // 創建Spring彈簧
            createSpring(x, y, playerWidth) {
                const springWidthRatio = 42 / 109; // 42像素寬度相對於109角色寬度的比例
                const springWidth = Math.floor(playerWidth * springWidthRatio);
                
                let springHeight;
                if (this.images['spring-1'] && this.images['spring-1'].complete) {
                    const originalRatio = this.images['spring-1'].naturalHeight / this.images['spring-1'].naturalWidth;
                    springHeight = Math.floor(springWidth * originalRatio);
                } else {
                    const defaultRatio = 1.2;
                    springHeight = Math.floor(springWidth * defaultRatio);
                }

                const spring = {
                    x: x,
                    y: y,
                    width: springWidth,
                    height: springHeight,
                    state: 'idle', // 'idle', 'standby', 'compressing', 'compressed', 'expanding'
                    currentFrame: 1,
                    animationTime: 0,
                    isPlayerOn: false,
                    playerStandTime: 0,
                    standbyDuration: 0.3 * 1000,
                    compressionDuration: 0.01 * 1000,
                    holdDuration: 0.03 * 1000,
                    expansionDuration: 0.01 * 1000
                };

                this.springs.push(spring);
                console.log('🏃‍♂️ Spring彈簧創建完成:', spring);
                return spring;
            }

            // 更新所有Spring尺寸
            updateAllDimensions() {
                this.springs.forEach(spring => {
                    this.updateSpringDimensions(spring, player.width);
                });
            }

            // 更新單個Spring尺寸
            updateSpringDimensions(spring, playerWidth) {
                if (!this.images['spring-1'] || !this.images['spring-1'].complete) return;
                
                const springWidthRatio = 42 / 109;
                const springWidth = Math.floor(playerWidth * springWidthRatio);
                const originalRatio = this.images['spring-1'].naturalHeight / this.images['spring-1'].naturalWidth;
                const springHeight = Math.floor(springWidth * originalRatio);
                
                const oldHeight = spring.height;
                spring.width = springWidth;
                spring.height = springHeight;
                spring.y += (oldHeight - springHeight); // 保持底部對齊
            }

            // 檢查障礙物碰撞
            checkObstacleCollisions(player) {
                this.springs.forEach(spring => {
                    if (player.x < spring.x + spring.width &&
                        player.x + player.width > spring.x &&
                        player.y < spring.y + spring.height &&
                        player.y + player.height > spring.y) {
                        
                        // 優先處理垂直碰撞（可以站在spring上面）
                        if (player.velocityY > 0 && player.y < spring.y) {
                            player.y = spring.y - player.height;
                            player.velocityY = 0;
                            player.onGround = true;
                            return;
                        }
                        
                        // 水平碰撞處理（左右阻擋）
                        if (player.y + player.height > spring.y + 5) {
                            if (player.velocityX > 0) {
                                player.x = spring.x - player.width;
                            } else if (player.velocityX < 0) {
                                player.x = spring.x + spring.width;
                            }
                            player.velocityX = 0;
                        }
                    }
                });
            }

            // 檢查觸發碰撞
            checkTriggerCollisions(player) {
                this.springs.forEach(spring => {
                    const playerOnSpringTop = player.x < spring.x + spring.width &&
                                            player.x + player.width > spring.x &&
                                            player.y + player.height >= spring.y &&
                                            player.y + player.height <= spring.y + 10 &&
                                            player.onGround;
                    
                    if (playerOnSpringTop && spring.state === 'idle') {
                        if (!spring.isPlayerOn) {
                            spring.isPlayerOn = true;
                            spring.playerStandTime = Date.now();
                            spring.state = 'standby';
                            console.log('🏃‍♂️ 玩家站到彈簧上，進入待機狀態');
                            
                            // 切換到jump-1動畫
                            jumpState = 'preparing';
                            jumpStartTime = Date.now();
                        }
                    } else if (!playerOnSpringTop && spring.isPlayerOn) {
                        spring.isPlayerOn = false;
                        spring.playerStandTime = 0;
                        if (spring.state === 'standby') {
                            spring.state = 'idle';
                            spring.currentFrame = 1;
                            spring.animationTime = 0;
                            console.log('🏃‍♂️ 玩家離開彈簧，重置狀態');
                        }
                    }
                });
            }

            // 更新Spring動畫
            update(player) {
                const currentTime = Date.now();
                
                this.springs.forEach(spring => {
                    if (spring.state === 'idle') {
                        spring.currentFrame = 1;
                        return;
                    }
                    
                    const deltaTime = currentTime - spring.animationTime;
                    
                    switch (spring.state) {
                        case 'standby':
                            if (spring.isPlayerOn && deltaTime >= spring.standbyDuration) {
                                spring.state = 'compressing';
                                spring.currentFrame = 1;
                                spring.animationTime = currentTime;
                                console.log('🏃‍♂️ 彈簧待機時間結束，開始壓縮動畫');
                            }
                            break;
                            
                        case 'compressing':
                            if (deltaTime >= spring.compressionDuration) {
                                spring.currentFrame++;
                                spring.animationTime = currentTime;
                                
                                if (spring.currentFrame > 4) {
                                    spring.state = 'compressed';
                                    spring.currentFrame = 4;
                                    spring.animationTime = currentTime;
                                    console.log('🏃‍♂️ 彈簧壓縮完成，開始停頓');
                                }
                            }
                            break;
                            
                        case 'compressed':
                            if (deltaTime >= spring.holdDuration) {
                                spring.state = 'expanding';
                                spring.currentFrame = 3;
                                spring.animationTime = currentTime;
                                
                                if (spring.isPlayerOn) {
                                    player.velocityY = -12;
                                    player.onGround = false;
                                    jumpState = 'jumping';
                                    jumpStartTime = Date.now();
                                    console.log('🏃‍♂️ 彈簧彈開！玩家被彈起，切換到jump-2');
                                }
                            }
                            break;
                            
                        case 'expanding':
                            if (deltaTime >= spring.expansionDuration) {
                                spring.currentFrame--;
                                spring.animationTime = currentTime;
                                
                                if (spring.currentFrame < 1) {
                                    spring.state = 'idle';
                                    spring.currentFrame = 1;
                                    spring.animationTime = 0;
                                    console.log('🏃‍♂️ 彈簧回復到閒置狀態');
                                }
                            }
                            break;
                    }
                });
            }

            // 繪製Spring
            draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT) {
                this.springs.forEach(spring => {
                    const x = Math.floor(spring.x - camera.x);
                    const y = Math.floor(spring.y - camera.y);
                    
                    if (x + spring.width >= 0 && x <= GAME_WIDTH &&
                        y + spring.height >= 0 && y <= GAME_HEIGHT) {
                        
                        const frameName = `spring-${spring.currentFrame}`;
                        
                        if (this.imagesLoaded && this.images[frameName]) {
                            ctx.save();
                            ctx.imageSmoothingEnabled = false;
                            ctx.drawImage(this.images[frameName], x, y, spring.width, spring.height);
                            ctx.restore();
                        } else {
                            // 預設彈簧樣式
                            ctx.fillStyle = '#4CAF50';
                            ctx.fillRect(x, y, spring.width, spring.height);
                            
                            ctx.strokeStyle = '#2E7D32';
                            ctx.lineWidth = 2;
                            
                            const compressionRatio = spring.currentFrame / 4;
                            const compressedHeight = Math.floor(spring.height * compressionRatio);
                            const offsetY = spring.height - compressedHeight;
                            
                            for (let i = 0; i < 3; i++) {
                                const lineY = y + offsetY + (compressedHeight / 4) * (i + 1);
                                ctx.beginPath();
                                ctx.moveTo(x, lineY);
                                ctx.lineTo(x + spring.width, lineY);
                                ctx.stroke();
                            }
                            
                            ctx.fillStyle = '#ffffff';
                            ctx.font = '8px "Press Start 2P"';
                            ctx.fillText(`S${spring.currentFrame}`, x + 2, y + 10);
                        }
                    }
                });
            }

            // 重置所有Spring狀態
            reset() {
                this.springs.forEach(spring => {
                    spring.state = 'idle';
                    spring.currentFrame = 1;
                    spring.animationTime = 0;
                    spring.isPlayerOn = false;
                    spring.playerStandTime = 0;
                });
            }

            // 清空所有Spring
            clear() {
                this.springs = [];
            }
        }

        // 創建全域Spring管理器
        const springManager = new SpringManager();

        // ===============================
        // HP Logo 血量瓶模組
        // ===============================
        class HpLogoManager {
            constructor() {
                this.hpLogos = [];
                this.image = null;
                this.imageLoaded = false;
            }

            // 載入HP Logo圖片
            loadImage() {
                this.image = new Image();
                this.image.onload = () => {
                    this.imageLoaded = true;
                    console.log('✅ HP Logo圖片載入完成: hp-logo.svg');
                };
                this.image.onerror = () => {
                    console.log('❌ HP Logo圖片載入失敗: hp-logo.svg');
                    this.imageLoaded = false;
                };
                this.image.src = 'hp-logo.svg';
            }

            // 創建HP Logo（水平排列）
            createHorizontalHpLogos(startX, startY, count, spacing, gameHeight) {
                const hpLogoHeightRatio = 41 / 512; // 41像素高度在512背景中的比例
                const hpLogoHeight = Math.floor(gameHeight * hpLogoHeightRatio);
                
                // 根據圖片實際比例計算寬度，如果沒有則假設為正方形
                let hpLogoWidth;
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    const originalRatio = this.image.naturalWidth / this.image.naturalHeight;
                    hpLogoWidth = Math.floor(hpLogoHeight * originalRatio);
                } else {
                    hpLogoWidth = hpLogoHeight; // 預設為正方形
                }

                for (let i = 0; i < count; i++) {
                    this.hpLogos.push({
                        x: startX + i * (hpLogoWidth + spacing),
                        y: startY,
                        width: hpLogoWidth,
                        height: hpLogoHeight,
                        collected: false,
                        id: `horizontal_${i}`,
                        type: 'horizontal'
                    });
                }

                console.log(`🩹 水平HP Logo創建完成，共${count}個`);
                return { width: hpLogoWidth, height: hpLogoHeight };
            }

            // 創建HP Logo（垂直排列）
            createVerticalHpLogos(centerX, bottomY, count, spacing, gameHeight) {
                const hpLogoHeightRatio = 41 / 512; // 41像素高度在512背景中的比例
                const hpLogoHeight = Math.floor(gameHeight * hpLogoHeightRatio);
                
                // 根據圖片實際比例計算寬度，如果沒有則假設為正方形
                let hpLogoWidth;
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    const originalRatio = this.image.naturalWidth / this.image.naturalHeight;
                    hpLogoWidth = Math.floor(hpLogoHeight * originalRatio);
                } else {
                    hpLogoWidth = hpLogoHeight; // 預設為正方形
                }

                // 計算起始X位置以實現置中
                const startX = centerX - Math.floor(hpLogoWidth / 2);

                for (let i = 0; i < count; i++) {
                    this.hpLogos.push({
                        x: startX,
                        y: bottomY - (i + 1) * (hpLogoHeight + spacing), // 從底部往上排列
                        width: hpLogoWidth,
                        height: hpLogoHeight,
                        collected: false,
                        id: `vertical_${i}`,
                        type: 'vertical'
                    });
                }

                console.log(`🩹 垂直HP Logo創建完成，共${count}個`);
                return { width: hpLogoWidth, height: hpLogoHeight };
            }

            // 檢查碰撞
            checkCollisions(player) {
                let collectedCount = 0;
                
                this.hpLogos.forEach(hpLogo => {
                    if (!hpLogo.collected) {
                        if (player.x < hpLogo.x + hpLogo.width &&
                            player.x + player.width > hpLogo.x &&
                            player.y < hpLogo.y + hpLogo.height &&
                            player.y + player.height > hpLogo.y) {
                            
                            hpLogo.collected = true;
                            collectedCount++;
                            console.log(`💊 HP Logo被收集: ${hpLogo.id}`);
                        }
                    }
                });

                return collectedCount;
            }

            // 繪製HP Logo
            draw(ctx, camera, GAME_WIDTH, GAME_HEIGHT) {
                this.hpLogos.forEach(hpLogo => {
                    if (!hpLogo.collected) {
                        const x = Math.floor(hpLogo.x - camera.x);
                        const y = Math.floor(hpLogo.y - camera.y);
                        
                        // 檢查是否在畫面內
                        if (x + hpLogo.width >= 0 && x <= GAME_WIDTH &&
                            y + hpLogo.height >= 0 && y <= GAME_HEIGHT) {
                            
                            if (this.imageLoaded && this.image) {
                                ctx.save();
                                ctx.imageSmoothingEnabled = false;
                                ctx.drawImage(this.image, x, y, hpLogo.width, hpLogo.height);
                                ctx.restore();
                            } else {
                                // 預設樣式：紅色十字
                                ctx.fillStyle = '#ff0000';
                                ctx.fillRect(x, y, hpLogo.width, hpLogo.height);
                                
                                // 繪製十字
                                ctx.fillStyle = '#ffffff';
                                const crossWidth = Math.floor(hpLogo.width * 0.2);
                                const crossHeight = Math.floor(hpLogo.height * 0.6);
                                const horizontalCrossHeight = Math.floor(hpLogo.height * 0.2);
                                const horizontalCrossWidth = Math.floor(hpLogo.width * 0.6);
                                
                                // 垂直線
                                ctx.fillRect(
                                    x + Math.floor((hpLogo.width - crossWidth) / 2), 
                                    y + Math.floor((hpLogo.height - crossHeight) / 2), 
                                    crossWidth, 
                                    crossHeight
                                );
                                
                                // 水平線
                                ctx.fillRect(
                                    x + Math.floor((hpLogo.width - horizontalCrossWidth) / 2), 
                                    y + Math.floor((hpLogo.height - horizontalCrossHeight) / 2), 
                                    horizontalCrossWidth, 
                                    horizontalCrossHeight
                                );
                            }
                        }
                    }
                });
            }

            // 獲取收集到的HP Logo數量
            getCollectedCount() {
                return this.hpLogos.filter(hpLogo => hpLogo.collected).length;
            }

            // 獲取總HP Logo數量
            getTotalCount() {
                return this.hpLogos.length;
            }

            // 重置所有HP Logo狀態
            reset() {
                this.hpLogos.forEach(hpLogo => {
                    hpLogo.collected = false;
                });
            }

            // 清空所有HP Logo
            clear() {
                this.hpLogos = [];
            }
        }

        // 創建全域HP Logo管理器
        const hpLogoManager = new HpLogoManager();
        const cloudManager = new CloudManager();
        const cloudManager2 = new CloudManager2();
        const lightningManager = new LightningManager();
        const lightningManager2 = new LightningManager2();

        // HP Logo圖片載入已移至HpLogoManager模組



        function loadRoadImages() {
            const roadTypes = ['road-1', 'road-kanban', 'road-2', 'road-3', 'road-4', 'road-5', 'road-7', 'road-8', 'road-9', 'road-mid', 'road-short-1', 'road-short-2', 'house-1', 'house-2', 'house-3', 'house-4', 'house-5', 'house-6', 'house-7', 'house-8', 'bridge-1', 'bridge-2', 'laboratory-1', 'laboratory-2', 'cloud-1', 'cloud-2', 'cloud-3', 'lightning'];
            let loadedCount = 0;
            
            roadTypes.forEach(type => {
                const img = new Image();
                img.onload = function() {
                    roadImages[type] = img;
                    // 記錄原始尺寸
                    roadOriginalSizes[type] = {
                        width: this.naturalWidth || this.width,
                        height: this.naturalHeight || this.height
                    };
                    loadedCount++;
                    console.log(`✅ 路面圖片載入完成: ${type}.svg (${roadOriginalSizes[type].width}x${roadOriginalSizes[type].height})`);
                    
                    if (loadedCount === roadTypes.length) {
                        roadsLoaded = true;
                        console.log('🛣️ 所有路面圖片載入完成！');
                        // 圖片載入完成後重新創建世界以應用正確尺寸
                        if (typeof createWorld === 'function') {
                            createWorld();
                        }
                    }
                };
                img.onerror = function() {
                    console.log(`❌ 路面圖片載入失敗: ${type}.svg`);
                    // 使用預設尺寸
                    roadOriginalSizes[type] = {
                        width: 200,
                        height: 32
                    };
                    loadedCount++;
                    if (loadedCount === roadTypes.length) {
                        roadsLoaded = true;
                        if (typeof createWorld === 'function') {
                            createWorld();
                        }
                    }
                };
                img.src = `${type}.svg`;
            });
        }

        function drawRoads() {
            world.roads.forEach(road => {
                // 使用Math.floor確保整數像素位置，避免閃爍
                const x = Math.floor(road.x - camera.x);
                const y = Math.floor(road.y - camera.y);
                
                if (x + road.width >= 0 && x <= GAME_WIDTH &&
                    y + road.height >= 0 && y <= GAME_HEIGHT) {
                    
                    // 嘗試繪製SVG圖片
                    if (roadsLoaded && roadImages[road.type]) {
                        ctx.save();
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(roadImages[road.type], x, y, road.width, road.height);
                        ctx.restore();
                    } else if (road.type === 'laboratory-2') {
                        // laboratory-2顯示為不同的顏色
                        ctx.fillStyle = '#FFD700'; // 金色
                        ctx.strokeStyle = '#FFA500';
                        ctx.lineWidth = 2;
                        ctx.fillRect(x, y, road.width, road.height);
                        ctx.strokeRect(x, y, road.width, road.height);
                    } else {
                        // 如果圖片未載入，繪製預設的方塊
                        if ((road.type === 'road-short-1' || road.type === 'road-short-2') && road.isFalling) {
                            // 掉落中的road-short-1和road-short-2顯示為紅色
                            ctx.fillStyle = '#FF4444';
                            ctx.strokeStyle = '#FF0000';
                        } else {
                            // 其他road顯示為綠色
                            ctx.fillStyle = '#228B22';
                            ctx.strokeStyle = '#32CD32';
                        }
                        ctx.lineWidth = 2;
                        ctx.fillRect(x, y, road.width, road.height);
                        ctx.strokeRect(x, y, road.width, road.height);
                        
                        // 為road-short-1和road-short-2添加標籤
                        if (road.type === 'road-short-1' || road.type === 'road-short-2') {
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = '8px Arial';
                            ctx.fillText(road.id, x + 2, y + 10);
                        }
                        
                        // 顯示文字標示
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '16px "Press Start 2P"';
                        ctx.fillText(road.type, x + 10, y + 30);
                    }
                }
            });
        }

        function drawHpLogos() {
            hpLogos.forEach(hpLogo => {
                // 如果hp-logo已被收集，不繪製
                if (hpLogo.collected) return;
                
                // 使用Math.floor確保整數像素位置，避免閃爍
                const x = Math.floor(hpLogo.x - camera.x);
                const y = Math.floor(hpLogo.y - camera.y);
                
                // 檢查是否在畫面內
                if (x + hpLogo.width >= 0 && x <= GAME_WIDTH &&
                    y + hpLogo.height >= 0 && y <= GAME_HEIGHT) {
                    
                    // 嘗試繪製HP Logo圖片
                    if (hpLogoLoaded && hpLogoImage) {
                        ctx.save();
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(hpLogoImage, x, y, hpLogo.width, hpLogo.height);
                        ctx.restore();
                    } else {
                        // 如果圖片未載入，繪製預設的紅色十字
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(x, y, hpLogo.width, hpLogo.height);
                        
                        // 繪製白色十字
                        ctx.fillStyle = '#ffffff';
                        const crossSize = Math.floor(hpLogo.width * 0.6);
                        const crossThickness = Math.floor(hpLogo.width * 0.15);
                        const centerX = x + hpLogo.width / 2;
                        const centerY = y + hpLogo.height / 2;
                        
                        // 水平線
                        ctx.fillRect(centerX - crossSize/2, centerY - crossThickness/2, crossSize, crossThickness);
                        // 垂直線
                        ctx.fillRect(centerX - crossThickness/2, centerY - crossSize/2, crossThickness, crossSize);
                    }
                }
            });
        }


        
        function drawEndpoint() {
            // 已刪除 lab 藍色框框
            return;
        }
        

        
        function drawPlayer() {
            // 使用Math.floor確保整數像素位置，避免閃爍
            const x = Math.floor(player.x - camera.x);
            const y = Math.floor(player.y - camera.y);
            
            // 設定透明度
            const alpha = player.alpha !== undefined ? player.alpha : 1;
            ctx.globalAlpha = alpha;
            
            let hasValidSprite = false;
            let sprite = null;
            
            if (currentAnimation === 'jumping') {
                // 使用跳躍圖片 (jump-2)
                if (characterSprites.jumping && characterSprites.jumping.complete) {
                    hasValidSprite = true;
                    sprite = characterSprites.jumping;
                }
            } else if (currentAnimation === 'jumpPrepare') {
                // 使用準備跳躍圖片 (jump-1)
                if (characterSprites.jumpPrepare && characterSprites.jumpPrepare.complete) {
                    hasValidSprite = true;
                    sprite = characterSprites.jumpPrepare;
                }
            } else {
                // 檢查是否有有效的動畫幀
                const animFrames = characterSprites[currentAnimation];
                
                // 確保動畫幀索引在有效範圍內
                if (animFrames && animFrames.length > 0 && animationFrame >= animFrames.length) {
                    console.log(`⚠️ 動畫幀索引超出範圍: ${animationFrame} >= ${animFrames.length}，重置為0`);
                    animationFrame = 0;
                }
                
                hasValidSprite = animFrames && 
                              animFrames.length > 0 && 
                              animationFrame < animFrames.length &&
                              animFrames[animationFrame] && 
                              animFrames[animationFrame].complete;
                
                if (hasValidSprite) {
                    sprite = animFrames[animationFrame];
                }
                
                // 調試信息（僅在需要時顯示）
                if (currentAnimation === 'running' && !hasValidSprite) {
                    console.log(`❌ 跑步動畫幀無效: 索引${animationFrame}, 動畫數組長度${animFrames?.length}`);
                }
            }
            
            if (hasValidSprite && sprite) {
                // 繪製自定義角色動畫
                ctx.save();
                
                // 設置高品質渲染
                ctx.imageSmoothingEnabled = false;
                ctx.imageSmoothingQuality = 'high';
                
                // 如果面向左邊，水平翻轉
                if (!player.facingRight) {
                    ctx.scale(-1, 1);
                    ctx.drawImage(sprite, -(x + player.width), y, player.width, player.height);
                } else {
                    ctx.drawImage(sprite, x, y, player.width, player.height);
                }
                
                ctx.restore();
            } else {
                // 使用預設的emoji角色
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(x, y, player.width, player.height);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = '26px "Press Start 2P"';
                
                // 根據面向方向調整emoji
                if (!player.facingRight) {
                    // 面向左邊時稍微偏移
                    ctx.fillText('🧑‍🔬', x + 15, y + 35);
                } else {
                    ctx.fillText('🧑‍🔬', x + 18, y + 35);
                }
            }
            
            // 繪製防護罩效果
            if (player.shieldActive) {
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(x + player.width/2, y + player.height/2, 30, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = '#00ffff';
                ctx.font = '12px "Press Start 2P"';
                ctx.fillText(`${3 - player.shieldHits}`, x + player.width + 8, y + 15);
            }
            
            // 重置透明度
            ctx.globalAlpha = 1;
        }
        
        function gameLoop() {
            update();
            springManager.update(player);
            render();
            if (gameState === 'playing') {
                gameLoopId = requestAnimationFrame(gameLoop);
            }
        }
        
        window.addEventListener('load', init);
    </script>
</body>
</html>
